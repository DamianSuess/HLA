#if( !@defined( hlabe_hhf ))
?hlabe_hhf := true;

#includeOnce( "tables.hhf" )
#includeOnce( "w.hhf" )


const
	// Used to emit some extra data to the code file for debugging purposes:
	
	trace_c		:= false;
	dbgTrace_c	:= false;
	verbose_c	:= false;

	// Values for symbol_t "flags" field:
	
	isExtern_c		:= @{0};
	isPublic_c		:= @{1};
	isReferenced_c	:= @{2};
	isDefined_c		:= @{3};
	
	// Brand values for ELF files:
	
	brandNone		:= 0;
	brandLinux		:= 3;
	brandFreeBSD	:= 9;
	


	tknEBX		:text := "(type tokenStmt_t [ebx])";
	dispEBX		:text := "(type disp_t [ebx])";
	rel1EBX		:text := "(type rel_1_Stmt_t [ebx])";
	rel2EBX		:text := "(type rel_2_Stmt_t [ebx])";
	rel14EBX	:text := "(type rel_1_4_Stmt_t [ebx])";
	rel4EBX		:text := "(type rel_4_Stmt_t [ebx])";
	jmpEBX		:text := "(type jmp_Stmt_t [ebx])";
	srcEBX		:text := "(type sourceFileList_t [ebx])";
	dupEBX		:text := "(type dupStmt_t [ebx])";
	tblEDX		:text := "(type tableNode_t [edx])";
	tblEAX		:text := "(type tableNode_t [eax])";
	symEDX		:text := "(type symbol_t [edx])";
	symEAX		:text := "(type symbol_t [eax])";
	symECX		:text := "(type symbol_t [ecx])";
	symEBX		:text := "(type symbol_t [ebx])";
	relocESI	:text := "(type w.IMAGE_RELOCATION [ESI])";
	relocElfESI	:text := "(type Elf32_Rel [ESI])";

	// ELF constants
	
	EI_NIDENT	:= 16;
	ET_NONE		:= 0;
	ET_REL		:= 1;
	ET_EXEC		:= 2;
	ET_DYN		:= 3;
	ET_CORE		:= 4;
	ET_LOOS		:= $FE00;
	ET_HIOS		:= $FEFF;
	ET_LOPROC	:= $FF00;
	
	EF_HIPROC	:= $FFFF;
	
	EM_386		:= 3;
	
	EV_NONE		:= 0;
	EV_CURRENT	:= 1;
	
	EI_MAG0			:= 0;
	EI_MAG1			:= 1;
	EI_MAG2			:= 2;
	EI_MAG3			:= 3;
	EI_CLASS		:= 4;
	EI_DATA			:= 5;
	EI_VERSION		:= 6;
	EI_OSABI		:= 7;
	EI_ABIVESION	:= 8;
	EI_PAD			:= 9;
	
	ELFMAG0			:= $7F;
	ELFMAG1			:= 'E';
	ELFMAG2			:= 'L';
	ELFMAG3			:= 'F';
	
	ELFCLASSNONE	:= 0;
	ELFCLASS32		:= 1;
	ELFCLASS64		:= 2;
	
	ELFDATANONE		:= 0;
	ELFDATA2LSB		:= 1;		// Little Endian
	ELFDATA2MSB		:= 2;		// Big Endian
	
	ELFOSABI_NONE		:= 0;
	ELFOSABI_HPUX		:= 1;
	ELFOSABI_NETBSD		:= 2;
	ELFOSABI_LINUX		:= 3;
	ELFOSABI_SOLARIS	:= 6;
	ELFOSABI_AIX		:= 7;
	ELFOSABI_IRIX		:= 8;
	ELFOSABI_FREEBSD	:= 9;		// FreeBSD Brand
	ELFOSABI_TRU64		:= 10;
	ELFOSABI_MODESTO	:= 11;
	ELFOSABI_OPENBSD	:= 12;
	ELFOSABI_OPENVMS	:= 13;
	ELFOSABI_NSK		:= 14;
	ELFOSABI_AROS		:= 15;
	
	SHN_UNDEF			:= 0;
	SHN_LORESERVE		:= $FF00;
	SHN_LOPROC			:= $FF00;
	SHN_HIPROC			:= $FF1F;
	SHN_LOOS			:= $FF20;
	SHN_HIOS			:= $FF3F;
	SHN_ABS				:= $FFF1;
	SHN_COMMON			:= $FFF2;
	SHN_XINDEX			:= $FFFF;
	SHN_HIRESERVE		:= $FFFF;
	
	SHT_NULL			:= 0;
	SHT_PROGBITS		:= 1;
	SHT_SYMTAB			:= 2;
	SHT_STRTAB			:= 3;
	SHT_RELA			:= 4;
	SHT_HASH			:= 5;
	SHT_DYNAMIC			:= 6;
	SHT_NOTE			:= 7;
	SHT_NOBITS			:= 8;
	SHT_REL				:= 9;
	SHT_SHLIB			:= 10;
	SHT_DYNSYM			:= 11;
	SHT_INIT_ARRAY		:= 14;
	SHT_FINI_ARRAY		:= 15;
	SHT_PREINIT_ARRAY	:= 16;
	SHT_GROUP			:= 17;
	SHT_SYMTAB_SHNDX	:= 18;
	SHT_LOOS			:= $6000_0000;
	SHT_HIOS			:= $6fff_ffff;
	SHT_LOPROC			:= $7000_0000;
	SHT_HIPROC			:= $7fff_ffff;
	SHT_LOUSER			:= $8000_0000;
	SHT_HIUSER			:= $ffff_ffff;
	
	SHF_WRITE				:= 1;
	SHF_ALLOC				:= 2;
	SHF_EXECINSTR			:= 4;
	SHF_MERGE				:= $10;
	SHF_STRINGS				:= $20;
	SHF_INFO_LINK			:= $40;
	SHF_LINK_ORDER			:= $80;
	SHF_OS_NONCONFORMING	:= $100;
	SHF_GROUP				:= $200;
	SHF_TLS					:= $400;
	SHF_MASKOS				:= $FF0_0000;
	SHF_MASKPROC			:= $F000_0000;
	
	GRP_COMDAT			:= 1;
	GRP_MASKOS			:= $FF0_0000;
	GRP_MASKPROC		:= $F000_0000;
	
	STB_LOCAL			:= 0;
	STB_GLOBAL			:= 1;
	STB_WEAK			:= 2;
	STB_LOOS			:= 10;
	STB_HIOS			:= 12;
	STB_LOPROC			:= 13;
	STB_HIPROC			:= 15;
	
	STT_NOTYPE			:= 0;
	STT_OBJECT			:= 1;
	STT_FUNC			:= 2;
	STT_SECTION			:= 3;
	STT_FILE			:= 4;
	STT_COMMON			:= 5;
	STT_TLS				:= 6;
	STT_LOOS			:= 10;
	STT_HIOS			:= 12;
	STT_LOPROC			:= 13;
	STT_HIPROC			:= 15;
	
	STV_DEFAULT			:= 0;
	STV_INTERNAL		:= 1;
	STV_HIDDEN			:= 2;
	STV_PROTECTED		:= 3;
	
	R_386_NONE			:= 0;
	R_386_32			:= 1;
	R_386_PC32			:= 2;
	
	
	
	
		
	
type
	// ELF types:
	
	Elf32_Addr	:dword;
	Elf32_Off	:dword;
	Elf32_Half	:word;
	Elf32_Word	:uns32;
	Elf32_Sword	:int32;
	
	Elf32_Ehdr:
		record
		
			e_ident		:char[ EI_NIDENT ];
			e_type		:Elf32_Half;
			e_machine	:Elf32_Half;
			e_version	:Elf32_Word;
			e_entry		:Elf32_Addr;
			e_phoff		:Elf32_Off;
			e_shoff		:Elf32_Off;
			e_flags		:Elf32_Word;
			e_ehsize	:Elf32_Half;
			e_phentsize	:Elf32_Half;
			e_phnum		:Elf32_Half;
			e_shentsize	:Elf32_Half;
			e_shnum		:Elf32_Half;
			e_shstrndx	:Elf32_Half;
			
		endrecord;
		
	Elf32_Shdr:
		record
		
			sh_name			:Elf32_Word;
			sh_type			:Elf32_Word;
			sh_flags		:Elf32_Word;
			sh_addr			:Elf32_Addr;
			sh_offset		:Elf32_Off;
			sh_size			:Elf32_Word;
			sh_link			:Elf32_Word;
			sh_info			:Elf32_Word;
			sh_addralign	:Elf32_Word;
			sh_entsize		:Elf32_Word;
			
		endrecord;
		
	Elf32_Sym:
		record
		
			st_name		:Elf32_Word;
			st_value	:Elf32_Addr;
			st_size		:Elf32_Word;
			st_info		:byte;
			st_other	:byte;
			st_shndx	:Elf32_Half;
			
		endrecord;
		
	Elf32_Rel:
		record
		
			r_offset	:Elf32_Addr;
			r_info		:Elf32_Word;
			
		endrecord;
		
	Elf32_Rela:
		record
		
			r_offset	:Elf32_Addr;
			r_info		:Elf32_Word;
			r_addend	:Elf32_Sword;
			
		endrecord;
			
			
	
	
	

	// HLABE supports a three-section object file model (like a.out),
	// a text/code section, a static/data section, and a BSS section:
	
	section_t	:enum
	{
		undefinedSection_c,
		code_c,		// Must be in this order!
		data_c,
		bss_c
	};
	
	// Supported object file formats:
	
	obj_t		:enum
	{
		pecoff_c,
		elf_c,
		elfLinux_c,
		elfFreeBSD_c,
		macho_c
	};
	?minElf_c := elf_c;
	?maxElf_c := elfFreeBSD_c;
	
	
	// Data type for a symbol table entry:
	
	symbol_t	:record
	
		next		:pointer to symbol_t;
		id			:string;
		symIndex	:uns32;				// index to symbol table entry
		offset		:dword;
		section		:section_t;
		flags		:byte;
		align(4);
			
	endrecord;
	
	
	tokens_t	:enum
	{
		start_tkn,				// Start-of-token-list token.
		align_tkn,				// .a	<x>
		bytes_tkn,				// Any absolute data
		
		label_tkn,				// :label definition
		
		reloc_tkn,				// Relocatable expression
		
		reserve_tkn,			// Reserve storage
		dupByte_tkn,			// Duplicate byte data
		dupWord_tkn,			// Duplicate word data
		dupDword_tkn,			// Duplicate dword data
				
		code_tkn,				// .c
		readonly_tkn,			// .y
		data_tkn,				// .s
		bss_tkn,				// .v
		
		rel1_tkn,				// loopX, jecxz, etc., that have 1-byte disp
		rel2_tkn,				// jcxz with 2-byte opcode and 1-byte disp
		rel1_4_tkn,				// Jmp instrs that have 1 or 4-byte disp
		rel4_tkn,				// Instrs (e.g., 'call') that have 4-byte disp
		jmp_tkn,				// Jmp disp instructions that have 1 or 4-byte disp
		
		public_tkn,				// .p
		extern_tkn,				// .x
		
		dummy_tkn				// Dummy record emitted at the end of a section.
	};
	
	tokenStmt_t	:record
	
		prev		:pointer to tokenStmt_t;
		next		:pointer to tokenStmt_t;
		token		:tokens_t;
		instrOffset	:dword;
		
	endrecord;
	
	// ":lbldef" creates this record:
	
	labelStmt_t	:record inherits( tokenStmt_t );
	
		symTabEntry	:tableNodePtr_t;
		
	endrecord;
	
	
	
	// ".a <n>" creates this record:
	
	alignStmt_t	:record inherits( tokenStmt_t );
	
		alignExpr	:dword;
		
	endrecord;
	
	
	// Data structure used by data declaration statements:
	
	varLen_t	:record inherits( tokenStmt_t );
	
		numBytes	:dword;
		
	endrecord;
	
	
	// ".b <n>" creates this record (and any other statement
	// that emits absolute data):
	
	byteStmt_t	:record inherits( varLen_t );
	
		byteData	:byte[1];	// Variable length
		
	endrecord;
	
	
	
	
	// ".d <reloc expr>" creates this record:
	
	relocStmt_t	:record inherits( tokenStmt_t );
	
		symbol		:tableNodePtr_t;
		offset		:dword;
		
	endrecord;
	
	
	// All the jump and call instructions have the following fields in common:
	
	sflPtr			:pointer to sourceFileList_t;
	sourceFileList_t	:record
	
		next		:sflPtr;
		filename	:string;
		lineNumber	:uns32;
		
	endrecord;
	
	disp_t	:record inherits( tokenStmt_t );
	
		disp		:int32;
		symbol		:tableNodePtr_t;
		offset		:dword;
		line		:sflPtr;
		
	endrecord;
	
	
	// Two-byte (only) conditional jumps emit this record:
	
	rel_1_Stmt_t	:record inherits( disp_t );
	
		opcode		:byte;
		
	endrecord;
	
	// rel_2_Stmt_t - used by jcxz.
	
	rel_2_Stmt_t	:record inherits( disp_t );
	
		opcode		:word;
		
	endrecord;
	
	
	// Four-byte (only) control-transfer instructions emit this record:
	
	rel_4_Stmt_t	:record inherits( disp_t );
	
		opcode		:byte;
		
	endrecord;
	
	
	// Variable-length Jcc instructions emit this record:
	
	rel_1_4_Stmt_t	:record inherits( disp_t );
	
		opcode1		:byte;
		opcode2		:word;
		curOfsSize	:byte;
		
	endrecord;
	
	
	// Jmp disp instructions emit this record:
	
	jmp_Stmt_t	:record inherits( disp_t );
	
		opcode1		:byte;
		opcode2		:byte;
		curOfsSize	:byte;
		
	endrecord;
	
	
	// ".ub <n>,<m>", ".uw <n>,<m>", and ".ud <n>,<m>" create these records:
	
	dupStmt_t	:record inherits( tokenStmt_t );
	
		size		:dword;
		count		:dword;
		data		:dword;
		
	endrecord;
	
	
	
	
	// ".r <n>" creates this record:
	
	reserveStmt_t	:record inherits( tokenStmt_t );
	
		sizeExpr	:dword;
		
	endrecord;
	
	
	
	
	
	
	tokenList_t	:pointer to tokenStmt_t;
	
	
	
	
static
	codeSize		:dword;					@external;
	numCodeRelocs	:dword;					@external;
	dataSize		:dword;					@external;
	numDataRelocs	:dword;					@external;
	bssSize			:dword;					@external;

    symbolTable     :table_t;				@external;
    equatesTable    :table_t;				@external;
	
	currentSection  :section_t;				@external;
	verbose			:boolean;				@external;



	#macro _proc( string procname ):dummy,dummy2;

		?dummy := procname + @string(dummy2);		
		#if( trace_c )
		
			procedure @text( dummy ); @noframe;
			begin @text( dummy );
			byte procname,0;
			nop;
			nop;
			nop;
			align(4);
			end @text( dummy );
			
		#endif
		procedure @text( procname )
		
	#endmacro

	#macro _begin( string procname ):dummy,dummy2;

		?dummy := procname + @string(dummy2);		
		#if( trace_c )
		
			procedure @text( dummy ); @noframe;
			begin @text( dummy );
			byte "begin ", procname,0;
			nop;
			nop;
			nop;
			align(4);
			end @text( dummy );
			
		#endif
		begin @text( procname )
		
			#if( dbgTrace_c ) 
			
				;stdout.put( procname, nl );
				
			#endif 
		
	#endmacro

	#macro _end( string procname ):dummy,dummy2;

		end @text( procname );
		?dummy := procname + @string(dummy2);		
		#if( trace_c )
		
			procedure @text( dummy ); @noframe;
			begin @text( dummy );
			byte " end ", procname,0;
			nop;
			nop;
			nop;
			align(4);
			end @text( dummy )
			
		#endif
		
		
	#endmacro

	// Print the file name/line numbers associated with a branch stmt:
	
	procedure printLineNumberChain( var dispRec:disp_t in ebx ); @external;
	
	
	// HLABE lexical analyzer:
	
	procedure lexer
	( 
				start_source	:dword; 
				end_src 		:dword; 
		result	codeListHead	:tokenList_t;
		result	dataListHead	:tokenList_t;
		result	bssListHead		:tokenList_t
	);	@external;
	
	
	
	// Optimize the branch displacements
	
	procedure optimizeDisps
	( 
		codeList	:tokenList_t;
		dataList	:tokenList_t;
		bssList	    :tokenList_t;
		verbose		:boolean
	);	@external;
	
	
	// Generate COFF file from compiled code:
	
	procedure compileCOFF
	( 
			inputFilename	:string;
			outputFilename	:string; 
			start_source	:dword; 
			end_source		:dword;
			verbose			:boolean; 
		var	codeListPtr		:tokenList_t;
		var	dataListPtr		:tokenList_t;
		var	bssListPtr	    :tokenList_t
	);	@external;
	
	
	
	// Generate ELF file from compiled code:
	
	procedure compileELF
	( 
			inputFilename	:string;
			outputFilename	:string; 
			start_source	:dword; 
			end_source		:dword;
			brand			:obj_t;
			verbose			:boolean; 
		var	codeListPtr		:tokenList_t;
		var	dataListPtr		:tokenList_t;
		var	bssListPtr	    :tokenList_t
	);	@external;
	
	
	// Generate Mach-O file from compiled code:
	
	procedure compileMACHO
	( 
				inputFilename	:string;
				outputFilename	:string; 
				start_source	:dword; 
				end_source		:dword;
				verbose			:boolean; 
		result	codeListPtr		:tokenList_t;
		result	dataListPtr		:tokenList_t;
		result	bssListPtr	    :tokenList_t
	);	@external;
	
	
	// C-callable function to compile an HLABE source file:
	// Two names for the same function because of naming
	// convention differences between various OSes.
	
	
	procedure hlabe_compile
	(
			inputFilename	:zstring;
			outputFilename	:zstring; 
			start_source	:dword; 
			end_source		:dword;
			objType			:obj_t;
			verbose			:boolean 
	);	@cdecl;
		@external( "hlabe_compile" );

	procedure _hlabe_compile
	(
			inputFilename	:zstring;
			outputFilename	:zstring; 
			start_source	:dword; 
			end_source		:dword;
			objType			:obj_t;
			verbose			:boolean 
	);	@cdecl;
		@external( "_hlabe_compile" );

	
#endif
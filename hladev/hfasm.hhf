// flat assembler  version 1.66
// Copyright (c) 1999-2006, Tomasz Grysztar.  
// All rights reserved.
//
// This programs is free for commercial and non-commercial use as long as
// the following conditions are adhered to.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// The licence and distribution terms for any publically available
// version or derivative of this code cannot be changed. i.e. this code
// cannot simply be copied and put under another distribution licence
// (including the GNU Public Licence).
//
//
// Auxilary note:
//
//	"Randall Hyde" qualifies as a contributor under the above notice.



procedure shorthwExcept__hla_; 		@external( "shorthwExcept__hla_" );
procedure shortDfltExcept__hla_;	@external( "shortDfltExcept__hla_" );
procedure BuildExcepts__hla_;		@external( "BuildExcepts__hla_" );


// Some commonly used constants:

const
	cr		:char 	:= #$d;
	lf		:char	:= #$a;
	ctlz	:char	:= #$1a;
	tab		:char	:= #$09;
	
	// Token used to mark auxillary data (text expansions, etc.)
	// that didn't directly appear in the original source line.
	
	auxDataToken	:byte := $3B;
	
	// Token used to embed length-prefixed strings into the
	// internal source file format:
	
	lenStrTkn		:byte := $1A;


	VERSION_STRING := "C1.66";
	VERSION_MAJOR := 1;
	VERSION_MINOR := 66;
	LABEL_STRUCTURE_SIZE := 32;





// Useful macros:


#macro _byte(b);
	(b & $FF)
#endmacro

#macro _word(w);
	(w & $FFFF)
#endmacro

// Macros to convert 1-4 character string literals to WORD and DWORD values:

#macro asWord(s):_i_, _result_;

	?_result_ :word := 0;
	#for( _i_ := @length(s)-1 downto 0 )
	
		?_result_ := 
			(_result_ << 8) + byte( char(@substr( s, _i_, 1 )));
	
	#endfor
	_result_		
				  
#endmacro


#macro asDword(s):_i_, _result_;

	?_result_ :dword := 0;
	#for( _i_ := @length(s)-1 downto 0 )
	
		?_result_ := 
			(_result_ << 8) + byte( char(@substr( s, _i_, 1 )));
	
	#endfor
	_result_
				  
#endmacro
	


// symfunc_t emits a length-prefixed string (pascal string)
// followed by a dword pointer to some code address

#macro symfunc_t(strng,adrs);

	byte @length(strng), strng;
	dword &adrs;

#endmacro

	


#macro fatal_err(s);

	call fatal_error;
	byte s, 0;
	
#endmacro

#macro asm_error(s);

	call assembler_error;
	byte s, 0;
	
#endmacro


// debugStr- Emits a string to the code stream if debug is true
// Note: do not use outside the code stream.

#macro debugStr(s);
	#if( debug )
	
		int(3);
		int(3);
		int(3);
		byte s,0;
		int(3);
		int(3);
		int(3);
		
	#endif
#endmacro

?out_of_memory_counter := 0;
?display_out_of_memory := false;	// Set to true to debug "out of memory" errors.

#macro out_of_mem( cond,toprint[] ):skipIt, __i__;

	#if( @elements( toprint ) = 2 )
	
		cmp( @text( toprint[0] ), @text( toprint[1] ));
		
	#endif
	#if( display_out_of_memory & !standalone )
	
		if( @text( "@" + @string(cond) ) ) then
		
			puts( "Out of memory position: " );
			putu32( out_of_memory_counter );
			put_newln();
			#for( __i__ := 0 to @elements(toprint) -1)
				puts( toprint[__i__] + " = " );
				puthex32( @text( toprint[__i__] ));
				put_newln();
			#endfor
			jmp out_of_memory;
			
		endif
	 
	#else
	
		@text( "j"+@string(cond) ) out_of_memory
		
	#endif
	?out_of_memory_counter += 1;
	
#endmacro

	
// proc is mainly for debugging purposes.
// If the global constant "debug" is true, then
// this macro will emit the procedure's name as
// a zero-terminated string before the procedure's
// declaration (in the code stream).
//
// This macro also automatically makes the symbol
// a public symbol so you'll get debugging information
// in the .OBJ file (assumes that the back-end assembler
// supports this; e.g., MASM).
//
// WARNING! Do not use this macro to define a procedure
// if the previous procedure falls through to the
// procedure you're defining.

#macro proc(string p):_p_, _q_, _r_, _index_;


	#if( @index( p, 0, ";" ) < @index( p, 0, "(" ))
	
		// If ";" appears before a "(" then we've
		// got a procedure name w/o parameters or
		// no semicolon after the parameters
		
		?_index_ := @index( p, 0, ";" );
		?_r_ := p;
		#if( _index_ <> -1 )
		
			?_r_ := @substr( p, 0, _index_ );
			
		#endif
		?_q_ := _r_;
		?_index_ := @index( _r_, 0, "(");
		#if( _index_ <> -1 )
		
			?_q_ := @trim( @substr( _r_, 0, _index_ ), 0 );
			
		#endif 
		
	#else
	
		// At this point we've either got some parameters
		// or we have neither parameters nor a ";"
		
		?_index_ := @index( p, 0, ")" );
		?_r_ := p;
		#if( _index_ <> -1 )
		
			?_r_ := @substr( p, 0, _index_+1 );
			
		#else
		
			?_index_ := @index( p, 0, ";" );
			#if( _index_ <> -1 )
			
				?_r_ := @substr( p, 0, _index_ );
				
			#endif
			
		#endif
		?_q_ := _r_;
		?_index_ := @index( _r_, 0, "(");
		#if( _index_ <> -1 )
		
			?_q_ := @trim( @substr( _r_, 0, _index_ ), 0 );
			
		#endif 
		
	#endif
	
	#if( debug )
	
		procedure _p_;
		begin _p_;
			int(3);
			int(3);
			int(3);
			int(3);
			byte	_q_, 0;
			int(3);
			int(3);
			int(3);
			int(3);
		end _p_;
	  
		#if( !@defined(_q_))
		
			procedure @text(_r_); @external;
		
		#endif
		
	#endif
				
	procedure @text(p);
	begin @text(_q_);
	#if( debug & debug2 )
	
		pushfd();
		puts( "Entered " + _q_ );
		put_newln();
		popfd();
		
	#endif

#endmacro


// enumList takes the parameter list and creates a set of
// consecutive constant values (starting with value startVal).

#macro enumList( startVal, theList[] );
const
	#for( _i_ := 0 to @elements( theList )-1 )
	
		@text( theList[_i_] ) := startVal + _i_;
		
	#endfor

#endmacro






// Constant definitions for the application-specific exceptions
	
namespace fatal;

	@global:enumList
	(
		$3000,
		out_of_memory,
		out_of_memory_reading_file,
		could_not_allocate_memory,
		stack_overflow,
		unexpected_end_of_file,
		code_cannot_be_generated,
		format_limitations_exceeded,
		write_failed,
		main_file_not_found
	);
			
end fatal;

namespace aerr;

	@global:enumList
	(
		$4000,
		address_sizes_do_not_agree,
		data_already_defined,
		error_reading_file,
		extra_characters_on_line,
		file_not_found,
		illegal_instruction,
		incomplete_macro,
		invalid_address,
		invalid_address_size,
		invalid_argument,
		invalid_expression,
		invalid_file_format,
		invalid_macro_arguments,
		invalid_name,
		invalid_operand,
		invalid_operand_size,
		invalid_use_of_symbol,
		invalid_value,
		long_immediate_not_encodable,
		missing_end_directive,
		missing_end_quote,
		name_too_long,
		operand_size_not_specified,
		operand_sizes_do_not_match,
		prefix_conflict,
		relative_jump_out_of_range,
		reserved_word_used_as_symbol,
		section_not_aligned_enough,
		setting_already_specified,
		symbol_already_defined,
		too_many_repeats,
		undefined_symbol,
		unexpected_characters,
		unexpected_instruction,
		value_out_of_range
	);
	
end aerr;





const
	// COFF_File_Header Machine type field
	
	IMAGE_FILE_MACHINE_I386        := $014c;
	IMAGE_FILE_MACHINE_AMD64       := $8664;
	
	// COFF_File_Header  Characteristics field
	
	IMAGE_FILE_RELOCS_STRIPPED     := $0001;
	IMAGE_FILE_EXECUTABLE_IMAGE    := $0002;
	IMAGE_FILE_LINE_NUMS_STRIPPED  := $0004;
	IMAGE_FILE_LOCAL_SYMS_STRIPPED := $0008;
	IMAGE_FILE_AGGRESIVE_WS_TRIM   := $0010;
	IMAGE_FILE_LARGE_ADDRESS_AWARE := $0020;
	IMAGE_FILE_BYTES_REVERSED_LO   := $0080;
	IMAGE_FILE_32BIT_MACHINE       := $0100;
	IMAGE_FILE_DEBUG_STRIPPED      := $0200;
	IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP := $0400;
	IMAGE_FILE_NET_RUN_FROM_SWAP   := $0800;
	IMAGE_FILE_SYSTEM              := $1000;
	IMAGE_FILE_DLL                 := $2000;
	IMAGE_FILE_UP_SYSTEM_ONLY      := $4000;
	IMAGE_FILE_BYTES_REVERSED_HI   := $8000;
	


type
	COFF_File_Header:
		record
			machine					:word;
			NumberOfSections		:word;
			TimeDateStamp			:dword;
			PointerToSymbolTable	:dword;
			NumberOfSymbols			:dword;
			SizeOfOptionalHeader	:word;
			Characteristics			:word;
		endrecord;
		
	

const
	// Magic # values for optional header:
	
	PE32		:= $10b;
	PE32Plus	:= $20b;
	
	// Subsystem values:
	
	IMAGE_SUBSYSTEM_UNKNOWN        := 0;
	IMAGE_SUBSYSTEM_NATIVE         := 1;
	IMAGE_SUBSYSTEM_WINDOWS_GUI    := 2;
	IMAGE_SUBSYSTEM_WINDOWS_CUI    := 3;
	IMAGE_SUBSYSTEM_POSIX_CUI      := 7;
	IMAGE_SUBSYSTEM_NATIVE_WINDOWS := 8;
	
type
	COFF_Header:
		record
			magic					:word;
			MajorLInkerVersion		:byte;
			MinorLinkerVersion		:byte;
			SizeOfCode				:dword;
			SizeOfInitializedData	:dword;
			SizeOfUninitializedData	:dword;
			AddressOfEntryPoint		:dword;
			BaseOfData				:dword;
			BaseOfCode				:dword;
			ImageBase				:dword;
			SectionAlignment		:dword;
			FileAlignment			:dword;
			MajorOSVersion			:word;
			MinorOSVersion			:word;
			MajorImageVersion		:word;
			MinorImageversion		:word;
			MajorSubsystemVersion	:word;
			MinorSubsystemVersion	:word;
			Win32VersionValue		:dword;
			SizeOfImage				:dword;
			SizeOfHeaders			:dword;
			CheckSum				:dword;
			Subsystem				:word;
			DllCharacteristics		:word;
			SizeOfStackReserve		:dword;
			SizeOfStackCommit		:dword;
			SizeOfHeapReserve		:dword;
			SizeOfHeapCommit		:dword;
			LoaderFlags				:dword;
			NumberOfRvaAndSizes		:dword;
		endrecord;


const
	// Values for the COFF_Section_Header Characteristics field:
	
	IMAGE_SCN_TYPE_NO_PAD          := $00000008;
	IMAGE_SCN_CNT_CODE             := $00000020;
	IMAGE_SCN_CNT_INITIALIZED_DATA := $00000040;
	IMAGE_SCN_CNT_UNINITIALIZED_DATA := $00000080;
	IMAGE_SCN_LNK_OTHER            := $00000100;
	IMAGE_SCN_LNK_INFO             := $00000200;
	IMAGE_SCN_LNK_REMOVE           := $00000800;
	IMAGE_SCN_LNK_COMDAT           := $00001000;
	IMAGE_SCN_NO_DEFER_SPEC_EXC    := $00004000;
	IMAGE_SCN_GPREL                := $00008000;
	IMAGE_SCN_MEM_FARDATA          := $00008000;
	IMAGE_SCN_MEM_PURGEABLE        := $00020000;
	IMAGE_SCN_MEM_16BIT            := $00020000;
	IMAGE_SCN_MEM_LOCKED           := $00040000;
	IMAGE_SCN_MEM_PRELOAD          := $00080000;
	IMAGE_SCN_ALIGN_1BYTES         := $00100000;
	IMAGE_SCN_ALIGN_2BYTES         := $00200000;
	IMAGE_SCN_ALIGN_4BYTES         := $00300000;
	IMAGE_SCN_ALIGN_8BYTES         := $00400000;
	IMAGE_SCN_ALIGN_16BYTES        := $00500000;
	IMAGE_SCN_ALIGN_32BYTES        := $00600000;
	IMAGE_SCN_ALIGN_64BYTES        := $00700000;
	IMAGE_SCN_ALIGN_128BYTES       := $00800000;
	IMAGE_SCN_ALIGN_256BYTES       := $00900000;
	IMAGE_SCN_ALIGN_512BYTES       := $00A00000;
	IMAGE_SCN_ALIGN_1024BYTES      := $00B00000;
	IMAGE_SCN_ALIGN_2048BYTES      := $00C00000;
	IMAGE_SCN_ALIGN_4096BYTES      := $00D00000;
	IMAGE_SCN_ALIGN_8192BYTES      := $00E00000;
	IMAGE_SCN_LNK_NRELOC_OVFL      := $01000000;
	IMAGE_SCN_MEM_DISCARDABLE      := $02000000;
	IMAGE_SCN_MEM_NOT_CACHED       := $04000000;
	IMAGE_SCN_MEM_NOT_PAGED        := $08000000;
	IMAGE_SCN_MEM_SHARED           := $10000000;
	IMAGE_SCN_MEM_EXECUTE          := $20000000;
	IMAGE_SCN_MEM_READ             := $40000000;
	IMAGE_SCN_MEM_WRITE            := $80000000;
	IMAGE_SCN_SCALE_INDEX          := $00000001;
	

type
	COFF_Section_Header:
		record
			sectionName				:char[8];	// 0
			VirtualSize				:dword;		// 8
			VirtualAddress			:dword;		// $c
			SizeOfRawData			:dword;		// $10
			PointerToRawData		:dword;		// $14
			PointerToRelocations	:dword;		// $18
			PointerToLineNumbers	:dword;		// $1c
			NumberOfRelocations		:word;		// $20
			NumberOfLineNumbers		:word;		// $22
			Characteristics			:dword;		// $24
		endrecord;


type
	FASM_Section_Header:
		record
			SectionType			:byte[4];		// 0
			SectionName			:dword;			// 4
			StartOfSection		:dword;			// 8
			SectionSize			:dword;			// $c
			SectionAlignment	:dword;			// $10
			Characteristics		:dword;			// $14
			unknown1			:dword;
			unknown2			:dword;
		endrecord;			

	FASM_RelocationRecord:
		record
			VirtualAddress		:dword;
			SymbolTableIndex	:dword;
			relocType			:word;
		endrecord;



const
	fSectionEBX	:text := "(type FASM_Section_Header [ebx])";
	fSectionEDX	:text := "(type FASM_Section_Header [edx])";
	fSectionESI	:text := "(type FASM_Section_Header [esi])";

	cSectionEBX	:text := "(type COFF_Section_Header [ebx])";
	cSectionEDX	:text := "(type COFF_Section_Header [edx])";
	cSectionEDI	:text := "(type COFF_Section_Header [edi])";

	fRelocESI	:text := "(type FASM_RelocationRecord [esi])";

{\rtf1\ansi\ansicpg10000\deff0\deflang1033\deflangfe1033\deftab360{\fonttbl{\f0\fnil\fprq2\fcharset0 Times New Roman;}{\f1\fnil\fprq2\fcharset0 Courier New;}{\f2\froman\fcharset77 Times-Roman;}{\f3\fnil\fprq2\fcharset0 Helvetica;}{\f4\fnil\fprq2\fcharset0 Courier;}{\f5\fmodern\fcharset77 Courier-Oblique;}{\f6\froman\fcharset77 Times-Italic;}{\f7\fnil\fprq2\fcharset0 Arial;}{\f8\fnil\fprq2\fcharset2 Symbol;}}
{\colortbl ;\red0\green0\blue255;\red0\green0\blue0;}
{\*\generator Msftedit 5.41.15.1515;}\viewkind4\uc1\pard\b\f0\fs28 HLA Basic\par
\b0\fs20\par
\par
HLA Basic is a relatively simple to learn and use language that will run in a combination compiled/interpreted mode.  HLA Basic is a public-domain/open source product so you can freely use it in any project without fear of licensing or copyright restrictions.\par
\par
HLA Basic is not intended to be used as a stand-alone programming language. Instead, HLA Basic is an \i embedded programming language\i0 .  This means that HLA Basic programs are part of some larger application (that is, the Basic program is embedded in some other application). The primary intent of the HLA Basic language is to allow HLA (High Level Assembly) programmers to include \i user programmability\i0  into their assembly language applications.  That is, the end user of some HLA application can write small programs in HLA Basic that are loaded into that HLA application and change the behavior of that application.  This, for example, could be used to create super-powerful user-defined macros and other programmable snippets for the main HLA program.  Although it is possible to write a short HLA application that serves only to execute an HLA Basic program (and, indeed, the HLA Basic system supplies such an application), the real power of HLA Basic is realized by incorporating one or more HLA Basic programs as part of a large HLA application.\par
\par
HLA Basic programs can be edited by any standard text editor (e.g., vi, emacs, or any other Linux, Mac OSX, FreeBSD text editor; or any Windows-compatible text editor) that works with standard Unix or Windows text files.  HLA BASIC programs are \lquote compiled\rdblquote  into a special \i byte code\i0  which is saved to a binary file. A main HLA application will load and execute these HLA BASIC byte code programs.\par
\par
\b\fs28 Compiling HLA Basic Programs\par
\par
\b0\fs20 HLA Basic programs are compiled using the HLA Basic compiler (bc). The HLA Basic compiler is a portable application the runs under Windows, Linux, Mac OS, or FreeBSD.  Running the HLA Basic compiler is the same, regardless of the OS on which it is running.  This documentation assumes that the HLA Basic toolset is installed on your machine and that you can run it from a command-line prompt (that is, the executable is in the OS\rquote  execution path). \par
\par
The first step, as for any program, is to create a HLA Basic source file. You should use a text editor (not a word processor) on the OS to create a HLA Basic source file. By convention, HLA Basic source files have a \ldblquote .bas\rdblquote  filename suffix.\par
\par
Once you have a source file, you can compile it to a HLA Basic Byte Code file by executing the following command:\par
\par
\tab\f1 bc <filename.bas>\par
\f0\par
where \ldblquote <filename.bas>\rdblquote  represents the name of your source file.  Compiling the source file will produce a listing of the file. If there is an error, compilation will stop on the offending line and print an error message. \par
\par
Successful compilation of a HLA Basic source file results in the production of a HLA Basic Byte Code file. The bc compiler will name this file <filename.hbbc>, where \ldblquote filename\rdblquote  is the original filename (sans the \ldblquote .bas\rdblquote  suffix\rdblquote  you used for the source file.\par
\par
Once you\rquote ve produced a \ldblquote .hbbc\rdblquote  byte code file, you will copy that file to the appropriate subdirectory where the application expects to find it (this is explained later). \par
\par
\par
\par
\b\fs28 HLA Basic Syntax\par
\b0\fs20\par
\pard\nowidctlpar\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\f2 A HLA BASIC source line takes the following general format (braces surround optional items).\f3  \par
\f4\fs18\par
optional_label: \par
\par
statement #1 \{ : statement #2 \{ ... \{ :statement #n\}...\}\}\f3\fs20  \par
\f2\par
That is to say, a single source line in \f0 HLA Basic \f2 may contain multiple statements separated by colons.  A single statement label, consisting of an identifier immediately following by a colon, is legal at the beginning of the line.  A label must appear on a line by itself.   \par
\par
Note that  although multiple statements per line are possible, you cannot split a single statement across two lines.\par
\par
There are some exceptions to this general syntax.  A few statements must appear at the beginning of a source line and a few statements must be the only statement on the source line.  We\rquote ll discuss these exceptions as we encounter them.  Although there is a very slight performance benefit to placing several statements on a single line, good programming style generally suggests that you place\f3  \f2 one statement per source line in a \f0 HLA Basic \f2 program.  Therefore, the rest of this document will assume one \f0 HLA Basic \f2 statement per source line unless there is good reason to violate this. \par
\par
\f0 HLA BASIC \f2 limits source input lines to about 1,000 characters per source line (this limit may be smaller under certain OSes).\par
\par
\b\fs28 Constants and Identifiers\par
\f3\par
\b0\f2\fs20 Variable names and other identifiers in \f0 HLA Basic \f2 must begin with an alphabetic character or an at-sign (\ldblquote @\rdblquote ).   You may follow this first character with any number of alphanumeric and underscore characters.  There is no limitation on identifier name lengths other than the practical limit of the source line length.  \par
\par
Due to a design flaw in \f0 HLA Basic\f2 , identifiers are currently case sensitive.  Therefore, "i" and "I" are two separate identifiers in the \f0 HLA Basic \f2 language.  Do not count on this feature, however, as this flaw will be corrected in a future version of \f0 HLA Basic\f2 .\par
\par
By convention, identifiers beginning with an at-sign (\ldblquote @\rdblquote ) are used to denote HLA Basic pseudo variables.  Therefore, you should avoid creating user-defined identifiers that begin with an \ldblquote @\rdblquote .  This document will discuss HLA Basic pseudo variables in a later section.\par
\par
Integer constants take two forms in HLA Basic: decimal constants and hexadecimal constants.  Integer constants consist of a sequence of decimal digits (\lquote 0\rquote ..\rquote 9\rquote ). Hexadecimal constants consist of a \lquote $\rquote  symbol followed by one or more hexadecimal digits (\lquote 0\rquote ..\rquote 9\rquote , \lquote a\rquote ..\rquote f\rquote , and \lquote A\rquote ..\rquote F\rquote ).  Integer constants are 32-bit signed entities in HLA Basic and may fall in the range -2147483648..2147483647 (0..$FFFF_FFFF).\par
\par
Real constants use the IEEE 64-bit floating-point format and support around 15 significant digits. Real constants take the usual form:  d\{.d\}\{e\'b1d\}  where \lquote d\rquote  represents one or more decimal digits and braces surround optional items.\par
\par
String constants consist of zero or more characters surrounded by quotes (\ldblquote ). If a quote character appears in a string constant, it must appear twice, e.g., \ldblquote The string \ldblquote\ldblquote Hello World\rdblquote\rdblquote  is very common.\rdblquote  \par
\par
\par
\b\fs28 Expressions and the LET Statement\par
\f3\par
\b0\f2\fs20 All but two \f0 HLA BASIC \f2 statements must begin with an appropriate keyword.  The exceptions are statement labels and the LET statement.  The LET keyword is optional for the LET statement.  This is the only statement that does not require a keyword to lead off the statement (well,  other than label definitions, which don\rquote t have anything following them).   \par
\par
This statement uses the following syntax\f3  \par
\f4\fs18\par
\{LET\} \i\f5 variable\i0\f3\fs20  \f4\fs18 = \i\f5 expression\i0\f3\fs20  \par
\f2\par
"\i\f6 variable\i0\f2 " denotes a HLA BASIC identifier or pseudo variable name and "\i\f6 expression\i0\f2 " denotes a valid \f0 HLA BASIC \f2 expression. \par
\par
\par
For the LET statement, the variable identifier must be an as-yet undefined symbol or it must be a symbol that appears as an identifier in another statement.  In particular, it cannot be the same identifier as some statement label in the program. \par
\par
Note to long-time BASIC users: you do not attach suffixes like "$", "!", or "%" to an identifier to denote the type of that symbol.  \f0 HLA BASIC \f2 automatically keeps track of the variable\rquote s type and dynamically changes the type as necessary during program execution.  This is a very powerful feature of the \f0 HLA BASIC \f2 language that simplifies many programming tasks.  If the value of \f3  \i\f6 expression\i0\f3  \f2 is a string object, then \f0 HLA BASIC \f2 dynamically converts the variable to a string variable; ditto for integer and real expressions (\f0 HLA BASIC \f2 converts the \i\f6 variable\i0\f3  \f2  to an integer or floating point object, respectively).\f3  \par
\par
\pard\sb72\tx1474\b\f7 Operators in HLA Basic\par
\pard\b0\f0\par
\pard\fi360\li360\expndtw-2 An expression in HLA Basic consists of various\expndtw0  \expndtw-2\i terms \i0 and\expndtw0  \expndtw-2\i operators. \i0 The context free grammar for HLA Basic\expndtw0  expressions is the following:\par
\pard\li1080\sb36 Y -> Y orop X | X\par
X -> X andop L | L\par
\pard\li1080\sb72 L -> L relop A | A\par
A -> A addop M | M\par
M -> M mulop T | T\par
T -> variable | intconst | strconst | fltconst | functionID( X ) | - T | \b not\b0  T\par
\par
\pard\li720\sb36\tx1524\par
\pard\li720\sb72 orop ->            \b or\b0\par
andop ->          \b and\b0\par
\pard HLA BASIC\par
Page 4\tab Version: 6/15/01\tab Written by Randall Hyde\par
\pard\li720\sb36 relop ->           < | <= | >= | > | <> | =\par
\pard\li720\sb108\tx1524 addop -> \tab + | -\par
\pard\li720\sb108\tx1683 mulop ->\tab         * | / |  \b mod\b0\par
\pard\par
\pard\li360\sb108 The precedence of the operators is as follows:\par
\pard\li2232\sb504\sa108\expndtw10\b\fs22 Table 1 HLA Basic Operator Precedence\par
\trowd\trgaph10\trleft1080\trrh-518\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3250\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx5405\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx7580\pard\intbl\sb108\sa144\qc\expndtw0\b0\fs20 Operator\cell Precedence\cell Associativity\cell\row\trowd\trgaph10\trleft1080\trrh-374\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3250\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx5405\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx7580\pard\intbl\sb36\sa72\qc - (unary), not\cell 5\cell right-to-left\cell\row\trowd\trgaph10\trleft1080\trrh-399\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3250\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx5405\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx7580\pard\intbl\sb72\sa72\qc *, /,  mod\cell 4\cell left-to-right\cell\row\trowd\trgaph10\trleft1080\trrh-398\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3250\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx5405\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx7580\pard\intbl\sb36\sa72\qc +, -\cell 3\cell left-to-right\cell\row\trowd\trgaph10\trleft1080\trrh-403\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3250\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx5405\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx7580\pard\intbl\sb72\sa72\qc <, <=, =, <>, >, >=\cell 2\cell left-to-right\cell\row\trowd\trgaph10\trleft1080\trrh-404\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3250\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx5405\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx7580\pard\intbl\sb36\sa72\qc and\cell\pard\intbl\sb72\sa72\qc 1\cell left-to-right\cell\row\trowd\trgaph10\trleft1080\trrh-404\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3250\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx5405\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx7580\pard\intbl\sb36\sa72\qc or\cell\pard\intbl\sb72\sa72\qc 0\cell Left-to-right\cell\row\pard\sb216\qj You may use parentheses to override the default precedence. The relational and boolean operators produce an integer zero/one result denoting false/true (respectively).\par
\pard\fi360\sb72\qj HLA Basic uses a \expndtw12\i dynamic type system. \expndtw0\i0 This means that HLA Basic determines the type of an expression while it is calculating that expression, based on the type of the operands in that expression. HLA Basic does not require you to declare the type of a variable before assigning some value to that variable; indeed, as the execu\-tion of a program progress, you can assign values of differing types to the same variable (this is similar to the \expndtw12\i variant \expndtw0\i0 type in many languages). HLA Basic supports three primitive data types: integers, reals, and strings. HLA Basic attempts to accommodate each of these types in an expression as best it can.\par
\pard\fi360\sb36\qj Obviously, most of the operators above are intended for use with numeric (integer and real) data types. Indeed, only the "+" (concatenation) and relational ("<", "<=", etc.) operators directly accept string operands. However, as you\rquote ll see in the next section, HLA Basic actually allows string operands anywhere a numeric oper\-and is legal (and vice versa). HLA Basic will attempt to convert such strings into numeric values should they appear in such a location. The following table describes each of the above operators:\par
\pard\li3960\sb504\sa144\expndtw10\b\fs22 Table 2\par
\trowd\trgaph10\trleft-10\trrh-1229\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx1132\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3004\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx4876\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx6748\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx8625\pard\intbl\sb468\sa504\qc\expndtw0\fs20 Operator\cell\pard\intbl\li141\sb360 integer OP integer\par
\pard\intbl\li265\sa396 (or OP integer)\cell\pard\intbl\li265\sb216 integer OP real\par
\pard\intbl\li789 or\par
\pard\intbl\li261\sa252 real OP integer\cell\pard\intbl\li385\sb360 real OP real\par
\pard\intbl\li395\sa396 (or OP real)\cell\pard\intbl\li141\sb108 string OP numeric\par
\pard\intbl\li131 numeric OP string\par
\pard\intbl\li241 string OP string\par
\pard\intbl\li313\sa144 (or OP string)\cell\row\trowd\trgaph10\trleft-10\trrh-1094\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx1132\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3004\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx4876\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx6748\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx8625\pard\intbl\sb36\sa792\qc\b0 - (unary)\cell\pard\intbl\li68 Negates the integer\par
\pard\intbl\li68\sa576 value\cell\pard\intbl\li68\sb36\sa792 N/A\cell\pard\intbl\li68 Negates the real\par
\pard\intbl\li68\sa576 value.\cell\pard\intbl\li72 Attempts to convert\par
the string to an integer or real and then\par
\pard\intbl\li72\sa72 negates that value.\cell\row\trowd\trgaph10\trleft-10\trrh-1128\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx1132\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3004\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx4876\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx6748\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx8625\pard\intbl\sb72\sa792\qc NOT\cell\pard\intbl\li68\sb72 Sets the integer to\par
\pard\intbl\li68 zero if it was\par
non-zero, one if it\par
\pard\intbl\li68\sa72 was zero.\cell\pard\intbl  N/A\cell\pard\intbl\li68\sb72 Generates a\par
\pard\intbl\li68\sa576 run-time error.\cell\pard\intbl\li72\sb72 Generates a\par
\pard\intbl\li72\sa576 run-time error.\cell\row\trowd\trgaph10\trleft-10\trrh-2294\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx1132\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3004\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx4876\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx6748\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx8625\pard\intbl\sb36\sa2016\qc *\cell\pard\intbl\li72 Computes the integer product of the\par
\pard\intbl\li72\sa1512 two operands\cell\pard\intbl\li68 Converts the integer to a real and\par
computes the real\par
product of the two\par
\pard\intbl\li68\sa1044 operands.\cell\pard\intbl\li68 Computes the real\par
product of the two\par
\pard\intbl\li68\sa1512 operands.\cell\pard\intbl\li68 If both operands are\par
strings, this generates an error. If one\par
operand is numeric,\par
HLA Basic attempts\par
to convert the other\par
operand to a number and computes\par
\pard\intbl\li68\sa72 their product.\cell\row\trowd\trgaph10\trleft-10\trrh-2323\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx1132\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3004\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx4876\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx6748\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx8625\pard\intbl\sb72\sa2016\qc /\cell\pard\intbl\li72\sb72 Computes the integer quotient of the\par
\pard\intbl\li72\sa1512 two operands (truncated result)\cell\pard\intbl\li68\sb72 Converts the integer to a real and\par
\pard\intbl\li68 computes the real\par
quotient of the two\par
\pard\intbl\li68\sa1044 operands.\cell\pard\intbl\li68\sb72 Computes the real\par
\pard\intbl\li68 quotient of the two\par
\pard\intbl\li68\sa1512 operands.\cell\pard\intbl\li68\sb72 If both operands are\par
\pard\intbl\li68 strings, this generates an error. If one\par
operand is numeric,\par
HLA Basic attempts\par
to convert the other\par
operand to a number and computes\par
\pard\intbl\li68\sa72 their quotient.\cell\row\trowd\trgaph10\trleft-10\trrh-3279\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx1132\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3004\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx4876\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx6748\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx8625\pard\intbl\sb72\sa2952\qc mod\cell\pard\intbl\li72\sb72 Computes the integer remainder of the\par
\pard\intbl\li72\sa2484 two operands.\cell\pard\intbl\li68\sb72 Generates a type\par
\pard\intbl\li68\sa2736 mismatch error.\cell\pard\intbl\li68\sb72 Generates a type\par
\pard\intbl\li68\sa2736 mismatch error.\cell\pard\intbl\li68\sb72 If either operand is\par
\pard\intbl\li68 an integer, this\par
expression attempts\par
to convert the string\par
to an integer and\par
then computes the\par
remainder of the\par
two operands. If\par
either operand is not\par
integer, then this\par
expression produces a type mismatch error.\cell\row\trowd\trgaph10\trleft-10\trrh-3043\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx1132\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3004\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx4876\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx6748\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx8625\pard\intbl\sb72\sa2736\qc +\cell\pard\intbl\li72\sb36 Computes the sum\par
\pard\intbl\li72 of the two integer\par
\pard\intbl\li72\sa2268 operands.\cell\pard\intbl\li68\sb36 Converts the integer to a real and\par
\pard\intbl\li68 computes the real\par
sum of the two\par
\pard\intbl\li68\sa1764 operands.\cell\pard\intbl\li68\sb36 Computes the real\par
\pard\intbl\li68 sum of the two\par
\pard\intbl\li68\sa2268 operands.\cell\pard\intbl\li68\sb36 If both operands are\par
\pard\intbl\li68 strings, this expression computes the concatenation of the two strings. Else it\par
attempts to convert\par
the string to the\par
same type as the\par
other numeric operand and computes\par
the sum of the values.\cell\row\trowd\trgaph10\trleft360\trrh-1229\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx1502\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3374\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx5246\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx7118\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx8995\pard\intbl\sb468\sa504\qc\b Operator\cell\pard\intbl\li141\sb360 integer OP integer\par
\pard\intbl\li265\sa396 (or OP integer)\cell\pard\intbl\li265\sb216 integer OP real\par
\pard\intbl\li789 or\par
\pard\intbl\li261\sa252 real OP integer\cell\pard\intbl\li385\sb360 real OP real\par
\pard\intbl\li395\sa396 (or OP real)\cell\pard\intbl\li141\sb108 string OP numeric\par
\pard\intbl\li131 numeric OP string\par
\pard\intbl\li241 string OP string\par
\pard\intbl\li313\sa144 (or OP string)\cell\row\trowd\trgaph10\trleft360\trrh-3014\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx1502\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3374\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx5246\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx7118\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx8995\pard\intbl\sb36\sa2736\qc\b0 -\cell\pard\intbl\li68 Computes the difference of the two\par
\pard\intbl\li68\sa2232 integer operands.  If this is used as a unary operator, then it negates the following integer value.\par
\par
\par
\par
Uniasdf\cell\pard\intbl\li68 Converts the integer to a real and\par
computes the real\par
difference of the\par
\pard\intbl\li68\sa1764 two operands. \cell\pard\intbl\li68 Computes the real\par
difference of the\par
\pard\intbl\li68\sa2232 two operands.  If this is used as a unary operator, it negates the following real value.\cell\pard\intbl\li72 If both operands are\par
strings, this operator\par
generates a type\par
mismatch error.\par
Otherwise, it\par
attempts to convert\par
the string to the\par
same type as the\par
other numeric operand and computes\par
the difference of the\par
\pard\intbl\li72\sa72 values.\cell\row\trowd\trgaph10\trleft360\trrh-3283\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx1502\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3374\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx5246\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx7118\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx8995\pard\intbl\sb72\qc <, <=, =,\par
\pard\intbl\sa2736\qc <>, >, >=\cell\pard\intbl\li68\sb72 Compares the two\par
\pard\intbl\li68 integer operands\par
and returns 0/1\par
based on the comparison.\cell\pard\intbl\li68\sb72 Converts the integer to a real and\par
\pard\intbl\li68 compares the two\par
operands, returning\par
0/1 based on the\par
result of the comparison\cell\pard\intbl\li68\sb72 Compares the two\par
\pard\intbl\li68 real operands and\par
returns (integer) 0/1\par
based on the comparison.\cell\pard\intbl\li72\sb72 If both operands are\par
\pard\intbl\li72 strings, this operator\par
compares the two\par
strings lexicographically and returns 0/1 based on the result. Otherwise, it attempts to convert\par
the string to the\par
same type as the\par
other numeric operand and compares\par
\pard\intbl\li72\sa72 the values.\cell\row\trowd\trgaph10\trleft360\trrh-2799\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx1502\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3374\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx5246\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx7118\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx8995\pard\intbl\sb72\sa2484\qc AND\cell\pard\intbl\li68\sb72 Returns one if both\par
\pard\intbl\li68 operands are\par
non-zero, zero otherwise.\cell\pard\intbl\li68\sb72 Causes a run-time\par
\pard\intbl\li68 error (type mismatch).\cell\pard\intbl\li68\sb72 Causes a run-time\par
\pard\intbl\li68 error (type mismatch).\cell\pard\intbl\li72\sb72 If one operand is\par
\pard\intbl\li72 an integer operand,\par
this operator\par
attempts to convert\par
the string operand\par
to an integer and\par
then computes their\par
logical AND. Otherwise, this operator\par
generates a run-time\par
\pard\intbl\li72\sa72 error.\cell\row\trowd\trgaph10\trleft360\trrh-2803\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx1502\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx3374\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx5246\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx7118\clbrdrl\brdrw5\brdrs\clbrdrt\brdrw5\brdrs\clbrdrr\brdrw5\brdrs\clbrdrb\brdrw5\brdrs \cellx8995\pard\intbl\sb36\sa2484\qc OR\cell\pard\intbl\li68\sb36 Returns one if either\par
\pard\intbl\li68 operand is non-zero,\par
\pard\intbl\li68\sa2016 zero otherwise.\cell\pard\intbl\li68\sb36 Causes a run-time\par
\pard\intbl\li68 error (type mismatch)\cell\pard\intbl\li68\sb36 Causes a run-time\par
\pard\intbl\li68 error (type mismatch)\cell\pard\intbl\li72\sb36 If one operand is\par
\pard\intbl\li72 an integer operand,\par
this operator\par
attempts to convert\par
the string operand\par
to an integer and\par
then computes their\par
logical OR. Other\_\par
wise, this operator\par
generates a run-time\par
\pard\intbl\li72\sa72 error.\cell\row\pard\li8280 HLA BASIC\par
\pard Released to the Public Domain by Randall Hyde\tab Page 7\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \ri72\sb683\b\f7 Dynamic Typing\par
\pard\qj\b0\f0\par
\pard\fi360\li360\ri72\qj As noted earlier, HLA Basic automatically sets the type of an expression based upon the types of the oper\-\expndtw-2 ands within that expression. Like most high level languages, HLA Basic expressions produce an integer result if\expndtw0  both operands are integers. For operators that support real operands (not all of them do), HLA Basic produces a real result whenever either or both operands are real. This is a fairly intuitive process for those who are familiar with other high level languages. What is probably not intuitive is the behavior of strings within arithmetic \expndtw-2 expressions. The purpose of this section is to discuss the behavior of HLA Basic\rquote s type system and the automatic\expndtw0  conversions it provides.\par
\pard\fi360\li360\ri72\sb36\qj Perhaps it is wisest to first consider those conversions that HLA Basic will \expndtw14\i not \expndtw0\i0 do. In HLA Basic, certain operators are defined to support integer operands only. This includes the modulo/remainder operator (MOD) as well \expndtw-2 as the logical operators AND, OR, and NOT. These operators do not allow real operands, even if that real value\expndtw0  \expndtw-2 doesn\rquote t contain a fractional component (e.g., 1.0). If you really want to use real expressions with the AND, OR,\expndtw0  \expndtw-2 and NOT operators, please see the INT and ROUND built-in functions that will convert a real value to an integer.\expndtw0\par
The NOT operator accepts only an integer operand. It will report a type mismatch error if you supply a string or real operand to this operator. This is true even if the string holds the character representation of some integer value. You must explicitly use the VAL function to convert the string to a value if you have an integer \expndtw-2 string. As noted above, you must use INT or ROUND to convert real values to integers before operating on them\expndtw0  \expndtw-2 with the NOT operator. HLA Basic does not support automatic type conversion of NOT\rquote s operands because it is\expndtw0  \expndtw-2 very unusual to have non-integer operands after the NOT operator (i.e., this usually indicates some sort of error).\expndtw0  \expndtw-2 Hence, HLA Basic reports the error rather than attempting to convert the data to an integer format (which would\expndtw0  be dubious, at best).\par
The AND and OR operators also require integer operands. However, if one operand is an integer and the other is a string, HLA Basic will first attempt to convert that string to an integer result. If the conversion is not possible, then HLA Basic reports an error. HLA Basic does not allow either (or both) operands to be real values.\par
The modulo/remainder operator (MOD) requires integer operands. Like the AND and OR operators, this opera\-tor rejects any real operands. If one operand is an integer and the other is a string, this operator will attempt to convert the string to an integer before rejecting the expression.\par
The unary negation operator ("-") requires a numeric operand. If you supply a string value as an operand, HLA Basic will not attempt to convert this to a numeric value; it will simply report a type mismatch error.\par
The division operator (\ldblquote /\rdblquote ) expects two numeric operands. If either, or both, operands are real, then HLA Basic performs a floating-point division operation and produces a real result. If both operands are integers, then HLA Basic performs an integer division (truncating any remainder).\par
\pard\fi360\li360\ri72\sb36\sa396\qj Most other operators support a variety of mixed-mode operators and will automatically convert their oper\-\expndtw-2 ands so that they have the same type. If the two operands are integer and real, HLA Basic converts the integer to\expndtw0  a real operand and then calculates the result based upon the real operands. If one operand is a string operand, HLA Basic first attempts to convert the string to an integer value. If the string does not contain the string repre\-\expndtw-2 sentation of a legal integer value, then HLA Basic attempts to convert that string to a real value. If the string does\expndtw0  \expndtw-2 not contain the legal representation of a real value, the HLA Basic stops with a type mismatch error. If HLA Basic\expndtw0  \expndtw-2 successfully converts the string to an integer or real value, it completes the calculation as though the program had\expndtw0  originally supplied that integer or real operand. Note that HLA Basic will not attempt to convert string operands to numeric form if both operands around a numeric operator are strings.\par
\pard\sb108\tx1478\b\f7 Built-in Functions\par
\pard\qj\b0\f0\par
\pard\fi360\li360\ri72\qj HLA Basic supports a large number of built-in functions. Furthermore, it is easy to add new functions to HLA Basic as you have the source listings to the interpreter. This document discusses how to do that in a later section. The fol\-lowing subsections describe the default set of built-in functions.\par
\pard In the following sections, the parameter and return types are denoted by using variable names with the fol\-\expndtw-2 lowing prefixes: "i" for integer operands, "f" for floating point/real values, "s" for string values, "n" for numeric\expndtw0  (integer or real), and "a" for an arbitrary type. Note that HLA Basic will automatically convert integers to real in parameter lists. Likewise, most function that expect a numeric value will accept a string and attempt to convertHLA BASIC\par
Page 9\tab Version: 6/15/01\tab Written by Randall Hyde\par
\pard\fi360\li360\ri72\sb36\qj  that string to a numeric value. The following sections, however, describe the native types for the parameters (as well as the function return types).\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb13\tx1495\b\f7 abs( <numeric> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 i1 = abs ( i2 )\par
f1 = abs ( f2 )\par
\pard\fi360\li360\sb252\f0\fs20 This function computes the absolute value of its parameter. If the parameter is a real/floating-point value, then the result is a real value. Likewise, if the parameter is an integer value, then the abs function produces an integer result.\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb13\tx1495\b\f7 acos( <real> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 f1 = acos ( f2 )\par
\pard\fi360\li360\sb252\f0\fs20 This function computes the arc-cosine of its parameter. The parameter must be a value in the range -1..+1. This function returns the angle, in radians, whose cosine produces the parameter value.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1495\b\f7 asc( <string> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 i = asc( s )\par
\pard\fi360\li360\sb252\f0\fs20 This function takes a string parameter. It returns the ASCII code of the first character in the string. This function generates a run-time error if the string is empty.\par
\pard\brdrt\brdrs\brdrw30\brdrcf2\brsp100 \sb393\tx1495\b\f7 asin( <real> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 f1 = asin( f2 )\par
\pard\fi360\li360\sb252\f0\fs20 This function computes the arc-sine of its parameter. The parameter must be a value in the range -1..+1. This function returns the angle, in radians, whose sine produces the parameter value.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb394\tx1495\b\f7 atan( <real> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 f1 = atan( f2 )\par
\pard\fi360\li360\sb252\f0\fs20 This function computes the arc-tangent of its parameter. This function returns the angle, in radians, whose tangent produces the parameter value.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb394\tx1500\b\f7 chr( <int> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sl-192\slmult0\f1\fs18 s = chr( i )\par
\pard\fi360\li360\sb252\sa396\f0\fs20 This function produces a string of length one whose single character has the ASCII code specified by the integer parameter.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb394\tx1500\b\f7 cos( <real> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 f1 = cos( f2 )\par
\pard\fi360\li360\sb252\f0\fs20 This function computes the cosine of its parameter. The parameter must be an angle in radians. This func\-tion is most accurate when the angle is in the range -2*pi..2*pi radians.\par
\pard\li8280 HLA BASIC\par
\pard Released to the Public Domain by Randall Hyde\tab Page 10\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb122\b\f7 date\par
\pard\li360\sb252\sl-192\slmult0\b0\f1\fs18 d = date\par
\pard\li720\sb288\f0\fs20 This function returns a string of the form \ldblquote mmm dd, yyyy\rdblquote  that represents the current date. \ldblquote mmm\rdblquote  is a three-letter abbreviation for the month (e.g, \ldblquote Jan\rdblquote ).  The day component will have a leading zero if the day value is in the range 1..9. The system computes the date by getting the system (UTC) time, adding in the value of the \i timeZone\i0  pseudo variable, and then calculating the date from this.\par
\super\par
\pard\li8280\nosupersub HLA BASIC\par
\pard Released to the Public Domain by Randall Hyde\tab Page 10\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb122\b\f7 exp( <real> )\par
\pard\li360\sb252\sl-192\slmult0\b0\f1\fs18 f1 = exp ( f2 )\par
\pard\li720\sb288\f0\fs20 This function computes e\super f2\nosupersub .\super\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb399\tx1478\nosupersub\b\f7 int( <real> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 i = int( f )\par
\pard\fi360\li360\sb252\f0\fs20 This function extracts the integer portion of a real value and converts it to an integer (via truncation). The resulting value must fit in a 32-bit integer.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1478\b\f7 left( <string>, <int> )\par
\pard\li360\sb252\sl-192\slmult0\b0\f1\fs18 s1 = left( s2, i )\par
\pard\li720\sb288\f0\fs20 This function extracts the left-most "i" characters from the string "s2" and returns this substring.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1478\b\f7 len( <string> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 i = len( s )\par
\pard\fi432\li288\sb252\f0\fs20 This function returns the current length of the string variable "s" as an integer value. Note that there is no practical length on strings in HLA Basic.\par
\pard\brdrt\brdrs\brdrw30\brdrcf2\brsp100 \sb398\tx1478\b\f7 log( <real> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 f1 = log( f2 )\par
\pard\fi360\li360\sb252\f0\fs20 This function computes the natural logarithm (base-e) of f2. The value of the parameter, f2, must be greater than zero.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb432\tx1478\b\f7 mid( <string>, <int>, <int> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 s1 = mid( s2, i1, i2 )\par
\pard\fi432\li288\sb252\sa396\expndtw-2\f0\fs20 This function extracts a substring of length i2, starting at character position i1, from s2 and returns the result.\expndtw0  Note that string indexes are zero-based in HLA Basic. Hence, MID( s2, 0, i2) is equivalent to LEFT(s2, i2).\par
\pard\li8280 HLA BASIC\par
\pard Released to the Public Domain by Randall Hyde\tab Page 10\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb122\b\f7 pwr10( <real> )\par
\pard\li360\sb252\sl-192\slmult0\b0\f1\fs18 f1 = pwr10 ( f2 )\par
\pard\li720\sb288\f0\fs20 This function computes 10\super f2\nosupersub .\super\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb432\tx1478\nosupersub\b\f7 randomize\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 i = randomize\par
\pard\fi432\li288\sb252\f0\fs20 This function "randomizes" the HLA Basic random number generator and then returns a random number. Note that this instruction uses the x86 RDTSC instruction which is only available on Pentium and later chips.\par
\par
\pard\sa252 HLA BASIC\par
\pard Page 11\tab Version: 6/15/01\tab Written by Randall Hyde\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb13\b\f7 right( <string>, <int> )\par
\pard\li360\sb252\sl-192\slmult0\b0\f1\fs18 s1 = right( s2, i )\par
\pard\li720\sb252\f0\fs20 This function extracts the right-most i characters from string s2 and returns the result.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb399\tx1504\b\f7 rnd\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\qj\f1\fs18 i = rnd\par
\pard\fi360\li360\ri72\sb252\qj\f0\fs20 The RND function returns a pseudo-random number on each successive call. Note that, in the absence of calling RANDOMIZE, the RND always produces the same sequence of pseudo-random numbers each time you start the HLA Basic interpreter (but not each time you run a BASIC program from within HLA Basic without restarting HLA Basic). Therefore, if you need to guarantee the same sequence on each run (i.e., during testing) then you should restart HLA Basic before each run.\par
\pard\fi360\li360\ri72\sb36\qj To get a more random sequence, you should call the randomize function (just once) at some point in your program. The RANDOMIZE function reads the Pentium\rquote s time stamp counter and seeds the random number generator using this value.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb394\tx1504\b\f7 round( <real> )\par
\pard\li360\sb252\sl-192\slmult0\b0\f1\fs18 i = round( f )\par
\pard\li720\sb288\f0\fs20 This function converts a floating point value to an integer via rounding.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb394\tx1495\b\f7 sin( <real> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 f1 = sin( f2 )\par
\pard\fi360\li360\ri72\sb252\f0\fs20 This function computes the sine of its parameter. The parameter must be an angle in radians. This function is most accurate when the angle is in the range -2*pi..2*pi radians.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb399\tx1495\b\f7 sqrt( <real> )\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 f1 = sqrt ( f2 )\par
\pard\fi360\li360\ri72\sb252\sa396\f0\fs20 This function computes the square root of its parameter. The parameter must be greater than or equal to zero.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb399\tx1495\b\f7 str( <string> \{, <int>, \{<int>\}\} )\line str( <real> \{, <int>, \{<int>\}\} )\line str( <int> \{, <int>, \{<int>\}\} )\par
\pard\li360\sb252\sl-192\slmult0\b0\f1\fs18 s1 = str( s2 )\par
\pard\li720\sb288\f0\fs20 This function call simply returns the value of s2 as the result.\par
\pard\li360\sb360\sl-192\slmult0\f1\fs18 s3 = str( s4, i)\par
\pard\li8280\f0\fs20 HLA BASIC\par
\pard Released to the Public Domain by Randall Hyde\tab Page 13\par
\pard\fi360\li360\sb180\qj\expndtw-2 The "i" parameter specifies a string length. If i is less than the length of s4, then this function simply returns\expndtw0  s4. If i is greater than the length of s4, then this function returns a string of length i consisting of all the charac\-ters in s4 following by sufficient spaces to make the string length i characters long.\par
\pard\li360\sb72\sl-192\slmult0\f1\fs18 s5 = str( s6, i1, i2 )\par
\pard\fi360\li360\sb252\expndtw-2\f0\fs20 This function returns a string that is i1 characters long. It consists of the first i2 characters of s6 followed by\expndtw0  sufficient spaces to extend the resulting string to i1 characters. Note that i2 must be less than i1.\par
\pard\li360\sb72\sl-192\slmult0\f1\fs18 s6 = str( i1 )\par
\pard\fi360\li360\sb252\f0\fs20 This function call converts the integer parameter to a string using the minimum number of character posi\-tions to represent that string.\par
\pard\li360\sb72\sl-192\slmult0\f1\fs18 s7 = str( i1, i2 )\par
\pard\li360\sl-192\slmult0 s8 = str( i1, i2, i3 )\par
\pard\fi360\li360\sb252\qj\expndtw-2\f0\fs20 These function calls convert the integer i1 to a string using at least i2 print positions. If the value of i1 would\expndtw0  \expndtw-2 normally require fewer than i2 print positions, then STR pads the resulting string with spaces and left-justifies the\expndtw0  string within the resulting string. If i1 requires more than i2 print positions, then STR uses however many print positions are necessary. When the first parameter is an integer expression, the STR function ignores the third parameter, if it is present.\par
\pard\li360\sb72\sl-192\slmult0\f1\fs18 s9 = str( f )\par
\pard\fi360\li360\sb252\expndtw-2\f0\fs20 This function call converts the floating point operand to a string using exponential (scientific) notation. This\expndtw0  form uses a field width of approximately 24 characters.\par
\pard\li360\sb72\sl-192\slmult0\f1\fs18 s10 = str( f, i )\par
\pard\fi360\li360\sb252\f0\fs20 This function call converts the floating point value f to a string using exponential (scientific) notation. The string will be i characters long. The value of i should be eight or greater to obtain reasonable results.\par
\pard\li360\sb72\sl-192\slmult0\f1\fs18 s11 = str( f, i1, i2 )\par
\pard\fi360\li360\sb252\qj\f0\fs20 This function converts the floating point operand to a string using decimal notation. The string will be i1 characters long and STR converts the number such that it has i2 positions after the decimal point. Note that i1 must be at least two greater than i2.\par
\pard\fi360\li360\sb36\qj In addition to the obvious use for STR (converting data to a string format), the STR function has one other really important use - it provides formatted output capabilities for the HLA Basic PRINT statement. If you want to produce nice columns of numbers and other formatted output, you would typically use the STR function to achieve this, e.g.,\par
\pard\li360\sb72\sa360\sl-192\slmult0\f1\fs18 print "f = "; str(f, 10, 2 ), "i ="; str( i, 5 )\par
\pard\brdrt\brdrs\brdrw30\brdrcf2\brsp120 \sb16\tx1460\expndtw10\b\f7\fs22 tan( <real> )\par
\pard\sl-192\slmult0\expndtw0\b0\f0\fs20\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 f1 = tan( f2 )\par
\pard\fi432\li288\sb252\sa684\f0\fs20 This function computes the tangent of its parameter. The parameter must be an angle in radians. This func\-tion is most accurate when the angle is in the range -2*pi..2*pi radians.\par
\pard\brdrt\brdrs\brdrw30\brdrcf2\brsp120 \sb16\tx1460\expndtw10\b\f7\fs22 time\par
\pard\sl-192\slmult0\expndtw0\b0\f0\fs20\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 t = time\par
\pard\fi432\li288\sb252\sa684\f0\fs20 This function returns a string of the form \ldblquote hh:mm:ss\rdblquote  denoting the current local time. This function reads the system UTC time, adds in the value of the \i timeZone\i0  pseudo variable, and produces a string result. The time is always given in 24-hour format.\par
\pard\brdrt\brdrs\brdrw30\brdrcf2\brsp120 \sb16\tx1460\expndtw10\b\f7\fs22 unixTime\par
\pard\sl-192\slmult0\expndtw0\b0\f0\fs20\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 ut = unixTime\par
\pard\fi432\li288\sb252\sa684\f0\fs20 This function returns an unsigned integer value that denotes the number of seconds since Jan 1, 1970 (a UNIX time value).  This function is useful for computing the number of seconds between two events.  Note that because this function returns a signed 32-bit integer, rollover will occur at some point in the year 2038. You should only use this function for computing the number of seconds between two events; you should not use this function to actually produce the date or time (use the  date and time functions for that purpose).  \par
\pard\brdrt\brdrs\brdrw30\brdrcf2\brsp120 \sb16\tx1460\expndtw10\b\f7\fs22 val( <string> )\par
\pard\sl-192\slmult0\expndtw0\b0\f0\fs20\par
\pard\li360\sb252\sl-192\slmult0\f1\fs18 n = val( s )\par
\pard\qj\f0\fs20 HLA BASIC\par
\pard\par
\pard\fi360\li360\ri72\sb180\sa360\qj The VAL function converts a string to a numeric value. The string must contain the valid representation of an integer or real value. VAL first attempts to convert the string to an integer; failing that, it attempts to convert \expndtw-2 the string to a floating point value. If that does not succeed, the VAL raises a run-time exception. The type of the\expndtw0  resulting numeric value depends entirely on the type of the string data.\par
\pard\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb13\tx1490\b\f7 Arrays and the DIM Function in HLA Basic\par
\pard\b0\f0\par
\pard\fi360\li360\ri72\qj\expndtw-2 In HLA Basic, an array is just a special case of a data type. Unlike standard BASIC, there is no "DIM" state\expndtw0\-\expndtw-2 ment for declaring arrays, instead, you call a special function (named "DIM") that returns an empty array. There\expndtw0\-fore, to declare an array with 10 elements in it, you would use an assignment statement like the following:\par
\pard\li360\sb72\sl-192\slmult0\f1\fs18 x = dim( 10 )\par
\pard\sl-192\slmult0\f0\fs20\par
\pard\li360\ri72\expndtw-2 This function allocates storage for 10 uninitialized variables (with indices 0..9) and associates this array with the\expndtw0  variable x. Like most languages, you use brackets containing an integer expression to index into an array, e.g.,\par
\pard\li360\sb108\sl-192\slmult0\f1\fs18 x[ i+2 ] = y * z\par
\pard\sl-192\slmult0\f0\fs20\par
\pard\li360\ri72\qj Any attempt to access an array variable without an index generates a run-time error. Likewise, any attempt to \expndtw-2 access an array element outside the range 0..n-1 (where n is the value of the DIM parameter) generates a run-time\expndtw0  error.\par
\pard\fi360\li360\ri72\sb72 Array elements are just like any other HLA Basic variable. Array elements need not all be the same type of object; it is perfectly legal to have some integer, real, and string objects in the same array.\par
\pard\fi360\li360\ri72\sb36\qj HLA Basic doesn\rquote t directly support multidimensional array declarations. However, since arrays are just another type to HLA Basic and any given array element can be any legal type, you can synthesize a multidimen\-sional array by calling the DIM function for each element of an existing array. For example, to create a 10x10 array you could use the following BASIC code:\par
\pard\li360\ri1440\sb72\f1\fs18 x = dim( 10 ) \par
\expndtw-2 for i = 0 to 9 \expndtw-11\par
\pard\fi360\li360\ri1440\sb72 x[i] = dim ( 10 ) \expndtw0\par
\pard\li360\ri1440\sb72 next i\par
\pard\fi360\li360\ri72\sb252\f0\fs20 Since the type of each element in an array doesn\rquote t need to be the same, it is even possible to create an array that has an integer, a string, a real, and an array element, e.g.,\par
\pard\li360\sb72\sl-192\slmult0\tx810\f1\fs18 m = dim( 4 )\par
\pard\li360\sl-192\slmult0\tx810 m[0] = 1\par
m[1] = 1.1\par
\pard\li360\ri2610\tx810\expndtw-8 m[2] = "Hello World"\expndtw0  \par
m[3] = dim( 4 )\par
\pard\sl-192\slmult0\f0\fs20\par
\pard\li360 To access an element of a synthesize multidimensional array you use syntax like the following:\par
\pard\li360\sb108\sl-192\slmult0\f1\fs18 m[ 3 ][ 2 ] = m[ 3 ][ 0 ]\par
\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb13\tx1490\b\f0\fs28 HLA Basic Pseudo Variables\par
\pard\b0\fs20\par
\pard\fi360\li360\ri72\qj\expndtw-2 HLA Basic provides a special kind of functional object, known as a pseudo-variable,  that may appear within expressions (like normal built-in functions) as well as on the left-hand side of an assignment statement (i.e., immediately after a LET).  Pseudo variables provide two main functions: they allow an HLA Basic program to communicate with the underlying HLA application, passing data to and from the assembly code; pseudo variables also allow two (or more) HLA Basic programs to pass data between themselves.  \par
\par
A pseudo variable uses the same syntax as a function call \endash  that is, a name (possibly) followed by parentheses and any required arguments.  When a pseudo variable appears within some expression, that pseudo variable returns some value (as defined by the underlying interpreter code). If a pseudo variable appears to the left of an assignment statement, then the HLA Basic interpreter evaluates the expression on the right-hand side of that assignment and the interpreter passes that value to the (internal) pseudo variable handler code.\par
\par
All pseudo variable names must with an at-sign (\ldblquote @\rdblquote ). Pseudo variables must be defined in the compiler, detokenizer, and interpreter assembly language source files. They are not user-defined quantities you can create in a HLA Basic program.  The main purpose for pseudo variables is to allow you to easily communication data values with the underlying HLA program that is executing the HLA Basic program.\par
\pard\ri72\qj\par
\pard\fi360\li360\ri72\qj Because pseudo variables tend to be application specific, the HLA Basic language only defines a single pseudo variable: @timeZone.  A later section will describe how to create new pseudo variables in your programs.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp120 \sb706\tx1144\expndtw0\b\f7 @timeZone\par
\pard\li360\sb252\sl-192\slmult0\b0\f1\fs18 @timeZone = <expression>\par
j = <\'85> @timeZone <\'85>\par
\pard\li720\sb288\sa396\f0\fs20 The \b @timeZone\b0  pseudo variable sets the time zone offset for the date and time functions. This is the number of hours (in the range -12..+12) that must be added to UTC time to produce the current local time.\par
\pard\fi360\li360\ri72\qj\expndtw-2 A Basic application must set this value as appropriate for the current time zone or the date and time functions will not return the correct local time (they will return UTC if you let the \b @timeZone\b0  value default to zero).\expndtw0\par
\expndtw-2\par
\pard\li360\sb108\sl-192\slmult0\expndtw0\f1\fs18\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb13\tx1490\b\f0\fs28 HLA Basic Statements\par
\pard\li720\sb288\sa396\b0\fs20 In addition to the LET statement (described previously), HLA Basic supports the following run-time statements.\b\fs28\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp120 \sb706\tx1144\f7\fs20 beep\par
\pard\li360\sb252\sl-192\slmult0\b0\f1\fs18 beep\par
\pard\li720\sb288\sa396\f0\fs20 This statement beeps the (Linux console) speaker for a short duration.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp120 \sb706\tx1144\b\f7 cls\par
\pard\li360\sb252\sl-192\slmult0\b0\f1\fs18 cls\par
\pard\li8280\f0\fs20 HLA BASIC\par
\pard Released to the Public Domain by Randall Hyde\tab Page 17\par
\pard\li360\sb252\sl-192\slmult0 This statement clears the (Linux console) display.\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb13\tx1114\b\f7 color <int>, <int>\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sl-192\slmult0\f1\fs18 color b, f\par
\pard\fi360\li360\sb252\qj\f0\fs20 This statement sets the text background (b) and foreground (f) text colors (that the \b print\b0  statement uses when writing text to the display. The two operands can be any integer expression that evaluates to a value in the range 0..7 (since there are 8 possible foreground and background colors).\par
The valid color values are as follows:\par
\pard\fi-720\li1440\sb252\qj\tx1440\fs24 0\tab\fs20 black\par
\pard\fi-720\li1440\sb252\qj\fs24 1\tab\fs20 red\par
\fs24 2\tab\fs20 green\par
\fs24 3\tab\fs20 yellow\par
\fs24 4\tab\fs20 blue\par
\fs24 5\tab\fs20 magenta\par
\fs24 6\tab\fs20 cyan\par
\fs24 7\tab\fs20 white\par
\pard\fi360\li360\sb252\qj\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb399\tx1114\b\f7 debug\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 debug\par
\pard\fi360\li360\sb252\f0\fs20 This statement toggles the run-time trace facility during program execution. When the trace mode is turned on, HLA Basic displays the line number of each statement it executes.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1104\b\f7 for var = <int> to <int> \{step <int>\} / next var / next\par
\pard\sl-192\slmult0\b0\f0\par
\pard\fi-360\li720\ri5760\expndtw-7\f1\fs18 for i = 1 to 10 \par
\pard\fi-360\li720\ri7200\par
\pard\li720\ri7200\expndtw0 ... \par
\par
\pard\li360\sl-192\slmult0 next i\par
\pard\fi-360\li720\ri5040\sb216\expndtw-7 for i = 0 to 100 step 10 \par
\pard\fi-360\li720\ri6192\sb216\tab ...\expndtw0\par
\pard\li360\sl-192\slmult0 next i\par
\pard\sl-192\slmult0\f0\fs20\par
\pard\li360 Note: both the for and next keywords must appear at the beginning of the source line. There must not be any labels on these lines.\par
\pard\fi360\li360\sb72\qj\expndtw-2 This statement implements the definite loop in HLA Basic. If the STEP keyword and operand is not present,\expndtw0  the step value is assumed to be one. If the STEP value is positive, then HLA Basic executes this loop while the \expndtw-2 value of the loop control variable is less than or equal to the value of the second expression. If the STEP value is\expndtw0  \expndtw-2 negative, then HLA Basic executes the body of the loop while the loop control variable\rquote s value is greater or equal\expndtw0  to the second expression.\par
\pard\fi360\li360\sb36\qj The "NEXT var" statement must physically follow the FOR statement in the source file. This form of the NEXT statement is not dynamic. HLA Basic assumes that all statements between the "FOR" and the "NEXT var" statements comprise the body of the loop. HLA Basic will generate an error if the "NEXT var" statement does not following the corresponding "FOR" in the source file.\par
\pard\fi360\li360\sb36\sa396\qj\expndtw-2 The NEXT statement (without a variable after the NEXT keyword) automatically restarts the last FOR state\expndtw0\-ment executed. This is true even if the NEXT statement does not physically appear between the FOR and "NEXT var" statements in the program.\par
\pard\fi360\li360\qj\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb13\tx1140\b\f7 gosub lbl\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 gosub MySubroutine\par
\pard\fi360\li360\sb252\qj\f0\fs20 This code pushes a "return address" onto the GOSUB stack and then transfers control to the statement asso\-ciated with the given label. Control returns to the first statement following the GOSUB (possibly on the same line, after a colon following the "GOSUB LBL" statement) when the program executes a RETURN statement. See the RETURN statement for more details.\par
\pard\fi360\li360\sb36 There is a built-in limit of 64 nested GOSUBs in the HLA Basic language. However, this is easy to change by modifying a single constant at the beginning of the HLA Basic interpreter source file.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb394\tx1140\b\f7 goto lbl\par
\pard\li360\sb252\sl-192\slmult0\b0\f1\fs18 goto targetLabel\par
\pard\li720\sb252\sa396\f0\fs20 This statement immediately transfers control to the specified statement in the source file.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb394\tx1114\b\f7 gotoxy <int>, <int>\par
\pard\b0\f0\par
\pard\fi360\li360\ri72\expndtw-2 This statement requires to integer expressions. It repositions the cursor in the window at the (x,y) coordinate\expndtw0  specified by the two operands. E.g.,\par
\pard\li1800\sb72\sl-192\slmult0\f1\fs18 gotoxy 5,10\par
\pard\sl-192\slmult0\f0\fs20\par
\pard\li360\sa396 repositions the cursor on line 10, column 5.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb394\tx1144\b\f7 if( <int> ) then.. elseif( <int> ) then..else..endif\par
\pard\fi360\li360\sb216\expndtw-2\b0\f0 The IF..THEN..ELSEIF..ELSE..ENDIF sequence provide condition execution in HLA Basic. This statement\expndtw0  allows the following syntax:\par
\pard\li360\sb36\sl-216\slmult0\f1\fs18 if( expr\sub 1\nosupersub  ) then\par
\par
\pard\fi360\li360\ri2880\sl480\slmult1\expndtw-6 << Statements  >> \par
\pard\fi360\ri2880\sl480\slmult1\expndtw0 endif\par
\pard\li360\sb612\sl-216\slmult0 if( expr\sub 1\nosupersub  ) then\par
\pard\li720\sb252\sl-216\slmult0 << Statements >>\par
\pard\sl-216\slmult0\f0\fs20\par
\pard\li360\sl-216\slmult0\f1\fs18 elseif( expr\sub 2\nosupersub  ) then\par
\pard\li720\sb252\sl-216\slmult0 << Statements >>\par
\pard\sl-216\slmult0\f0\fs20\par
\pard\li360\sl-216\slmult0\f1\fs18 << Note: additional ELSEIF clauses may appear here>>\par
\pard\sl-216\slmult0\f0\fs20\par
\pard\li360\sl-216\slmult0\f1\fs18 endif\par
\pard\li360\sb648\sl-216\slmult0 if( expr\sub 1\nosupersub  ) then\par
\pard\fi360\li360\ri2160\sl480\slmult1\expndtw-6\par
<< Statements >> \par
\pard\fi360\ri2160\sl480\slmult1\expndtw0 else\f0\fs20\par
\pard\li720\sl-216\slmult0\f1\fs18 << Statements >>\par
\pard\li8280\f0\fs20 HLA BASIC\par
\pard Released to the Public Domain by Randall Hyde\tab Page 20\par
\pard\sl-216\slmult0\par
\par
\pard\li360\sl-216\slmult0\f1\fs18 endif\par
\pard\li360\sb864\sl-216\slmult0 if( expr\sub 1\nosupersub  ) then\par
\pard\li648\sb252\sl-216\slmult0 << Statements >>\par
\pard\sl-216\slmult0\f0\fs20\par
\pard\li360\sl-216\slmult0\f1\fs18 elseif( expr\sub 2\nosupersub  ) then\par
\pard\li648\sb252\sl-216\slmult0 << Statements >>\par
\pard\sl-216\slmult0\f0\fs20\par
\pard\li360\sl-216\slmult0\f1\fs18 << Note: additional ELSEIF clauses may appear here>>\par
\pard\sl-216\slmult0\f0\fs20\par
\pard\li360\sl-216\slmult0\f1\fs18 else\par
\pard\sl-216\slmult0\f0\fs20\par
\pard\fi288\li360\ri1890\sl480\slmult1\expndtw-2\f1\fs18 << Statements >> \par
\pard\fi360\ri1890\sl480\slmult1\expndtw0 endif\par
\pard\sl-216\slmult0\f0\fs20\par
\pard\li360\ri72\expndtw-2 Important: Note that the\expndtw0  \f7 if, elseif, else, \expndtw-2\f0 and\expndtw0  \f7 endif \expndtw-2\f0 keywords must appear first on a source line. For lexical reasons,\expndtw0  these must be the first statements on a source line.\par
\pard\fi288\li360\ri72\sb72\sa360\qj\expndtw-2 The\expndtw0  \f7 if \expndtw-2\f0 and\expndtw0  \f7 elseif \expndtw-2\f0 clauses evaluate their expressions and execute the statements following the then keyword if\expndtw0  the expression is true (non-zero). Otherwise they skip to the next \expndtw2\f7 elseif, else, \expndtw0\f0 or \expndtw12 endif \expndtw0 clause if the expression evaluates false (zero).\par
\pard\fi360\li360\ri72\qj\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb13\tx1118\b\f7 input var\par
\pard\b0\f0\par
\pard\fi360\li360\ri72\qj This statement pauses and reads some input from the user. If the input can be converted to an integer value without error, then the \expndtw2\f7 input \expndtw0\f0 statement stores the integer result in the \expndtw2\f7 var \expndtw0\f0 variable (setting the type of \expndtw2\f7 var \expndtw0\f0 to inte\-\expndtw-2 ger). If the input cannot be converted to an integer but it can be converted to a floating point value, then the\expndtw0  \f7 input \f0 statement converts the input to a real value and stores the result in the \expndtw2\f7 var \expndtw0\f0 object (setting its type to real). If the input is non-numeric, then the input statement converts \expndtw2\f7 var \expndtw0\f0 to a string and stores the input text in this variable.\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb394\tx1114\b\f7 on <int> goto lbl_list\par
\pard\b0\f0\par
\pard\fi360\li360\ri72 The on..goto statement transfers control to one of several different table based upon the value of some expression. The syntax for this statement is\par
\pard\li360\sb72\tx1114\f1\fs18 on \expndtw8\i\fs16 expr \expndtw0\i0\fs18 goto lbl\sub 0\nosupersub , lbl\sub 1\nosupersub , lbl\sub 2\nosupersub , \super lbl\expndtw22\nosupersub\fs12 n-1\expndtw0\super\fs18\par
\pard\nosupersub\f0\fs20 This statement evaluates the expression, which must produce an integer value. If the result is zero then this statement jumps to the first label in the list following the \expndtw2\f7 goto \expndtw0\f0 keyword. If the result is one, then this statement HLA BASIC\par
Page 21\tab Version: 6/15/01\tab Written by Randall Hyde\par
\pard\fi360\li360\ri72\sb288\expndtw-2 jumps to the second label, etc. If the value is less than zero or greater than n-1, this this statement falls through to\expndtw0  the next physical statement in the program (i.e., the one following the \f7 on..goto \f0 statement).\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb13\tx1140\b\f7 on <int> gosub lbl_list\par
\pard\b0\f0\par
\pard\fi360\li360\qj This statement is very similar to the \f7 on..goto \f0 statement except it calls the subroutine at the specified label rather than jumping directly there. When the subroutine returns, it returns control to the first statement beyond the \f7 on..gosub. \f0 Example:\par
\pard\li360\sb72\tx1140\f1\fs18 on i-2 gosub sub1, subA, subB\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb696\tx1144\b\f7\fs20 print expr_list\par
\pard\b0\f0\par
\pard\fi360\li360\qj The \f7 print \f0 statement displays the data specified by the expression list on the console output device (i.e.,  the CCS console device). The \f7 expr_list \f0 item above represents a list of zero or more HLA Basic expressions, each separated by a comma or a semicolon. Items that are separated by semicolons are printed adjacent to one another, items separated by com\-mas are separated by a tab field. HLA Basic automatically formats the expressions according to their data type and prints the value of the expression in a string format. Example:\par
\par
\pard\li360\sb72\tx1144\f1\fs18 print "Hello World, i=", i\par
\pard\fi360\li360\sb252\qj\f0\fs20 Note that if the statement ends with a semicolon, HLA Basic does not print a newline sequence after the tex\-tual output. If the statement does not end with a semicolon, the HLA Basic will print a newline sequence after displaying the associated text.\par
\pard\fi360\li360\sb36 HLA Basic\rquote s \f7 print \f0 statement does not directly support formatted output, but you can use the \f7 STR \f0 function to format the data on output. See the description of the \f7 STR \f0 function for more details.\par
\par
\pard\fi360\li360\ri72\qj\par
\pard\li360\sb72\tx1144\f1\fs18\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb393\tx1144\b\f7\fs20 rem\par
\pard\b0\f0\par
\pard\fi360\li360\qj This statement allows you to insert a comment (remark) into the code. The remainder of line is ignored by \expndtw-2 the interpreter. Note that a colon (":") character does not end the comment, only the physical end of the line does\expndtw0  this. Example,\par
\pard\li360\sb72\sa396\tx1144\f1\fs18 rem this is a comment\par
\pard\fi360\li360\qj\f0\fs20 HLA Basic supports two additional comment forms that are easier to read in most programs than the \ldblquote rem\rdblquote  keyword.  First of all, HLA treats all text following \ldblquote //\rdblquote  to the end of the line as a comment (just like the HLA assembly language), e.g.,\par
\pard\li360\sb72\sa396\tx1144\f1\fs18 // this is a comment\par
\pard\fi360\li360\qj\f0\fs20 HLA Basic also treats all text beginning with a single apostrophe character (\lquote ) as a comment (just like Microsoft BASIC), e.g.,\par
\pard\li360\sb72\sa396\tx1144\f1\fs18\lquote  this is a comment\par
\pard\fi360\li360\qj\f0\fs20 The HLA Basic compiler ignores all comment text and does not emit any data to the compiled interpreter file for the comment data.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb393\tx1144\b\f7 return\par
\pard\li720\sb252\b0\f0 Returns from a subroutine called by GOSUB. See GOSUB and ON..GOSUB for more details. Example:\par
\par
\pard\li360\sb72\tx1144\f1\fs18\tab return\par
\par
\pard\li720\sb252\f0\fs20 If the internal return stack is empty, then executing the return statement raises an exception.\par
\pard\li360\sb72\tx1144\par
\pard\li8280 HLA BASIC\par
\pard Released to the Public Domain by Randall Hyde\tab Page 22\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp80 \sb122\b\f7 stop\par
\pard\li720\sb216\b0\f0 Stops the HLA Basic program notifies the HLA application that it has stopped. What happens at that point depends entirely on how the HLA application interacts with HLA Basic system.   \par
\pard\li360\sb72\tx1109\expndtw6\f1\fs16 stop\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb399\tx1114\expndtw0\b\f7\fs20 suspend\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 suspend\par
\pard\fi360\li360\sb252\f0\fs20 This statement returns control from the current HLA Basic module to the main application code (written in HLA). When HLA calls this module again, control resumes with the first statement following the suspend statement.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb399\tx1114\b\f7 system\par
\pard\sl-192\slmult0\b0\f0\par
\pard\li360\sb36\sl-192\slmult0\f1\fs18 system \ldblquote OS Cmd\rdblquote\par
\pard\fi360\li360\sb252\f0\fs20 This statement executes the OS command specified by the string parameter. This is a typical shell/command-line-interpreter command-line (including arguments). The HLA Basic interpreter uses the system \ldblquote EXEC\rdblquote  command to execute this statement. If you are using a built-in shell command, you will need to run the shell program. For example, under Windows you would need to execute:\par
\f1\fs18 system \ldblquote cmd /c dir\rdblquote\par
\pard\li360\sb252\f0\fs20 to execute the built-in \ldblquote dir\rdblquote  command.\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb394\tx1104\b\f7 wait <int>\par
\pard\b0\f0\par
\pard\fi360\expndtw-7\f1\fs18 wait 2000 : delays for two seconds\par
\pard\expndtw0\f0\fs20\par
\pard\li720\sb216 Delays the program for the specified number of milliseconds. \par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb394\tx1144\b\f7 while( <int> ) do..endwhile\par
\pard\fi360\li360\sb216\expndtw-2\b0\f0 The WHILE..ENDWHILE sequence provides indefinite loop execution in HLA Basic. This statement\expndtw0  allows the following syntax:\par
\pard\li360\sb36\sl-216\slmult0\f1\fs18 while( expr\sub 1\nosupersub  ) do\par
\par
\pard\fi360\li360\ri5850\sl480\slmult1\expndtw-6 <<Statements>>\line\expndtw0 endwhile\par
\pard\fi360\li360\sb216\expndtw-2\f0\fs20 Upon encountering this statement, the program evaluates the expression between the parenthesis. If the expression evaluates to true (non-zero) then the program executes the statements between the DO clause and the ENDWHILE clause. Upon hitting the ENDWHILE, the program jumps back to the WHILE, reevaluates the expression, and repeats the process. Should the expression ever evaluate to false, control transfers to the first statement following the matching ENDWHILE. Note that if the expression evaluates to false when the program first encounters the WHILE statement, the program will not execute any of the statements between the DO and the ENDWHILE clauses.\par
\pard\li360\sb72\tx1144\expndtw0\f1\fs18\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1144\b\f7\fs20  \f0\fs28 Implementing HLA Basic\par
\pard\fi360\li360\qj\b0\fs20\par
HLA Basic will consist of three main components: the \i tokenizer-compiler\i0 , the \i detokenizer\i0  utility, and the \i run-time interpreter\i0 .  Each of these three components will be written in the HLA programming language.\par
\par
The \b tokenizer-compiler component\b0  will read a HLA Basic source file (a text file), translate the source file to a \ldblquote byte code\rdblquote  format, and then write the compiled byte code to a \ldblquote .hbbc\rdblquote  file.  \ldblquote .hbbc\rdblquote  files are compiled binary (hbbc = \ldblquote HLA Basic Byte Code\rdblquote ) versions of the HLA Basic programs.  The tokenization/compilation process will do two things: first, it will convert the text data form of a HLA Basic program into a compact \ldblquote tokenized\rdblquote  form with all reserved words converted to a single byte and numeric/string data converted to a binary form (with a prefix byte code to specify the data type). Having the source program tokenized in this manner will improve execution time of the interpreted program by two orders of magnitude.  The second thing the tokenizer/compiler will do is to \ldblquote compile\rdblquote  the program by filling in target addresses of labels and variables so these values do not have to be computed at run time. Again, this improves run-time performance. \par
\par
The tokenizer/compiler is also responsible for determining the syntactical correctness of the HLA Basic program. If there are any syntactical (or other detectable) errors in the source file, the compiler will report the error and it will not produce a \ldblquote .hbbc\rdblquote  file from the compilation.  \par
\par
The \b detokenizer\b0  is a small utility program that takes a \ldblquote .hbbc\rdblquote  file and converts it back into a source file.  Strictly speaking, the detokenizer program isn\rquote t necessary. Presumably, the original source file is still available and anyone interested in reading the source code can look at the original source file. However, source files do get lost (in particular, older versions of source code can get lost) and a detokenizer utility is useful for verifying that a \ldblquote .hbbc\rdblquote  file really does correspond to the most recent source file available for the given module (or reconstructing the source file, if necessary). The detokenizer utility program will also be instrumental in verifying the operation of the tokenizer/compiler program.\par
\par
The \b run-time interpreter\b0 , unlike the previous two HLA Basic components, is not a stand-alone application. Instead, the run-time interpreter will be a module that is part of the main HLA application. This interpreter will be part of the CCS application program.  The run-time interpreter will have two main entry points that are callable from the main HLA application: \i initialization\i0  and \i resume\i0 . The \i initialization\i0  entry point of the interpreter will be called once for each HLA Basic module that the main application loads into memory during the system initialization phase. Thereafter, when the main application resumes execution of the module, it will call the \i resume\i0  entry point. The main difference between the two entry points is that the \i initialization\i0  entry point will zero out all data memory and start the interpreter running on the \ldblquote .hbbc\rdblquote  file at the first statement in the file; the \i resume\i0  entry point will enter the interpreter without clearing out variable storage (that is, it will preserve the previous values from the last execution of that module\rquote s code) and it will continue execution with the statement after the last \i suspend\i0  statement the module executed.\par
\par
An execution image of a HLA Basic module will contain two parts: a code section (that corresponds to the data in the \ldblquote .hbbc\rdblquote  file) and a data section. These two sections will be a maximum of 64Kbytes long (each). Note that HLA Basic maintains variable string data outside these two sections, so strings created at run-time do not consume any storage in the code or data sections (note, however, that literal strings appearing in the source file are encoded into the \ldblquote .hbbc\rdblquote  file and are part of the code section). Also note that global data objects are maintained outside the HLA Basic module\rquote s data space. Given that most modules should be quite short, 64K each should be more than sufficient room for the code and data sections. \par
\par
\par
\pard\li360\sb72\tx1144\f1\fs18\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1144\b\f7\fs20  \f0\fs28 Incorporating HLA Basic Programs into an HLA Application\par
\pard\fi360\li360\qj\b0\fs20\par
HLA Basic programs are always run from an enclosing HLA program.  The HLA application creates a Basic program \i object\i0 , loads the byte code into the memory reserved for the Basic object, and then invokes a method in the object to begin (or resume) execution of the Basic program.  The HLA Basic program can temporarily or permanently return control to the underlying assembly language application, allowing the two pieces of code to interact with one another.\par
\par
HLA Basic programs are maintained as \b RTPgmClass\b0  \i objects\i0  in an object-oriented HLA application.  Therefore, the first thing you must do to include an HLA Basic program in an HLA application is include the \ldblquote basic.hhf\rdblquote  header file and create a subclass of the \i rtPgmClass\i0  data type.  A simple example is the following from the be.hla source file:\par
\par
\f1 #include( "basic.hhf" )\par
\par
type\par
\tab myRTPgmClass: class inherits( rtPgmClass );\par
\tab\par
\tab\tab override procedure create;\par
\tab\tab\par
\tab endclass;\par
\tab\par
readonly\par
\tab align( 4 );\par
\tab vmt( myRTPgmClass );\par
\par
\f0\par
Most HLA applications (that aren\rquote t relatively trivial, like be.hla) will also overload one or more of the \b byteCodeExtensions\b0 ,\b  functionExtensions,\b0  and \b pseudoVarExtensions\b0  methods, as well.  The \b byteCodeExtensions\b0  method handles new statements you\rquote ve added to the HLA Basic language; the \b functionExtensions\b0  method handles new built-in functions you\rquote ve added; and the \b pseudoVarExtensions\b0  method handles new pseudo variables you\rquote ve added to the language.\par
\par
The overridden \b myRTPgmClass.create\b0  procedure always does the following (from the be.hla source file):\par
\par
\f1 /////////////////////////////////////////////////////////////////\par
//\par
// myRTPgmClass.create-\par
//\par
//\tab Overrides the rtPgmClass create function so we can properly \par
// set up the VMT pointer.\par
\par
procedure myRTPgmClass.create( filename:string; pgmData:dword ); \par
begin create;\par
\par
\tab if( esi = NULL ) then\par
\tab\par
\tab\tab rtPgmClass.create( filename, pgmData );\par
\tab\tab\par
\tab else\par
\tab\par
\tab\tab (type rtPgmClass [esi]).create( filename, pgmData );\par
\tab\tab\par
\tab endif;\par
\tab mov( &myRTPgmClass._VMT_, this._pVMT_ );\par
\par
end create;\par
\f0\par
Essentially, this sets up the the virtual method table (VMT) pointer in the class. Strictly speaking, if you do not override any of the \b byteCodeExtensions, functionExtensions,\b0  or \b pseudoVarExtensions\b0  methods, you could directly use the \b rtPgmClass\b0  data type and skip writing a new create method. However, most programs that use HLA Basic will probably want to, at the very least, add some pseudo variables to the language (so the HLA Basic program can easily communicate with the underlying HLA code). Therefore, you\rquote ll almost always create a derived class (like myRTPgmClass, above) and write the overridden \b create\b0  method.\par
\par
In order to execute an HLA Basic program, you must create an actual Basic program class object (e.g., a \b myRTPgmClass\b0  variable) that will maintain the state of the Basic program during its execution.  If you\rquote ve named your derived \b rtPgmClass\b0  data type \b myRTPgmClass\b0  (as all the examples in this document use; just keep in mind that you can use any unique name for your derived class),  then you could use a statement like the following to create the Basic object variable:\par
\par
\pard\f1\tab pgm\tab :myRTPgmClass;\par
\pard\fi360\li360\qj\f0\par
The first thing you must do with your program variable is initialize the object (possibly allocating storage for it) and load the HLA Basic Byte Code data into the object. This is done with a call to the \b myRTPgmClass.create\b0  procedure.  This procedure has two parameters: a filename string and a pointer to some byte code data. Currently, the interpreter only supports loading byte code from a file, so the system ignores the second parameter and raises an exception if you pass a NULL value as the first argument (the filename parameter slot).  Assuming that the file \ldblquote myBasicPgm.hbbc\rdblquote  is in the same directory as your HLA application\rquote s executable, here\rquote s the command that will initialize the \b pgm\b0  object above and load the byte code data from the file in memory:\par
\par
\f1\tab pgm.create( \ldblquote myBasicPgm.hbbc\rdblquote , NULL );\par
\f0\par
This call to create initializes the Basic program, but does not start its execution. Once the \b create\b0  method loads the byte code data and initializes the object, it returns control back to your HLA program.\par
\par
There are three methods in the \b rtPgmClass\b0  data type that you will use to control the execution of HLA Basic programs: \b run, resume,\b0  and \b reset\b0 . \par
\par
The \b run\b0  method does a quick \ldblquote in-memory compile\rdblquote  of the byte code that create loads into memory and then transfers control to the \b resume\b0  method that begins the execution of the program. You should only call the \b run\b0  method once, after the execution of the \b create\b0  procedure; the \b run\b0  method assumes that the Basic run-time system is in an initial state (as set up by the \b create\b0  procedure).\par
\par
The \b reset\b0  method restarts a Basic program that was previously executing.  It deallocates all storage associated with existing Basic variables (that is, it sets them all to \ldblquote uninitialized\rdblquote  and restarts the program to run with the first byte code in the byte code file (corresponding to the first line of source code).  Typically, you would invoke the reset method after a Basic program stops because it \ldblquote ran off the end\rdblquote  of the program. You can also restart a program that has terminated by executing a \i stop\i0  statement by using the \b reset\b0  method, though the convention is to use \i stop\i0  when there is some sort of catastrophic failure in the Basic code, and restarting the program might not make a lot of sense at that point (e.g., it might just execute \i stop\i0  again, leading to an endless loop of stops and resets).\par
\par
The \b resume\b0  method also restarts a Basic program.  It does not, however, deallocate storage for all the variables and reset the program to its initial state. The resume method is intended to be used when a program suspends execution via the \i suspend\i0  statement.  When you invoke the \b resume\b0  method, execution continues in the statement after the \i suspend\i0  statement that suspended the program.  Warning: do not execute the \b resume\b0  method unless the program has been suspended.  The result is indeterminate if you execute resume and the program had stopped (via the \i stop\i0  statement or by running off the end if the program file).\par
\par
As noted earlier, there are three ways the execution of an HLA Basic program stops and control returns to the HLA program: via the \i stop\i0  statement, by running off the end of the program file, or by executing a \i suspend\i0  statement.  In order to resume or restart the program, you will need to know how the program returned to your assembly code.\par
\par
Executing a stop instruction raises the \i PgmStopException\i0  exception. The code for this exception is defined in the basic.hhf header file. If you do not want your HLA program to abort whenever the Basic code executes a \i stop\i0  statement, you will need to put a \i try..endtry\i0  statement around your calls to \b run, reset,\b0  and \b resume\b0  and provide an exception clause to catch this exception.  If you decide to go ahead and restart the program after catching the \i PgmStopException\i0  exception, be sure to use a \b reset\b0  call, not a \b resume\b0  call.\par
\par
If a Basic program executes the \i suspend\i0  statement, or terminates because it \ldblquote ran off the end of the program,\rdblquote  then execution simply returns from the last \b run, reset\b0 , or \b resume\b0  call you\rquote ve made.  The EAX register will contain zero if the program terminated by running off the end of the source file; EAX will contain one if the program executed a suspend statement.  By using this return value, you can determine if you should restart the program with the \b resume\b0  method (if EAX was one) or the \b reset\b0  method (if EAX was zero).\par
\par
In addition to the \i PgmStopException\i0  that HLA Basic raises if you execute a \i stop\i0  statement, there are several other Basic-specific exceptions that HLA Basic can raise and you should probably be prepared to handle.  The following are the exceptions and their explanation; note that some of the exceptions are compile-time only, some are run-time only\par
\par
\i BasicError\par
\i0 This is a generic (compile-time) syntax error.\par
\tab\tab\par
\i BasicErrorWithMsg\par
\i0 This is a generic error exception. The object-specific field this.exceptionMsg will contain a string associated with this exception that describes the actual error.\par
\par
\i StmtTooLongException\par
\i0 This is a compile-time error that the system raises if an HLA Basic statement generates more byte codes than the system allows (i.e., you need to break the statement up into multiple statements).\par
\par
\i SyntaxErrorException\par
\i0 The HLA Basic compiler raises this error if there is a syntactical problem with the current statement.\par
\par
\i PgmStopException\par
\i0 The HLA Basic interpreter raises this exception when it executes a \i stop\i0  statement.\par
\par
\i LabelSyntaxException\par
\i0 The HLA Basic compiler raises this exception if there is a syntax error in a label.\par
\par
\i ExprSyntaxException\par
\i0 The HLA Basic compiler raises this exception if there is a syntax error in an arithmetic expression.\par
\par
\i tooManySymbols\par
\i0 The HLA Basic compiler raises this exception if the current source file has more than 512 user-defined identifiers.\par
\par
\i StrToNumberError\par
\i0 This error shouldn\rquote t happen, but if it does there was a failure at run time when converting a string to a number.  Usually, HLA Basic will raise the appropriate conversion or range exception if there is a problem converting a string to a numeric value.\par
\par
\i NumToStrError\par
\i0 The HLA Basic run time system raise this error if you try to convert something other than a numeric value (or string) to a string object (e.g., converting an array to a string)\par
\par
\i typeMismatch\par
\i0 The Basic run time system raises this exception if the operand data types are illegal.\par
\par
typeMismatchIntOpStr\par
typeMismatchStrOpInt\par
typeMismatchRealOpStr\par
typeMismatchStrOpReal\par
The HLA Basic run time system raises these exceptions when an operator expects numeric types around an operator, but instead found a string that it could not convert to the specific numeric type (e.g., typeMismatchIntOpStr means you should have \ldblquote int op int\rdblquote  and the system could not convert the string operand to an integer). \par
\par
\i AttemptToDeallocateLabel\par
\i0 This is an internal error.\par
\par
\par
Perhaps the easiest way to describe how to run an HLA Basic program from an HLA application is by presenting a simple example. The following code is a relatively trivial application that contains all the scaffolding code to load a single HLA Basic byte code file and execute that file. If the program terminates by some exception (including executing a \i stop\i0  statement), then the program terminates.  If the Basic program executes a suspend statement, then it waits until the user presses the enter key and resumes execution. If the program stops by running off the end of the Basic file, then it waits for the user to press the enter key and will then restart the program.\par
\par
\pard\li90\f1\fs18 program HLA_Basic_Shell;\par
?@nodisplay := true;\par
?@noalignstack := true;\par
\par
#include( "stdlib.hhf" )\par
#include( "basic.hhf" )\par
\par
type\par
\tab myRTPgmClass: class inherits( rtPgmClass );\par
\tab\par
\tab\tab override procedure create;\par
\tab\tab\par
\tab endclass;\par
\tab\par
readonly\par
\tab align( 4 );\par
\tab vmt( myRTPgmClass );\par
\par
storage\par
\tab align( 4 );\par
\tab\par
\tab\par
\tab // Application globals:\par
\tab\par
\tab fileExt\tab\tab :string;\par
\tab filename\tab\tab :string;\par
\tab sourceFile\tab\tab :string;\par
\tab byteCodeFile\tab\tab :string;\par
\tab cmdline\tab\tab :string;\par
\tab pgm\tab\tab\tab :myRTPgmClass;\par
\tab\par
\tab\par
\tab fileExtBuf\tab\tab :byte[1024];\par
\tab byteCodeBuf\tab\tab :byte[1024];\par
\tab cmdLnBuf\tab\tab :byte[1024];\par
\tab sourceFileBuf\tab\tab :byte[1024];\par
\par
\par
readonly\par
\par
\tab align( 4 );\par
\tab BasicTitle\tab :string := "HLA Basic Interpreter V2.1";\par
\par
\par
procedure usage;\par
begin usage;\par
\par
\tab stdout.put( "Usage: be <byte-code-filename>" nl );\par
\tab os.exitProcess( 1 );\par
\tab\par
end usage;\par
\par
\par
\par
\par
/*****************************************/\par
/*                                       */\par
/* AtLineNumber-                         */\par
/*                                       */\par
/* A little utility routine that prints  */\par
/* " at line number xx" where xx is the  */\par
/* current source file line number (this */\par
/* code assumes that EBX is pointing at  */\par
/* the start of the current line).       */\par
/*                                       */\par
/*****************************************/\par
\par
procedure AtLineNumber( ip:dword in ebx ); @nodisplay; @noframe;\par
begin AtLineNumber;\par
\par
\tab stdout.put( "at line number ", (type StmtRec [ebx]).lineNum, nl );\par
\tab ret();\par
\tab\par
end AtLineNumber;\par
\par
\par
\par
\par
//////////////////////////////////////////////////////////////////////////////\par
//\par
// myRTPgmClass.create-\par
//\par
//\tab Overrides the rtPgmClass create function so we can properly set up\par
// the VMT pointer.\par
\par
procedure myRTPgmClass.create( filename:string; pgmData:dword ); \par
begin create;\par
\par
\tab if( esi = NULL ) then\par
\tab\par
\tab\tab rtPgmClass.create( filename, pgmData );\par
\tab\tab\par
\tab else\par
\tab\par
\tab\tab (type rtPgmClass [esi]).create( filename, pgmData );\par
\tab\tab\par
\tab endif;\par
\tab mov( &myRTPgmClass._VMT_, this._pVMT_ );\par
\par
end create;\par
\par
\par
\par
\par
\par
\par
/////////////////////////////////////////////////////////////////////////////\par
\par
\tab\par
begin HLA_Basic_Shell;\par
\par
\tab str.init( fileExtBuf, 1024 );\par
\tab mov( eax, fileExt );\par
\tab\par
\tab str.init( byteCodeBuf, 1024 );\par
\tab mov( eax, byteCodeFile );\par
\tab\par
\tab str.init( cmdLnBuf, 1024 );\par
\tab mov( eax, cmdline );\par
\tab\par
\tab str.init( sourceFileBuf, 1024 );\par
\tab mov( eax, sourceFile );\par
\tab\par
\tab\par
\tab\par
\tab\par
\tab  \par
\tab\par
\tab // Start it off running.\par
\tab\par
\tab stdout.put( BasicTitle, nl );\par
\tab\par
\tab // Get the bytecode filename from the command line\par
\tab\par
\tab arg.c();\par
\tab if( eax <> 2 ) then\par
\tab\par
\tab\tab usage();\par
\tab\tab os.exitProcess( 1 );\par
\tab\tab\par
\tab endif;\par
\tab arg.a_v( 1 );\par
\tab mov( eax, filename );\par
\tab\par
\tab // See if the filename has an extension attached to it:\par
\tab\par
\tab filesys.extractExt( filename, fileExt );\par
\tab\par
\tab // If the extension is ".bas" then we need to first compile the file:\par
\tab  \par
\tab if( str.eq( fileExt, HLABasicSourceCodeExt_c )) then\par
\tab\par
\tab\tab // If it's a ".bas" source file, then compile it to\par
\tab\tab // a byte code file.\par
\tab\tab\par
\tab\tab str.put( cmdline, "bc ", filename );\par
\tab\tab os.system( cmdline );\par
\tab\tab if( eax <> 0 ) then\par
\tab\tab\par
\tab\tab\tab os.exitProcess( 1 );\par
\tab\tab\tab\par
\tab\tab endif;\par
\tab\tab\par
\tab\tab filesys.deleteExt( filename, byteCodeFile );\par
\tab\tab str.cat2( "." HLABasicByteCodeExt_c , byteCodeFile );\par
\tab\tab  \par
\tab // If the extension is a byte code extension (e.g., "hbbc") then\par
\tab // we can just execute the file:\par
\tab\par
\tab elseif( str.eq( fileExt, HLABasicByteCodeExt_c )) then\par
\tab\par
\tab\tab str.cpy( filename, byteCodeFile );\par
\tab\tab\par
\tab else\par
\tab\par
\tab\tab // If the extension is not ".bas" or ".hbbc" / ".tbbc" then\par
\tab\tab // we need to see (in this order):\par
\tab\tab //\par
\tab\tab //\tab 1)\tab Does <filename>.hbbc (<filename>.tbbs) exist? If so,\par
\tab\tab //\tab\tab execute that file.\par
\tab\tab //\par
\tab\tab //\tab 2)\tab Does <filename>.bas exist? If so, compile and execute\par
\tab\tab //\tab\tab that file.\par
\tab\tab\par
\tab\tab str.cat3( filename, "." HLABasicByteCodeExt_c, byteCodeFile );\par
\tab\tab if( !filesys.exists( byteCodeFile )) then\par
\tab\tab\par
\tab\tab\tab\par
\tab\tab\tab // Check to see if a ".bas" file exists:\par
\tab\tab\tab\par
\tab\tab\tab str.cat3\par
\tab\tab\tab (\par
\tab\tab\tab\tab filename, \par
\tab\tab\tab\tab "." HLABasicSourceCodeExt_c, sourceFile \par
\tab\tab\tab );\par
\tab\tab\tab if( filesys.exists( sourceFile )) then\par
\tab\tab\tab\par
\tab\tab\tab\tab // Okay, ".bas" file exists, compile it:\par
\tab\tab\tab\par
\tab\tab\tab\tab str.put( cmdline, "bc ", sourceFile );\par
\tab\tab\tab\tab os.system( cmdline );\par
\tab\tab\tab\tab if( eax <> 0 ) then\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab\tab os.exitProcess( 1 );\par
\tab\tab\tab\tab\tab\par
\tab\tab\tab\tab endif;\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab // Note that the "byteCodeFile" string contains the\par
\tab\tab\tab\tab // full bytecode filename (plus extension) at this \par
\tab\tab\tab\tab // point.\par
\tab\tab\tab\tab\par
\tab\tab\tab else\par
\tab\tab\tab\par
\tab\tab\tab\tab stdout.put\par
\tab\tab\tab\tab ( \par
\tab\tab\tab\tab\tab "Could not compile or run ", \par
\tab\tab\tab\tab\tab filename, \par
\tab\tab\tab\tab\tab nl \par
\tab\tab\tab\tab );\par
\tab\tab\tab\tab os.exitProcess( 1 );\par
\tab\tab\tab\tab\par
\tab\tab\tab endif;\par
\tab\tab\tab\par
\tab\tab // else  -- We're in business, just use the byte code file.\par
\tab\tab\tab\par
\tab\tab endif;\tab\tab\tab  \par
\tab\par
\tab endif;\par
\tab if( !filesys.exists( byteCodeFile )) then\par
\tab\par
\tab\tab stdout.put( "No such bytecode file: ", byteCodeFile, nl );\par
\tab\tab os.exitProcess( 1 );\par
\tab\tab\par
\tab endif;\par
\tab stdout.put( "Running '", byteCodeFile, "'" nl nl );\par
\tab\par
\tab pgm.create( byteCodeFile, NULL );\par
\tab try\par
\tab\par
\tab\tab pgm.run();\par
\tab\tab forever\par
\tab\tab\par
\tab\tab\tab if( eax = 0 ) then\par
\tab\tab\tab\par
\tab\tab\tab\tab stdout.put\par
\tab\tab\tab\tab ( \par
\tab\tab\tab\tab\tab "Program 'ran off the end', \ldblquote\par
\tab\tab\tab\tab\tab\ldblquote press enter to restart: "\par
\tab\tab\tab\tab );\par
\tab\tab\tab\tab stdin.readLn();\par
\tab\tab\tab\tab stdin.flushInput();\par
\tab\tab\tab\tab pgm.reset();\par
\tab\tab\tab\tab\par
\tab\tab\tab else // EAX must equal 1\par
\tab\tab\tab\par
\tab\tab\tab\tab stdout.put\par
\tab\tab\tab\tab (\par
\tab\tab\tab\tab\tab "Program suspended, press enter to resume: "\par
\tab\tab\tab\tab );\par
\tab\tab\tab\tab stdin.readLn();\par
\tab\tab\tab\tab stdin.flushInput();\par
\tab\tab\tab\tab pgm.resume();\par
\tab\tab\tab\tab\par
\tab\tab\tab endif;\par
\tab\tab\tab\par
\tab\tab endfor;\par
\tab\tab\par
\tab\tab\par
\tab\tab\par
\tab   exception( PgmStopException )\par
\tab   \par
\tab\tab stdout.put( nl "Executed STOP " );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab\par
\tab   exception( BasicError )\par
\par
\tab\tab stdout.put\par
\tab\tab ( \par
\tab\tab\tab nl \par
\tab\tab\tab "Program stopped because of BASIC run-time error " \par
\tab\tab );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab\par
\tab   exception( BasicErrorWithMsg )\par
\par
\tab\tab stdout.put\par
\tab\tab ( \par
\tab\tab\tab nl \par
\tab\tab\tab "Program stopped because of BASIC run-time error " \par
\tab\tab );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab stdout.put( pgm.exceptionMsg, nl );\par
\tab\tab\par
\tab   exception( typeMismatch )\par
\tab   \par
\tab\tab stdout.put( nl "Type mismatch in expression " );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab\par
\tab   exception( typeMismatchIntOpStr )\par
\tab   \par
\tab\tab stdout.put( nl "Type mismatch in expression (int op str) " );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab\par
\tab   exception( typeMismatchStrOpInt )\par
\tab   \par
\tab\tab stdout.put( nl "Type mismatch in expression (str op int) " );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab\par
\tab   exception( typeMismatchRealOpStr )\par
\tab   \par
\tab\tab stdout.put( nl "Type mismatch in expression (real op str) " );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab\par
\tab   exception( typeMismatchStrOpReal )\par
\tab   \par
\tab   \tab stdout.put( nl "Type mismatch in expression (str op real) " );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab\par
\tab   exception( BadPgmDataException )\par
\tab   \par
\tab   \tab stdout.put\par
\tab\tab ( \par
\tab\tab\tab nl \par
\tab\tab\tab "Program stopped because of byte code file corruption " \par
\tab\tab );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab\par
\tab   exception( StrToNumberError )\par
\tab   \par
\tab   \tab stdout.put( nl "Unknown error in StrToNumber function " );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab\par
\tab   exception( NumToStrError )\par
\tab\tab\par
\tab   \tab stdout.put\par
\tab\tab ( \par
\tab\tab\tab nl \par
\tab\tab\tab "Illegal parameter data type in NumberToStr function " \par
\tab\tab );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab\par
\tab   exception( AttemptToDeallocateLabel )\par
\tab\tab\par
\tab   \tab stdout.put( nl "Attempted to overwrite a label object " );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab\par
\tab\tab\par
\tab   anyexception\par
\tab   \tab\par
\tab\tab ex.exceptionMsg( eax, pgm.exceptionMsg );\par
\tab\tab stdout.put\par
\tab\tab ( \par
\tab\tab\tab nl \par
\tab\tab\tab "Exception: ", \par
\tab\tab\tab pgm.exceptionMsg,\par
\tab\tab\tab nl\par
\tab\tab\tab "Occurred during program execution " \par
\tab\tab );\par
\tab\tab AtLineNumber( pgm.ip );\par
\tab\tab\par
\tab endtry;\tab    \par
\tab stdout.put( nl nl, BasicTitle, nl "Execution stopped" nl );\par
\par
\par
end HLA_Basic_Shell;\par
\pard\fi360\li360\qj\fs20\par
\f0\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1144\b\f7  \f0\fs28 Executing Multiple HLA Basic Programs in the same HLA Program\par
\pard\fi360\li360\qj\b0\fs20\par
It is quite possible to have several different HLA Basic programs in various stages of execution within a single HLA assembly language program. Indeed, this is probably more common than only executing a single HLA Basic program from an assembly application.  This section describes how to do that and the motivation for it.\par
\par
A useful way to think about HLA Basic programs within an HLA assembly language application is to view them as user-written macros that can change the behavior of the underlying application.  Suppose, for example, that you\rquote ve written a text editor. Let\rquote s suppose that your text editor supports some form of syntax highlighting that displays certain keywords in different colors. You can allow the user to choose which key words take on certain colors by having them write an HLA Basic program that processes a reserved word string (passed in via a pseudo-variable) that determines the color it should take on.  A different HLA Basic program could be used to perform specialized search functionality. You could invoke (resume) each of these HLA Basic programs by resuming a different \i rtPgmClass\i0 -derived object in your HLA assembly language application.\par
\par
To achieve this, you would begin by create two (or more) rtPgmClass-derived (e.g., myRTPgmClass variables) such as the following:\par
\par
\f1 syntaxColorChk\tab :myRTPgmClass;\par
specialSearch\tab :myRTPgmClass;\par
\f0\par
A typical embedded HLA Basic program contains two parts: an initialization section that executes once when the program first loads into memory and a main section that executes once for each resumption of the code by the assembly language application (that is, at the end of each iteration, the main section of the HLA Basic program suspends to return control to the HLA application, and then loops back to the beginning of the main section when the HLA application resumes the Basic program). The structure of a typical embedded HLA Basic application looks like this:\par
\par
\f1 << initialization code that executes once >>\par
\par
forever:\par
\par
\tab << Code to execute on each resumption >>\par
\tab suspend\par
\par
goto forever\par
\par
\f0 Here\rquote s what the \i syntaxColorChk\i0  program might look like (for a very simple version of the program):\par
\par
\f1 rem Initialize the color constants:\par
\par
black\tab\tab = 0 \tab  \par
red\tab\tab = 1\tab  \par
green\tab\tab = 2\tab  \par
yellow\tab = 3 \par
blue\tab\tab = 4\tab  \par
magenta\tab = 5\par
cyan\tab\tab = 6\tab  \par
white\tab\tab = 7\tab  \par
gray\tab\tab = 8\tab  \par
ltGray\tab = 9 \par
dkGray\tab = 10\par
\par
rem Initialize a table of reserved words\par
\par
rsvWrds = dim(4)\par
rsvWrds[0] = \ldblquote if\rdblquote\par
rsvWrds[1] = \ldblquote then\rdblquote\par
rsvWrds[2] = \ldblquote else\rdblquote\par
rsvWrds[3] = \ldblquote endif\rdblquote\par
\par
\par
forever:\par
\tab rem Wait for request to do syntax coloring:\par
\par
\tab suspend\par
\par
\tab rem Fetch the string to check from the @reservedWord\par
\tab rem pseudo-variable:\par
\par
\tab curWrd = @reservedWord\par
\par
\tab rem Compare the input string against our list of reserved\par
\tab rem   words and set the @color pseudo-variable to an\par
\tab rem   appropriate value if we match a reserved word\par
\tab rem\par
\tab rem Begin by assuming we \b don\rquote t\b0  have a reserved word:\par
\par
\tab @color = white\par
\tab for i = 0 to 3\par
\par
\tab\tab if( rsvWrds[i] = curWrd ) then\par
\par
\tab\tab\tab rem If we have reserved word, change the\par
\tab\tab\tab rem   color to blue to signify that.\par
\par
\tab\tab\tab @color = blue\par
\par
\tab\tab endif\par
\par
\tab next i\par
\par
goto forever\par
\par
\tab\par
\f0 The HLA assembly language editor application would run this program immediately after invoking the \b myRTPgmClass.create\b0  method in order to execute the initialization code:\par
\f1\par
syntaxColorChk.create( \ldblquote syntaxColor.hbbc\rdblquote , NULL );\par
syntaxColorChk.run();\par
\par
\f0 This will run the above code up to the suspend statement (right after the \i forever\i0  label).  At this point, the Basic code is suspended waiting for a request from the HLA assembly code to do an actual syntax coloring operation. At some other point in the assembly code, when you want to determine if you should color some text, you\rquote d execute code like this:\par
\par
\f1 // Put the word/string to check into the currentWord string\par
// variable (which the @reservedWord pseudo variable will\par
// access \endash  see the section on \ldblquote Extending HLA Basic\rdblquote  for\par
// an explanation of how to connect an HLA Basic pseudo variable\par
// to an HLA object.\par
\par
<< do whatever you need to do to copy the word to \ldblquote currentWord\rdblquote\par
\par
// Invoke the HLA Basic code to check the reserved word\par
\par
syntaxColorChk.resume();\par
\par
// At this point, whatever HLA variable connects with the\par
// @color pseudo variable (let\rquote s say \ldblquote textColor\rdblquote ) contains either\par
// white or blue. Use that color to draw the text in the\par
// appropriate color for this word:\par
\par
console.setAttrs( textColor, console.black );\par
stdout.puts( currentWord );\par
\par
<< process the next word >>\par
\f0\tab\tab  \par
While the \b syntaxColorChk\b0  program is suspended, you may resume or run any other HLA Basic program you\rquote ve created in your HLA application. For example, after \b syntaxColorChk\b0  suspends (perhaps because you\rquote re done listing the file), you can invoke the \b specialSearch.resume\b0  method to do a search. Because \b specialSearch\b0  is a completely different object from \b syntaxColorChk\b0  and they do not share any program state, running one Basic application does not affect the operation of the other.\par
\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1144\b\f7  \f0\fs28 Extending HLA Basic\par
\pard\fi360\li360\qj\b0\fs20\par
HLA Basic is an extensible domain-specific language intended for embedded applications (embedded in this sense means embedded in a different application, not necessarily the hardware-embedded application space).  HLA Basic is a public-domain open-source system that provides a generic BASIC-like programming language compiler and interpreter. The system is object-oriented making it easy to extend and also allowing the execution of multiple BASIC programs from the same application (as each execution instance is a single object in the main application, and it\rquote s possible to instantiate multiple HLA Basic objects in that main application).  Though HLA Basic provides a generic programming language, the real power of HLA BASIC is realized by extending the language with additional statements, functions, pseudo variables, and other features to make the language truly application-specific. This section describes how this is done.\par
\pard\qj\par
\pard\fi360\li360\qj Whenever a change is necessary in the HLA Basic system, it\rquote s important to realize that you must change three different programs to reflect that change: the HLA Basic compiler (\i bc\i0 ), the HLA Basic decompiler (\i bd\i0 ; this is optional, but you really should maintain the decompiler as this is a very useful debugging tool), and the HLA Basic interpreter (the \i bx\i0  object module, that links with the main HLA applications).  Technically speaking, a well-designed extension to the HLA Basic language would not affect the actual \i bx\i0  object module.  The interpreter\rquote s object-oriented design allows you to put application-specific code in the main application, where you subclass HLA Basic interpreter objects. However, logically this is an extension of the \i bx\i0  object-code module even if the modifications don\rquote t take place directly in the bx.hla source file.\par
\par
\pard Note that the HLA Basic interpreter is written in High-Level Assembly language (HLA). Before you freak out, HLA code is very high-level (indeed, higher-level than C/C++ in many cases); it\rquote s not like the assembly language of the 1980\rquote s (and earlier) that has a deserved reputation for being hard to read and maintain.  HLA is described on the web at http://webster.cs.ucr.edu/AsmTools/HLA/index.html. You can also find an electronic edition of the book \ldblquote Art of Assembly Language\rdblquote  that teaches the HLA language at http://webster.cs.ucr.edu/AoA/index.html.  Fortunately, modifying HLA Basic will not require you to become an expert assembly language programmer, but you will need to learn about some functions in the HLA Standard Library that the compiler and interpreter use.  We\rquote ll get into those requirements in a little bit.\par
\par
For HLA Basic, there are four types of extensions you will typically make to the language: new statements, new functions, new pseudo variables, and (possibly) new operators. The following sections will cover each of these extensions in detail.\par
\par
\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1144\b\f7  \f0\fs28 HLA Basic Site-Specific Header File\par
\pard\fi360\li360\qj\b0\fs20\par
HLA Basic was designed to be embedded in other HLA (assembly language) applications. By design, therefore, the HLA Basic system must contain application-specific code.  For the most part, this application-specific code is separated from the Basic compiler, interpreter, and decompiler, so that the generic HLA Basic language can be maintained independently from whatever applications incorporate HLA Basic. However, to make it easy to extend HLA Basic, some application-specific (known as \i site-specific\i0 ) code must be included in by the compiler, interpreter, and decompiler. To minimize coupling and improve maintainability, this site-specific include file information is placed in a special header file named, appropriately enough, siteSpecific.hhf.\par
\par
The siteSpecific.hhf header file, at the very least, must define one text constant symbol, one string constant, two macros, and one array array constant:  HLABasicByteCodeExt_c, siteTitle_c, siteSpecificPseudoVars, siteSpecificFunctions,  and siteSpecificStmts_c, respectively.  For a generic HLA Basic system with no site-specific extensions, you would normally define these as follows:\par
\par
\pard\li360\ri-450\tx540\tx630\f1\tab\tab // If no site-specific code, then use "hbbc" as the default\par
\tab\tab // suffix for HLA Basic Byte Code files:\par
\tab\tab\par
const\par
\tab\tab HLABasicByteCodeExt_c :text := """hbbc""";\par
\par
\tab // siteTitle_c is the name of the site-specific BASIC language.\par
\tab // Use \ldblquote HLA-Basic Compiler vX.Y\rdblquote  as the default compiler title\par
\par
\tab siteTitle_c\tab :string := \ldblquote HLA Basic Compiler v2.2\rdblquote  nl;\par
\tab\tab\par
\tab\tab\par
\tab\tab // If no site-specific code, then we must create an empty macro\par
\tab\tab // for "siteSpecificPseudoVars":\par
\tab\tab\par
\tab\tab #macro siteSpecificPseudoVars;\par
\tab\tab #endmacro\par
\tab\tab\par
\tab\tab\par
\tab\tab // If no site-specific code, then we must create an empty macro\par
\tab\tab // for "siteSpecificFunctions":\par
\tab\tab\par
\tab\tab #macro siteSpecificFunctions;\par
\tab\tab #endmacro\par
\tab\tab\par
\tab\tab\par
\tab // If no site-specific code, then we must create \par
\pard\ri-450\tx540\tx630\tab // a siteSpecificStmts_c array with a single dummy entry:\par
\pard\li360\ri-450\tx540\tx630\tab\tab\par
\pard\li360\qj\tab\tab const\par
\tab\tab\tab siteSpecificStmts_c\tab :stmt_t[] := \par
\tab\tab\tab [\par
\tab\tab\tab\tab // Last entry isn't referenced.\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab stmt_t:[ "    dummy    ",\tab\tab  0, 0\tab\tab ]\par
\tab\tab\tab ];\par
\par
\tab\tab   \par
\pard\fi360\li360\qj\f0\par
The symbol HLABasicByteCodeExt_c is a text constant that expands to a literal string constant that defines the suffix used for HLA Basic Byte Code files. The default string is \ldblquote hbbc\rdblquote  (HLA Basic Byte Code). For certain applications you may want to change this suffix to avoid conflicts with other HLA Basic applications that use a different byte code file format. For example, TRIGA Basic Byte Code files use a suffix of \ldblquote tbbc\rdblquote  to differentiate them from standard HLA Basic files.  Here is the definition of the HLABasicByteCodeExt_c symbol as used in TRIGA Basic, for example:\par
\par
\pard\li360\ri-450\tx540\tx630\f1 const\par
\tab\tab HLABasicByteCodeExt_c :text := """tbbc""";\par
\par
\pard\fi360\li360\qj\f0 Whenever the compiler executes, it displays the title specified by the siteTitle_c string constant. Normally this is \ldblquote HLA Basic Compiler\rdblquote  plus the version number. If you are creating a variant of HLA Basic, you may want to change this title to reflect the new language name.  For example, the TRIGA Basic implementation of HLA Basic uses the following title definition:\par
\par
\pard\li360\ri-450\tx540\tx630\f1 const\par
\tab\tab siteTitle_c :text := "TRIGA-Basic Compiler v2.2";\par
\pard\fi360\li360\qj\f0\par
The basic.hhf file uses the macro \ldblquote siteSpecificPseudoVars\rdblquote  to fill in various fields in the data structure that defines pseudo-variables. A later section will explain how to define this macro; if you are not defining new pseudo-variables in your site-specific version of HLA Basic, then you would define an empty macro, as above.\par
\par
The basic.hhf file uses the macro \ldblquote siteSpecificFunctions\rdblquote  to fill in various fields in the data structure that defines built-in functions. A later section will explain how to define this macro; if you are not defining new functions in your site-specific version of HLA Basic, then you would define an empty macro, as above.\par
\par
The basic.hhf header file also defines a constant array (type stmt_t) that has the name  \ldblquote siteSpecificStmts_c\rdblquote .  Each element of this array contains the following data:\par
\par
\pard\li360\ri-450\tx540\tx630\f1 type\par
\tab stmt_t\tab :record\par
\tab\par
\tab\tab identifier\tab :string;\par
\tab\tab numArgs\tab\tab :uns32;\par
\tab\tab IDmap\tab\tab :dword;\par
\tab\tab\par
\tab endrecord;\par
\par
\pard\fi360\li360\qj\f0\par
The \b identifier\b0  field is a string specifying the reserved word that appears at the beginning of a user-defined statement.  The \b numArgs\b0  field specifies the number of arguments (that can be in the range 0..32).  The \b IDmap\b0  field is an array of 32 bits specifying  whether the operand must be a single ID (bit=1) or can be an arbitrary expression value (bit=1). Bit #0 corresponds to the first argument on the line.\par
\par
The siteSpecific.hhf header file provided with HLA Basic is actually the TRIGA Basic site specific file. At the beginning of the file is the declaration of the TrigaBASIC constant (true or false) that includes (or doesn\rquote t include) the TRIGA Basic specific statements. This is provided for demonstrative purposes; for any code you write (that isn\rquote t TRIGA Basic code) you\rquote ll want to simply delete all the TRIGA Basic specific code.\par
\pard\li360\ri-450\tx540\tx630\f1\par
\pard\fi360\li360\qj\f0\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1144\b\f7  \f0\fs28 HLA Pattern Matching Library\par
\pard\fi360\li360\qj\b0\fs20\par
The HLA Basic compiler makes use of the HLA Standard Library Pattern Matching Module to perform lexical analysis and parsing of the input Basic source code.   Though it would help you if you spent some time with the documentation for the HLA Standard Library\rquote s Pattern Matching Module, you could probably get by most of the time by simply cutting and pasting an existing statement and making appropriate changes to the existing code.  For example, consider the following code from the HLA Basic compiler that processes the HLA Basic \b color\b0  statement:\par
\par
\pard\li360\qj\tab\tab\f1  ////////////////////////////////////////////////////////////////////\tab\par
//\par
// Handle the COLOR <expr>, <expr> statement here.\par
\tab\tab   \par
pat.alternate\par
\tab\tab   \par
\tab // COLOR keyword:\par
\par
\tab pat.zeroOrMoreWS();\par
\tab pat.matchiWord( rw(COLORtkn) );\par
\tab PutToken( COLORtkn );\tab\tab\tab\par
\tab Expression( esi, edi );\par
\tab pat.oneChar( ',' );\par
\tab PutToken( COMMAtkn );\par
\tab Expression( esi, edi );\par
\tab pat.endStmt();\tab\tab\par
\pard\fi360\li360\qj\f0\par
\par
The \i pat.alternate\i0  statement marks the beginning of a new statement in the HLA Basic compiler; that is, the statements that follow either appear at the beginning of a Basic source line or they appear immediately after a colon (\lquote :\rquote ) statement separator character.\par
\par
The \i pat.zeroOrMoreWS\i0  function call above skips any leading whitespace characters at the beginning of the statement. The \i pat.matchiWord\i0  function call does a case insensitive comparison against a whole word (that is, the string must be followed by a non-alphanumeric or underscore character); the \i rw(COLORtkn)\i0  macro invocation expands to the string \ldblquote COLOR\rdblquote . Therefore, this statement matches the reserved word \i color\i0  at the beginning of a statement. \par
\par
The \i PutToken\i0  function call takes a single byte value and emits it to the byte code file the compiler produces. In this case, it emits a \i COLORtkn\i0  byte code to the output file.\par
\par
\i Expression\i0  is a function in the HLA Basic compiler that will compile an arithmetic expression into byte code.  The ESI register happens to point at the beginning of the current item in the source file (that is, just beyond the \i color\i0  reserved word at this point) and the EDI register points at the end of the current source line.  When this function returns, it has emitted all the byte codes that will compute the arithmetic expression it encountered and it will leave the ESI register pointing at the first byte of the source line beyond the arithmetic expression it processed.  Note that the \i Expression\i0  function call also eats any white space it finds immediately before and after the expression, there is no need to call \i pat.zeroOrMoreWS\i0  before or after this function.\par
\par
The call to \i pat.oneChar\i0  checks for the presence of a single comma following the first arithmetic expression.  If found, the following \i PutToken\i0  function call emits the comma token to the byte code file.\par
\par
The second call to the \i Expression\i0  function processes the second arithmetic expression that the color statement requires.  As for the first call to \i Expression\i0 , this call skips all surrounding white space and emits the byte codes for the expression to the output file.\par
\par
The \i pat.endStmt\i0  function is an HLA Basic compiler extension to the stdlib pattern matching functions.  It verifies that the compiler has cleanly reached the end of a statement (that is, it reaches the end of the source line or it encounters a \lquote :\rquote  character).\par
\par
The HLA stdlib pattern matching functions (including the HLA Basic extensions) don\rquote t behave like normal function calls.  They do not, for example, return some function result that denotes a successful (or unsuccessful) match.  The way the pattern matching functions work is that failure (to match an item) causes control to immediately transfer to the next \i pat.alternate\i0  statement in the source file.  That is, if any of the \i pat.matchiWord\i0 , \i Expression\i0 , or \i pat.oneChar \i0 functions fail to match the characters in the source line against their operands (or against an expression in the case of the \i Expression\i0  function) then they reset the ESI register back to where it was pointing at the beginning of the sequence (that is, to the value ESI contained when the system executed the current \i pat.alternate\i0  statement) and then control transfers to the next alternative to match.  Handling back tracking in this manner is really nifty as it saves a considerable amount of programming effort on the part of the person writing the parsing code.\par
\par
HLA Basic lexical items (reserved words and symbols) are divided into eight different types of objects: (standard) statements, miscellaneous statement elements, expression terms, built-in functions, pseudo variable identifiers, binary operators, unary operators,  and miscellaneous expression items.  The reserved words and symbols are defined in the basic.hhf header file in a \i mkRWstrs\i0  macro invocation.  The following are some sample lines from this macro invocation:\par
\par
\pard\li360\qj\f1 LEtkn,\tab\tab\tab "<=",\tab\tab\tab @\{0,1\},\tab exprOperator_c,\par
LPARENtkn,\tab\tab "(",\tab\tab\tab @\{1\},\tab\tab exprTerm_c,\par
RPARENtkn,\tab\tab ")",\tab\tab\tab @\{0\},\tab\tab exprMisc_c,\par
SEMICOLONtkn,\tab\tab ";",\tab\tab\tab @\{1\},\tab\tab stmtMisc_c,\par
COLORtkn,\tab\tab "color",\tab\tab @\{1\},\tab\tab stmt_c,\par
SINftkn,\tab\tab\tab "sin",\tab\tab @\{\},\tab\tab exprFunc_c, TIMEZONEtkn,\tab\tab "@timeZone",\tab @\{\},\tab\tab exprVar_c,\par
NOTtkn,\tab\tab\tab "not",\tab\tab @\{0,1\},\tab exprUnaryOp_c,\par
\par
\pard\fi360\li360\qj\f0 The first field in each record (line) is an identifier that the HLA Basic compiler, decompiler, and interpreter will use to identify the byte code associated with the lexical item.  By convention, all these identifiers end with the character sequence \ldblquote tkn\rdblquote  (for \ldblquote token\rdblquote ).  The built-in functions (type: exprFunc_c) generally have token names that end with \ldblquote ftkn\rdblquote  (for \ldblquote function token\rdblquote ).  These suffix names aren\rquote t mandatory, you can use anything you want for your own token names, but their use will make reading the source code for the Basic compiler, interpreter, and decompiler much easier.\par
\par
The second field of each line is a string that specifies the actual string that corresponds to the reserved word or symbol.  For items that look like identifiers (e.g., \ldblquote color\rdblquote  or \ldblquote sin\rdblquote  above), the current compiler requires the reserved word to be surrounded by non-alphanumeric characters. That is, the compiler will not match the first three characters of \i single\i0  as the reserved word \i sin\i0  (because of the use of the \i pat.matchiWord\i0  function to match reserved words like \i color\i0  as the earlier examples demonstrate).\par
\par
The third field is used only by the decompiler. It determines whether there will be spaces before or after the lexical item when detokenizing the program.  @\{\} means that there will be no spaces around the lexical item when it is decompiled. @\{0\} means there will be one space before, but no spaces after the decompiled item. @\{1\} means there will be a space after the item, but none before it.  Finally, @\{0,1\} means that there will be a space before and after the decompiled item.\par
\par
The last field on each line in the macro invocation is the lexical item\rquote s type. This is one of the eight values: \tab  \i stmt_c, stmtMisc_c, exprTerm_c, exprFunc_c, exprVar_c, exprOperator_c, exprUnaryOp_c,\i0  or \i exprMisc\i0 _c.  If you are creating a new statement, you\rquote ll probably want to give it the \i stmt_c\i0  type; if you are creating a new custom pseudo variable, you\rquote ll want to assign the \i exprVar_c\i0  type to it; if you are creating a new built-in function, you\rquote ll probably give that item the \i exprFunc_c\i0  type.  Generally, you won\rquote t use the other types in most extensions to the HLA Basic language; if you really want to create a new operator or other miscellaneous object, see the HLA Basic compiler source code for more details.\par
\par
To extend the HLA Basic language, you would add new records (lines) to the \i mkRWstrs\i0  macro invocation in the basic.hhf header file. Generally, you would add these new lexical items at the end of the existing list (i.e., after the \i TIMEZONEtkn\i0  record and before the \i numBasicTokens\i0  record).  The easiest way to add a new record is to find some record that is similar to the one you want to create, cut & paste the record, and then change the token constant name and the string (the first two fields).\par
\par
Once you\rquote ve added a new entry to the \i mkRWstrs\i0  macro invocation, the next step is to update the Basic compiler, decompiler, and interpreter source files to handle the new object. The following sections in this document describe how to do this.\par
\par
Note: because the HLA Basic compiler encodes all lexical objects using a single byte (hence the name \i byte code\i0 ), an HLA Basic program supports a maximum of 256 different lexical objects.  Standard HLA Basic defines about 100 different lexical items, so you can add up to about 150 of them when customizing the HLA Basic language.\par
\par
This section is far too small to describe all the things that are possible with the HLA stdlib pattern matching functions, please see the HLA stdlib documentation for more details. However, this section should be sufficient to provide a brief preview of how this is accomplished so that the following sections make more sense.\par
\par
\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1144\b\f7  \f0\fs28 Adding New Pseudo Variables to HLA Basic\par
\pard\fi360\li360\qj\b0\fs20\par
There are two ways to add pseudo-variables to HLA Basic: the easy way and the customized (but hard) way.  The easy method requires adding only a single line to the siteSpecific.hhf header file for each pseudo-variable you want to create. This mechanism is great if you simply want to create some global variables that are accessible from different HLA Basic modules and from within the underlying HLA application. Such pseudo-variables are simply variables in the HLA (assembly language) code and reading or writing such pseudo-variables reads or writes the values of the corresponding assembly language variables.\par
\par
You can also create customized pseudo-variables whose access is completely controlled by (assembly language) code that you write. Such pseudo-variable accesses don\rquote t have to simply reference a value of an HLA assembly language variable; instead, reading such a variable could cause the invocation of a function you\rquote ve written that computes the value of the pseudo-variable (in which case, accessing such a pseudo-variable in an expression would correspond to a function call to compute the new value). Storing a value into a customized pseudo-variable can also invoke a function that processes the value prior to using it in whatever manner you want. For example, you could define an @input pseudo-variable that actually reads data from some file whenever you access @input within an expression and writing to that pseudo-variable could write data to some output file.  \par
\par
Adding a global variable-type pseudo-variable to HLA Basic is very easy.  Just edit the siteSpecific.hhf header file and search for the macro symbol declaration \ldblquote siteSpecificPseudoVars\rdblquote . The body of this macro is a list of HLA of pvrect_t constants that provide a way to define pseudo-variables in your program.  Consider the definition of the \ldblquote @timeZone\rdblquote  pseudo-variable (from basic.hhf):\par
\par
\f1 pvrec_t:[ "timeZone", 0, 0, "int32" ]\par
\f0\par
The first entry in this record constant is a string that specifies the name of the pseudo-variable you want to create. When you compile this entry, HLA will generate a set of objects based upon the string you provide (e.g., \ldblquote timeZone\rdblquote  in this case). HLA will create a pseudo-variable in the Basic language by prepending an \ldblquote @\rdblquote  to this string. In the example above, HLA creates the \ldblquote @timeZone\rdblquote  pseudo-variable.  HLA will also create a global static variable in the HLA assembly file that uses the same name as the string you specify as the first argument; HLA will also export this name for use by other HLA assembly language modules.\par
\par
The last entry in the record constant is a string constant that specifies the HLA (assembly language) data type for the object.  This must be one of the following HLA data types:\par
\par
\pard\fi-360\li2160\qj\f1\fs24 o\tab\f0\fs20 real64\par
\f1\fs24 o\tab\f0\fs20 real32\par
\f1\fs24 o\tab\f0\fs20 dword\par
\f1\fs24 o\tab\f0\fs20 int32\par
\f1\fs24 o\tab\f0\fs20 uns32\par
\f1\fs24 o\tab\f0\fs20 word\par
\f1\fs24 o\tab\f0\fs20 int16\par
\f1\fs24 o\tab\f0\fs20 uns16\par
\f1\fs24 o\tab\f0\fs20 byte\par
\f1\fs24 o\tab\f0\fs20 int8\par
\f1\fs24 o\tab\f0\fs20 uns8\par
\f1\fs24 o\tab\f0\fs20 Boolean\par
\f1\fs24 o\tab\f0\fs20 char\par
\f1\fs24 o\tab\f0\fs20 string\par
\pard\fi360\li360\qj\par
When writing a value to a pseudo-variable, the run-time type of the value being assigned must be coercible to the pseudo-variable\rquote s type or a run-time error will result. When accessing a pseudo-variable, floating-point (real) values are always converted to real64, character and string objects are converted to string, and everything else is converted to an integer.\par
\par
The second entry in the record constant above is the number of array elements associated with this pseudo-variable. If the value of this field is zero or one, then HLA will create a scalar (non-array) pseudo-variable. In the example above, @timeZone is a scalar (rather than an array) object because the second field\rquote s value is zero. Consider the following definition in the TRIGA Basic variant of HLA Basic:\par
\par
\f1 pvrec_t:[ "ain", \tab 256, \tab 65535, "word" ]\par
\f0\par
This particular definition creates an array of 256 pseudo-variable objects having indexes 0..255.  In HLA Basic, you\rquote d access elements of this array using the \ldblquote @ain(expr)\rdblquote  syntax, where \ldblquote expr\rdblquote  is some integer-compatible expression that evaluates to some numeric quantity in the range 0..255.  HLA Basic checks the value of the expression at run-time to ensure that it lies within the specified range. A run-time error occurs if you attempt to access an array element using an index that is out of range.\par
\par
\b Important note\b0 : HLA Basic string pseudo-variables are always allocated on the heap (or contain NULL if nothing has never been assigned to the pseudo-variable string object). If you wish to change the value of a string pseudo-variable in your HLA program, you should first free the existing string (if it contains a non-NULL value), allocate the storage for the new string object on the heap.\par
\par
The third field of the pvrec_t record constant is a maximum value for integer pseudo-variable assignments. If this field is non-zero, then HLA Basic will compare the value you assign to the pseudo-variable to ensure that it is less than or equal to this value.  Note that HLA Basic does an \i unsigned\i0  comparison when checking this range.  \par
\par
The existing siteSpecific.hhf header file contains some sample code for the TRIGA Basic language that defines many pseudo-variables (these aren\rquote t compiled into the language unless you define the \ldblquote TrigaBASIC\rdblquote  symbol, so you don\rquote t have to worry about them \ldblquote polluting your namespace\rdblquote  if you\rquote re not compiling the TrigaBASIC version of the language).  You can use these examples as a guide when creating your own pseudo-variables using the easy method.\par
\par
Once you\rquote ve added a new element to the \b pseudoVars\b0  array in the siteSpecific.hhf header file, all you have to do is recompile the HLA Basic system and all the work is done for you. The HLA Basic compiler automatically recognizes the new pseudo-variables and emits code for accessing them; the decompiler will properly decompile references to the pseudo-variable; and the interpreter module (bx.hla) will automatically provide code to declare the global object and access it.  Nothing could be easier.\par
\par
\par
Adding new customizable pseudo variables (that is, using the flexible rather than easy implementation method) to HLA Basic involves the following steps:\par
\par
\pard\fi-360\li1440\qj\tx1440\f1\fs24 o\tab\f0\fs20 You will need to make a couple of modifications to the basic.hhf header file.  First of all, search for the pvTokens enumeration type declaration and add a new entry to the enumeration list that specifies the token name you want to use for the new pseudo-variable. For example, to implement the \b @color\b0  pseudo-variable described earlier (with a token name of \ldblquote color_tkn\rdblquote ), you would add \ldblquote color_tkn,\rdblquote  between the #endfor and the \b numPVtokens\b0  line in the \b pvTokens\b0  definition:\par
\pard\li1440\qj\par
\f1 type\par
\tab pvTokens\tab :enum \par
\tab\{\par
\tab\tab #for( _i_ := 0 to @elements( pseudoVars )-1 )\par
\tab\tab\par
\tab\tab\tab @text( pseudoVars[_i_].identifier + "_tkn"),\par
\tab\tab\tab\par
\tab\tab #endfor\par
\tab\tab color_tkn,\tab // <<- Added this line\par
\tab\tab numPVtokens\par
\tab\};\par
\f0\par
\pard\fi-360\li1440\qj\tx1440\f1\fs24 o\tab\f0\fs20 Next, you will need to modify the PVStrs_c constant array in basic.hhf so the decompiler will be able to properly decompile this pseudo-variable. The PVStrs_c array contains the strings corresponding to the HLA Basic reserved words. So if you are implementing the \b @color\b0  reserved word you would want to add the string \ldblquote @color\rdblquote  to this array. Add any new items after the #endfor statement in this declaration:\par
\pard\qj\par
\pard\li1440\qj\f1 const\tab\tab\par
\tab PVStrs_c\tab :string[] :=\par
\tab [\par
\tab\tab #for( _i_ := 0 to @elements( pseudoVars )-1 )\par
\tab\tab\par
\tab\tab\tab "@" + pseudoVars[_i_].identifier,\par
\tab\tab\tab\par
\tab\tab #endfor\par
\tab\tab\ldblquote @color\rdblquote ,\tab\tab // <<- Added this line\par
\tab ];\par
\pard\li360\qj\f0\par
\pard\fi-360\li1440\qj\tx1440\f1\fs24 o\tab\f0\fs20 You will need to modify the compiler to recognize the new pseudo-variable reserved word. This should be done immediate after the compiler checks for all the pseudo-variables created using the easy method. In the bc.hla source file, search for the identifier \b pseudoVars\b0 .  There are two sections of code that reference this, the  first occurrence of this is probably in a #for loop in the MatchID procedure; this #for loop processes all the built-in functions created using the easy method.  After the corresponding #endfor, insert the following code to handle pseudo-variables appearing in an expression:\par
\pard\qj\par
\pard\li1800\f1 elseif( str.ieq( identifier, \ldblquote @color\rdblquote  )) then\par
\par
\tab PutToken( FUNCtkn );\par
\tab PutToken( color_tkn );\par
\par
\tab //  If @color had some arguments (it does not),\par
\tab // you would also add the following code:\par
\tab //\par
\tab // GetParenExpr( 1, 1 );  // 1= # of arguments\par
\par
\tab\tab\tab\par
\pard\qj\par
\f0\par
\pard\fi-360\li1440\qj\tx1440\f1\fs24 o\tab\f0\fs20 You will also need to modify the section of the HLA Basic parser that handles assignments to pseudo-variables. Keep searching for \b pseudoVars\b0  until you find it in the main statement pattern matching procedure (well within the \b ParseStmt\b0  procedure).  You should find this symbol in a #for loop that processes all of the pseudo-variables created with the easy method.  After the corresponding #endfor statement, add the following code to implement an assignment to the \b @color\b0  pseudo-variable:\par
\pard\li1440\qj\par
\f1\tab pat.alternate\par
\tab   \par
\tab\tab // Process an optional "LET" if it appears \par
\pard\fi360\li1800\qj // at the beginning of this statement:\par
\pard\li1440\qj\tab\tab\par
\tab\tab pat.zeroOrMoreWS();\par
\tab\tab pat.zeroOrOnePat;\par
\tab\tab\tab\tab\tab\par
\tab\tab\tab pat.matchiWord( rw(LETtkn3) );\par
\tab\tab   \par
\tab\tab pat.endZeroOrOnePat;\par
\tab\tab pat.zeroOrMoreWS();\par
\par
\tab\tab // Process the \ldblquote @color\rdblquote  reserved word:\par
\par
\tab\tab pat.matchiWord( \ldblquote @color\rdblquote  );\par
\tab\tab PutToken( LETtkn3 );\par
\tab\tab PutToken( color_tkn );\par
\tab\tab\tab\tab\tab\tab\tab\tab\par
\tab\tab // An equals sign must follow the identifier.\par
\par
\tab\tab pat.zeroOrMoreWS();\par
\tab\tab pat.oneChar( '=' );\par
\tab\tab PutToken( EQtkn );\par
\tab\tab pat.zeroOrMoreWS();\par
\tab\tab\tab\tab\tab\tab   \par
\tab\tab\par
\tab\tab // Parse the arithmetic expression following the\par
\tab\tab // "\{let\} <pseudoVar> ="\par
\tab\tab\par
\tab\tab Expression( esi, edi );\par
\tab\tab pat.endStmt();\par
\f0\par
\pard\qj\par
\pard\li1440\qj Pseudo variables can also support an argument list.  For example, you might create a pseudo variable \i @pseudoArray\i0  that expects a single argument that specifies an index into the array.  If your application provides pseudo variable array extensions, you\rquote ll need to explicitly parse the parenthetical expression following the pseudo variable. Fortunately, this is quite easy.  For example, to parse \i @pseudoArray( expression )\i0  you\rquote d use code like the following:\par
\pard\qj\par
\pard\li720\qj\f1\tab\tab   pat.alternate\par
\tab\tab   \par
\tab\tab\tab pat.matchiWord( rw(PSEUDOARRAYtkn) );\par
\tab\tab\tab PutToken( LETtkn3 );\par
\tab\tab\tab PutToken( PSEUDOARRAYtkn);\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab\par
\tab\tab\tab // A parenthetical expression must follow the \par
\tab\tab\tab // "@color" identifier.\par
\par
\tab\tab\tab pat.zeroOrMoreWS();\par
\tab\tab\tab pat.oneChar( '(' );\par
\tab\tab\tab PutToken( LPARENtkn );\par
\tab\tab\tab pat.zeroOrMoreWS();\par
\tab\tab\tab Expression( esi, edi );\par
\tab\tab\tab pat.zeroOrMoreWS();\par
\tab\tab\tab pat.oneChar( ')' );\par
\tab\tab\tab PutToken( RPARENtkn );\par
\par
\tab\tab\tab // An assignment operator must follow the expression\par
\par
\tab\tab\tab pat.zeroOrMoreWS();\par
\tab\tab\tab pat.oneChar( '=' );\par
\tab\tab\tab PutToken( EQtkn );\par
\tab\tab\tab\tab\tab\tab\tab   \par
\tab\tab\tab\par
\tab\tab\tab // Parse the arithmetic expression following the\par
\tab\tab\tab // "\{let\} @pseudoArray( expression ) ="\par
\tab\tab\tab\par
\tab\tab\tab Expression( esi, edi );\par
\tab\tab\tab pat.endStmt();\line\par
\pard\li1440\qj\f0\par
\f1\par
\pard\qj\par
\pard\fi-360\li1440\qj\tx1440 o\tab\f0 Of course, the previous two modifications assume that you want to implement a new pseudo-variable using the exact same syntax as the standard pseudo-variables. When using a custom implementation of pseudo-variables are you not limited to using standard pseudo-variable syntax. If you prefer a different syntax, modify the code above to handle whatever syntax you choose.\par
\pard\li1440\qj\par
\pard\fi-360\li1440\qj\tx1440\f1\fs24 o\tab\f0\fs20 The decompiler automatically handles new pseudo variables without any modification on your part (other than creating the entry in the basic.hhf header file).  Of course, if you design a new syntax for your pseudo-variable\rquote s implementation, the decompiler might not be able to decompile the code in its original form. In that case you would need to modify the decompiler as well. However, keep in mind that the decompiler simply detokenizes the byte code file, so it\rquote s quite possible that it will decompile your new pseudo-variable properly even if you do change the syntax a little.\par
\pard\qj\par
\pard\li1440\qj\par
\pard\fi-360\li1440\qj\tx1440\f1\fs24 o\tab\f0\fs20 Most of the real work involved in creating a pseudo variable is in the Basic interpreter.  The following discussion describes how this is done.\par
\pard\qj\par
\pard\li1440\qj The first step in creating a new pseudo variable to to override the \i pseudoVarExtensions\i0  method in the \i rtPgmClass\i0  data type.  This is only done once for the entire program, not for each pseudo variable you create.  Here\rquote s an example of this:\par
\par
\pard\li1800\qj\f1\fs18 type\par
\tab myRTPgmClass: class inherits( rtPgmClass );\par
\tab\par
\tab\tab override procedure create;\par
\tab\tab override method pseudoVarExtensions;\par
\tab\tab\tab\tab\par
\tab endclass;\par
\tab\par
\tab pMyRTPgmClass\tab :pointer to myRTPgmClass;\par
\tab\par
\tab\par
readonly\par
\tab align( 4 );\par
\tab vmt( myRTPgmClass );\par
\pard\li1440\qj\f0\fs20\par
The overriddent \i pseudoVarExtensions\i0  method has two parameters: \i isRead\i0  (which is true if this is a read operation and false if this is a write operation) and \i ExprStackPtr\i0 .  Furthermore, upon entry the ECX register is pointing at the pseudo variable\rquote s byte code (token). It is the responsibility of the \i pseudoVarExtensions\i0  method to skip over all tokens it processes. In all cases (read or write), the method must skip over the token byte by incrementing ECX by one.\par
\par
For read operations, \i ExprStackPtr\i0  points directly at a \i Variant\i0  typed object that is to receive the value from the pseudo variable.  Here is the definition of the Variant type from the basic.hhf header file:\par
\par
\pard\li2160\qj\tab\par
\pard\li720\qj\tab\f1\fs18 // The value of a HLABasic variable is held within a variable\par
\tab // of the Variant type:\par
\tab\par
\tab Variant: record\par
\tab\par
\tab\tab union\par
\tab\tab\par
\tab\tab\tab a: record\par
\tab\tab\tab\par
\tab\tab\tab\tab elements:\tab uns32;\tab // Number of array elements.\par
\tab\tab\tab\tab array:\tab\tab dword;\tab // Pointer to array data.\par
\tab\tab\tab\tab\par
\tab\tab\tab endrecord;\par
\tab\tab\tab i:int32;\tab\tab // Integer value if Integer_c object.\par
\tab\tab\tab l:dword;\tab\tab // Stmt address if Label_c object.\par
\tab\tab\tab r:real64;\tab\tab // Real value if Real_c object.\par
\tab\tab\tab s:string;\tab\tab // String value if String_c object.\par
\tab\tab\tab\par
\tab\tab endunion;\par
\tab\tab\par
\tab\tab // Symbols current type:\par
\tab\tab\par
\tab\tab DataType\tab :vTypes;\tab // Type of this particular variable.\par
\tab\tab\par
\tab\tab // Lots of code in the Basic interpreter assumes that the\par
\tab\tab // size of the Variant type is a multiple of four. Ensure this.\par
\tab\tab\par
\tab\tab align(4);\tab\tab\tab\par
\tab\tab\par
\tab endrecord;\par
\pard\li1440\qj\f0\fs20\par
Mostly likely, a pseudo variable read operation will return an integer (the \i i\i0  field), a real (the \i r\i0  field), or a string (the \i s\i0  field) value. Pseudo variables never return label objects and probably shouldn\rquote t return array objects (which are only valid in certain contexts and those contexts are not communicated to the \i pseudoVarExtensions\i0  method).  To return a real or integer value for the pseudo variable read operation, simply store the real or integer value into the \i r\i0  or \i i\i0  field (respectively).  To return a string object as the pseudo variable read value, you must first allocate the string value on the heap and then return a pointer to this string in the \i s\i0  field.  The Basic interpreter will deallocate this string storage when it is done using it; therefore, you must not use the value of this string elsewhere in your program. In particular, if the string is already allocated on the heap, but you\rquote re going to continue using that string in your assembly language code (and take responsibility for freeing it yourself), you must make a fresh copy of the string (with \i str.a_cpy\i0 ) before storing the string pointer into the \i s\i0  field of the variant record.  Because the interpreter frees the storage associated with the \i s\i0  field, you must never explicitly free this storage yourself.\par
\par
After you\rquote ve stored away the value in the \i i, r, \i0 or \i s\i0  field, you must provide the data type to the Basic interpreter.  This is done by storing one of the constants \i Integer_c, Real_c,\i0  or \i String_c\i0  into the \i DataType\i0  field of the \i Variant\i0  record.  Note that the Basic.hhf header file defines these constants for you.\par
\par
The Basic.hhf header file provides a text constant, \i varEDI\i0 , that accesses a \i Variant\i0  record pointed at by the EDI register. You can use this constant (after loading EDI with the value of the \i ExprStackPtr\i0  parameter value) to access the item on the top of the interpreter\rquote s evaluation stack.  On return from the \i pseudoVarExtensions\i0  method, when doing a read operation, you must leave EDI pointing at the new top of the evaluation stack. This is done by adding \i @size( Variant )\i0  to the value of EDI (assuming it contains the value of the \i ExprStackPtr\i0  parameter).  The AL register should also contain the data type of the object you leave on the top of the stack.  For example, the typical code that would copy the HLA global variable \i textColorValue\i0  to the top of the evaluation stack would look like this:\par
\par
\pard\qj\f1\fs18\tab\tab\tab\tab mov( textColorValue, eax );\par
\tab\tab\tab\tab mov( eax, varEDI.i );\par
\tab\tab\tab\tab mov( Integer_c, al );\par
\tab\tab\tab\tab mov( al, varEDI.DataType );\par
\tab\tab\tab\tab add( @size( Variant ), edi );\par
\pard\li1440\qj\f0\fs20\par
The example above assumes that you\rquote ve got a simple pseudo variable that has no arguments.  However, it is also quite possible for there to be a set of expressions surrounded by parentheses immediately after the pseudo variable in the source file, for example, \i @pseudoArray(i+j)\i0 . In this case, it is your responsibility to evaluate the expression and use that value in an appropriate manner.  To evaluate an expression, leaving the result on the evaluation stack (without disturbing any other values already on the stack), you\rquote ll need to call the \i this.evalRPN\i0  method.  This method expects two parameters: a pointer to the first token that comprises the expression in the byte code array (i.e., the byte that ECX points at), and a pointer to the top of the evaluation stack (i.e., the value passed in the \i ExprStackPtr\i0  parameter, which is probably in EDI at this point).  On return from \i this.evalRPN\i0 , EDI is pointing at the new top of the evaluation stack (with the previous contents of the stack sitting below the new value).  The top of stack value is a \i Variant\i0  record and the \i DataType\i0  field will tell you the type of the expression sitting on the stack (\i this.evalRPN\i0  also returns the data type of the top of stack element in the AL register).\par
\par
The Basic interpreter provides a convenience function that checks the top of stack value returned by \i this.evalRPN\i0  to ensure it is an integer result: \i this.tosInt\i0 . These function expects three parameters: the top of stack data type, a pointer to the top of the evaluation stack, and an error message. The \i this.tosInt\i0  function which check to see if the item on the top of stack is an integer; if not, it will attempt to convert it to an integer; if it fails, it will raise a \i BasicErrorWithMsg\i0  exception and pass along the error message provided as the third parameter to \i this.tosInt\i0 .  If the top of stack value is already an integer, or if \i this.tosInt\i0  is successful in converting it to an integer, then returns the integer value in the EAX register. It is your responsibility to remove this item from the top of stack before returning back to the interpreter.  Of course, ultimately you need to push the value of the \i @pseudoArray\i0  element back onto the stack, so it\rquote s probably easiest to overwrite the value pushed by \i this.evalRPN\i0  with the value you fetch from the array.  The basic.hhf header file provides a text constant, \i tosEDI\i0 , that lets you access the item just pushed onto the evaluation stack (this is one position below \i varEDI\i0 , in case you\rquote re wondering). You can use this symbol in your HLA code to easily access fields of the \i Variant\i0  record left on the evaluation stack by \i this.evalRPN\i0 .\par
\par
Here is some typical code that would access the pseudo variable array element  \i @pseudoArray(expression)\i0  and leave its value sitting on the top of the evaluation stack:\par
\par
\pard\qj\f1\fs18\tab\tab\tab\par
\pard\li720\qj\tab\tab assert( (type byte [ecx]) = LPARENtkn );\par
\tab\tab add( 1, ecx );\tab\tab\tab\tab\tab // Skip '(' token.\par
\tab\tab this.evalRPN( ecx, edi );\tab\tab\tab\tab // Get index value.\par
\tab\tab assert( (type byte [ecx]) = RPARENtkn );\par
\tab\tab add( 1, ecx );\tab\tab\tab\tab\tab // Skip ')' token.\par
\tab\tab\tab\tab\par
\tab\tab this.tosInt( al,edi,"@pseudoArray requires an integer operand" );\par
\tab\tab mov( eax, index );\tab\tab\tab\tab\tab // Save index\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab\tab\tab\tab\tab\par
\tab\tab // Grab pseudoArray[index] and leave its value on the stack.\par
\tab\tab // (Reuse the value pushed on the stack by evalRPN.)\par
\tab\tab\tab\tab\par
\tab\tab movzx( pseudoArray[ eax*4 ], eax );\par
\tab\tab mov( eax, tosEDI.i );\par
\tab\tab mov( Integer_c, al );\par
\tab\tab mov( al, tosEDI.DataType );\par
\pard\qj\par
\pard\li1440\qj\f0\fs20\par
If the value of the \i isRead\i0  parameter to \i pseudoVarExtensions\i0  contains false, then the Basic program is executing a statement of the form:\par
\par
\f1 pseudoVar = expression\par
\f0\par
The Basic interpreter calls the \i pseudoVarExtensions\i0  method immediately after encountering the pseudo variable token at the beginning of the assignment statement. The \i pseudoVarExtensions\i0  method is responsible for parsing and processing the rest of the statement, including the assignment operator (\ldblquote =\rdblquote ) and the expression that follows the assignment operator.  Upon entry into the method, the ECX register points at the first token following the pseudo variable token, the code must skip over the assignment operator token, process the following expressions (via a call to \i this.evalExpr\i0 ), and store the result into the corresponding HLA object.\par
\par
The \i this.evalExpr\i0  method differs from \i this.evalRPN\i0  in two respects: first, it always clears the evaluation stack before evaluating the expression pointed at by ECX. Second, on return the result it always at the bottom of the evaluation stack (though EDI still points at this, so the code you write could look like the code following a \i this.evalRPN\i0  call). The important thing to note is that you can only call \i this.evalExpr\i0  to process an expression to the right of an assignment operator; you must not use \i this.exprEval\i0  to process some sub-expression in the middle of an arithmetic expression (such as an array index).\par
\par
Here\rquote s the code you might use to assign the value of an integer expression to an integer-typed pseudo variable (e.g., \i @color\i0 ):\par
\par
\pard\li1080\qj\fs18\tab\tab\f1 add( 1, ecx );\tab\tab\tab // Skip '=' token\par
\tab\tab this.evalExpr( ecx );\tab\tab // Get value.\par
\tab\tab this.makeInt( al, "Must assign an integer value to @color" );\par
\tab\tab\tab\tab\par
\tab\tab // EAX has the value to assign to @color.\par
\tab\tab\tab\tab\par
\tab\tab mov( eax, textColorValue);\par
\pard\li1440\qj\f0\fs20\par
The \i this.makeInt\i0  function is similar to \i this.tosInt\i0  except it assumes that the value was produced by \i this.evalExpr\i0  and is sitting on the bottom of the evaluation stack (note that you don\rquote t pass a pointer to the top of the evaluation stack to \i this.makeInt\i0 ).  This is also a \i this.makeReal\i0  function that is called in an almost identical fashion to check the return result to see if it is a floating-point value (or can be converted to a floating-point value). The \i this.makeReal\i0  function leaves its real result sitting on the floating-point stack (ST0) upon return.   Note that, unlike \i this.tosInt\i0 , you do not have to do anything to the evaluation stack upon return from \i this.evalExpr\i0 .  This is because the interpreter is done with the evaluation stack (for the current statement, at least).\par
\par
Here is the code that handles the write operation for the \i @pseudoArray( expression )\i0  pseudo variable access:\par
\par
\pard\li720\qj\tab\f1\fs18 add( 1, ecx );\tab\tab\tab\tab // Skip '(' token.\par
\tab this.evalExpr( ecx );\tab\tab\tab // Get index value.\par
\tab assert( (type byte [ecx]) = RPARENtkn );\par
\tab add( 2, ecx );\tab\tab\tab\tab // Skip ')' and '=' tokens.\par
\par
\tab this.makeInt( al, "@pseudoArray requires an integer operand" );\par
\tab mov( eax, index );\tab\tab\tab // Save index\par
\tab\tab\tab\tab\par
\tab this.evalExpr( ecx );\tab\tab // Get expression value.\par
\tab this.makeInt( al, "Must assign an integer value to @pseudoArray" );\par
\tab\tab\tab\tab\par
\tab // EAX has the value to assign to pseudoArray(index).\par
\tab\tab\tab\tab\par
\tab mov( index, edx );\par
\tab mov( ax, pseudoArray[edx*4] );\par
\pard\qj\par
\pard\li1440\qj\f0\fs20\par
If \i this.evalExpr\i0  (or \i this.tosInt\i0 , for that matter) returns a string object, the system has allocated storage for that string on the heap and it is your responsibility to free the storage associated with that string when you are done using (via a call to \i str.free\i0 ).  It wouldn\rquote t be very hard for you to write your own version of this function if you need it (see the source code for \i this.makeReal\i0  and \i this.makeInt\i0  in bx.hla for details).\par
\par
To recap, the \i pseudoVarExtensions\i0  method takes the following form (assuming we\rquote re handling the \i @color\i0  and \i @pseudoArray\i0  pseudo variables of the past examples):\par
\par
\par
\pard\f1\fs18 method myRTPgmClass.pseudoVarExtensions\par
( \par
\tab isRead:boolean;\par
\tab ExprStackPtr:dword\par
);\par
var\par
\tab token\tab\tab :dword;\par
\tab index\tab\tab :dword;\par
\tab\par
begin pseudoVarExtensions;\par
\par
\par
\tab push( ebx );\par
\tab movzx( (type byte [ecx]), eax );\tab // Get pseudo variable token\par
\tab add( 1, ecx );\tab\tab\tab // Skip pseudo-var token\par
\tab mov( eax, token );\tab\tab\tab // Save for later use\tab\tab\par
\tab if( isRead ) then\par
\par
\tab\tab switch( eax )\par
\par
\tab\tab\tab case( TEXTCOLORtkn )\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab // Grab the HLA textColorValue variable and \par
\tab\tab\tab\tab // leave its value on the stack:\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab mov( textColorValue, eax );\par
\tab\tab\tab\tab mov( eax, varEDI.i );\par
\tab\tab\tab\tab mov( Integer_c, al );\par
\tab\tab\tab\tab mov( al, varEDI.DataType );\par
\tab\tab\tab\tab add( @size( Variant ), edi );\par
\fs20\par
\fs18\tab\tab\tab\par
\tab\tab\tab case( PSEUDOARRAYtkn )\par
\par
\tab\tab\tab\tab assert( (type byte [ecx]) = LPARENtkn );\par
\tab\tab\tab\tab add( 1, ecx );\tab\tab // Skip '(' token.\par
\tab\tab\tab\tab this.evalRPN( ecx, edi );\tab // Get index value.\par
\tab\tab\tab\tab assert( (type byte [ecx]) = RPARENtkn );\par
\tab\tab\tab\tab add( 1, ecx );\tab\tab // Skip ')' token.\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab this.tosInt\par
\tab\tab\tab\tab ( \par
\tab\tab\tab\tab\tab al, \par
\tab\tab\tab\tab\tab edi, \par
\tab\tab\tab\tab\tab "pseudoArray requires an integer operand" \line\tab\tab\tab\tab );\par
\tab\tab\tab\tab\tab\tab\tab\tab\par
\tab\tab\tab\tab // Grab @pseudoArray[index] and leave its value \par
\tab\tab\tab\tab // on the stack (Reuse the value pushed on the \par
\tab\tab\tab\tab // stack by evalRPN.)\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab movzx( pseudoArray[ eax*4 ], eax );\par
\tab\tab\tab\tab mov( eax, tosEDI.i );\par
\tab\tab\tab\tab mov( Integer_c, al );\par
\tab\tab\tab\tab mov( al, tosEDI.DataType );\par
\par
\par
\tab\tab\tab // Cases that handle read access to other\par
\tab\tab\tab // pseudo variables would go here\par
\par
\tab\tab\tab default\par
\tab\tab\tab\par
\tab\tab\tab\tab str.put\par
\tab\tab\tab\tab (\par
\tab\tab\tab\tab\tab this.exceptionMsg,\par
\tab\tab\tab\tab\tab "Unexpected pseudo-variable token = $",\par
\tab\tab\tab\tab\tab al\tab\tab\tab\tab\tab\par
\tab\tab\tab\tab );\par
\tab\tab\tab\tab raise( BasicErrorWithMsg );\par
\par
\tab\tab endswitch;\par
\par
\tab else // This is a pseudo variable write operation\par
\par
\tab\tab switch( eax )\par
\par
\tab\tab\tab case( TEXTCOLORtkn )\par
\tab\tab\tab\par
\tab\tab\tab\tab add( 1, ecx );\tab\tab\tab // Skip '=' token\par
\tab\tab\tab\tab this.evalExpr( ecx );\tab\tab // Get value.\par
\tab\tab\tab\tab this.makeInt\par
\tab\tab\tab\tab (\par
\tab\tab\tab\tab\tab al, \par
\tab\tab\tab\tab\tab "Must assign an integer value to @color" \par
\tab\tab\tab\tab );\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab // EAX has the value to assign to textColorValue.\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab mov( eax, textColorValue );\par
\par
\par
\tab\tab\tab case( PSEUDOARRAYtkn )\par
\par
\f0\fs20\tab\tab\tab\tab\f1\fs18 add( 1, ecx );\par
\tab\tab\tab\tab this.evalExpr( ecx );\par
\tab\tab\tab\tab assert( (type byte [ecx]) = RPARENtkn );\par
\tab\tab\tab\tab add( 2, ecx );\par
\par
\tab\tab\tab\tab this.makeInt\par
\tab\tab\tab\tab ( \par
\tab\tab\tab\tab\tab al, \par
\tab\tab\tab\tab\tab "@pseudoArray requires an integer operand" \par
\tab\tab\tab\tab );\par
\tab\tab\tab\tab mov( eax, index );\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab this.evalExpr( ecx );\par
\tab\tab\tab\tab this.makeInt\par
\tab\tab\tab\tab ( \par
\tab\tab\tab\tab\tab al, \par
\tab\tab\tab\tab\tab "Must assign an integer value to @pseudoArray"\par
\tab\tab\tab\tab );\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab // EAX has the value to assign to pseudoArray(index).\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab mov( index, edx );\par
\tab\tab\tab\tab mov( ax, pseudoArray[edx*4] );\par
\par
\par
\par
\tab\tab\tab // << Cases that handle write access to \par
\tab\tab\tab // \tab other pseudo variables >>\par
\par
\tab\tab\tab default\par
\tab\tab\tab\par
\tab\tab\tab\tab str.put\par
\tab\tab\tab\tab (\par
\tab\tab\tab\tab\tab this.exceptionMsg,\par
\tab\tab\tab\tab\tab "Unexpected pseudo-variable token = $",\par
\tab\tab\tab\tab\tab al\tab\tab\tab\tab\tab\par
\tab\tab\tab\tab );\par
\tab\tab\tab\tab raise( BasicErrorWithMsg );\par
\par
\tab\tab endswitch;\par
\par
\tab endif;\par
\tab pop( ebx );\par
\par
end pseudoVarExtensions;\par
\pard\li1440\qj\f0\fs20\par
\par
 \par
\pard\fi360\li360\qj Although all of the examples in this section have labored under the assumption that a pseudo variable in an HLA Basic code snippet corresponds to a global variable in an HLA assembly language program, this certainly doesn\rquote t have to be the case.  You can write arbitrary code that does whatever you want when an HLA Basic program accesses a pseudo variable.  Generally, it\rquote s best if you do simulate a global variable with your pseudo variable objects \endash  those are the semantics people expect \endash  but if you have a good reason to do something else and adding a new Basic statement isn\rquote t the right approach, feel free to do whatever you like.\par
\par
The primary intent of pseudo variables is to allow two or more HLA Basic programs to communicate data between themselves and to allow an HLA Basic program to communicate data between itself and the underlying HLA assembly language application. In general, it\rquote s best if you stick to this paradigm when implementing pseudo variables.\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1144\b\f7  \f0\fs28 Adding New Functions to HLA Basic\par
\pard\fi360\li360\qj\b0\fs20\par
HLA Basic provides a plethora of built-in mathematical and string functions. Nevertheless, you may want to add new built-in functions to the language.  Adding a new built-in function to the HLA Basic language is almost like adding a new pseudo variable except you don\rquote t have to deal with assigning a value to the function.\par
\par
As for pseudo variables, when you want to add a new built-in function to HLA Basic there are two approaches: the easy way and the more flexible (but more difficult) way. With the easy way, you simply add one line to the siteSpecific.hhf header file and supply code to implement the new function.  The advanced approach (which shouldn\rquote t be necessary in most cases) requires you to make modifications to three separate programs: the compiler, the decompiler/detokenizer, and the interpreter.\par
\par
First, let\rquote s explore the easy way. Most functions you\rquote ll want to add to HLA Basic can be implemented by adding a single line to the siteSpecific.hhf header file and then writing the code to implement that function.  The \b siteSpecificFunctions\b0  macro contains a sequence of \b frec_t\b0  record entries that will add new function names to the system.  The \b frec_t\b0  record is defined thusly:\par
\par
\f1\fs18\tab\tab\tab\tab\par
\tab frec_t\tab :record\par
\tab\tab\par
\tab\tab identifier\tab :string;\par
\tab\tab minParms\tab\tab :uns32;\par
\tab\tab maxParms\tab\tab :uns32;\par
\par
\tab endrecord;\par
\tab\tab\tab\tab\tab\par
\f0\fs20 The \b identifier\b0  field specifies the (case-insensitive) name of the function.  This will be a reserved word in the new version of the HLA Basic language you are creating.  The \b minParms\b0  and \b maxParms\b0  fields specify the minimum and maximum number of arguments the function allows, respectively. If the function has no arguments, both of these values should be zero; if the function has a fixed number of arguments (i.e.,  it doesn\rquote t have a variable number of parameters), then both of these values should be the same. For example, if you wanted to add a case insensitive string comparison to HLA Basic, you might define \b siteSpecificFunctions\b0  thusly:\par
\par
\f1\fs18\tab\tab #macro siteSpecificFunctions;\par
\tab\tab\par
\tab\tab\tab frec_t:[ "stricmp",  2, 2 ],\par
\tab\tab\par
\tab\tab #endmacro\par
\par
\f0\fs20 When you build the system (that is, compile the compiler, decompiler, and interpreter), the code will automatically modify the compiler to handle your new function (along with the code to parse the argument list), it will modify the decompiler  to automatically disassemble your function, and it will modify the interpreter to call a function with the name you\rquote ve supplied along with a \ldblquote _f\rdblquote  suffix (e.g., for \ldblquote stricmp\rdblquote  above, the system will call the function \b stricmp_f\b0  at run-time). Of course, there is no way for the system to automatically write that function for you, so you will have to supply that function yourself.\par
\par
Whenever the run-time system calls a procedure to handle a user-defined function (e.g., \b stricmp_f\b0 ),  the environment upon entry is the following:\par
\par
\pard\fi-360\li1440\qj\f8\fs24\'b7\tab\f0\fs20 On entry, ECX points at the token stream. In particular, it points at the second byte of the built-in function token sequence (built-in function tokens are two bytes long, a lead-in byte that specifies a built-in function and a second byte that selects one of up to 256 different built-in functions).  The run-time system has used that second byte to determine which function to call (e.g., \b stricmp_f\b0 ), so that value is of little use to you.\par
\f8\fs24\'b7\tab\f0\fs20 On entry, ESI points at an object of type \b rtPgmClass\b0 . You will need to use this pointer (with \ldblquote (type rtPgmClass [esi])\rdblquote  coercion) in order to access interpreter functions that process identifiers, evaluate expressions, and so on.\par
\f8\fs24\'b7\tab\f0\fs20 On entry, EDI points at the top of the evaluation stack. Specifically, it points at the last entry left on the stack.\par
\pard\li720\qj\par
\pard\fi360\li360\qj Upon exit, you must leave ECX pointing at the next byte beyond the function\rquote s tokens and any arguments you process during the evaluation of that function.  For example, given a function call of the form \b stricmp( strVar1, \ldblquote hello\rdblquote  )\b0 , you would want to leave ECX pointing at the first token beyond the closing \ldblquote )\rdblquote  symbol.  You must also leave EDI pointing at the top of the evaluation stack when you return from the function. AL must contain the type of the function result that you leave on the evaluation stack (it should have one of the values \b Integer_c, Real_c\b0 , or \b String_c\b0 ). EDX is a scratchpad register and you can use it as you see fit. All other registers must be unmodified.\par
\pard\li720\qj\par
\pard\fi360\li360\qj At the very least, you will need to advance ECX beyond the second byte of the function\rquote s token, so each function will typically begin with at least an \b inc(ecx); \b0 instruction.  If your function has one or more arguments, you will also need to skip the opening parenthesis token the immediately follows the function token. Because the compiler has already parsed the function, we know that the parenthesis is there; you can check (perhaps with an assert) if you\rquote re paranoid, but generally an instruction of the form \b add( 2, ecx );\b0  (rather than the \b inc\b0  instruction) would begin a function\rquote s code when the function has arguments.\par
\par
A procedure that implements a built-in function must leave the function result sitting on the top of the evaluation stack when the function returns. Typically, you will need to push the function result onto the stack. This is done by adding \b @size(Variant)\b0  to EDI and storing the result data at address\b  (type Variant [edi])\b0 , note that the basic.hhf header file defines a text constant \b tosEDI\b0  that is set to \ldblquote (type Variant [edi])\rdblquote  so you may refer to the values on the top of the evaluation stack using \b tosEDI\b0 .\par
\par
If your function has any arguments, you should skip past the first \ldblquote (\ldblquote  token (mentioned above) and call \b (type rtPgmClass [esi]).evalRPN( ecx, edi );\b0  in order to evaluate each argument expression. Each call to \b evalRPN\b0  pushes the evaluated result onto the top of the evaluation stack and returns the type in the AL register (this will be \b String_c, Integer_c\b0 , or \b Real_c\b0  for legal expressions).  You must pop each evaluated result off the stack before returning from your procedure (and before pushing your function\rquote s return result onto the evaluation stack).\par
\par
There is a shortcut you can use if your function has one or more arguments; this is especially efficient if you have only a single argument \endash  rather than popping all the arguments and then pushing the function result into the evaluation stack, simply pop all but one of the arguments off the stack and replace that argument\rquote s value with the function return result.  For example, consider the code for the built-in function ASC:\par
\par
\f1\fs18 // ASC( s ) -- ASCII function.\par
//\par
// ASC function returns the ASCII code of the first\par
// character of its string parameter (zero if the\par
// string is empty).\par
\par
procedure asc_f; @noframe;\par
begin asc_f;\par
\par
  \tab add( 2, ecx );\tab\tab\tab\tab // Skip the ASC and '(' tokens.\par
\tab (type rtPgmClass [esi]).evalRPN( ecx, edi );\tab // Evaluate expression.\par
\tab\par
\tab if( al <> String_c ) then\par
\tab\par
\tab\tab str.put\par
\tab\tab ( \par
\tab\tab\tab (type rtPgmClass [esi]).exceptionMsg, \par
\tab\tab\tab "Expected a string expression in ASC call" \par
\tab\tab );\par
\tab\tab raise( BasicErrorWithMsg );\par
\tab\tab\par
\tab endif;\par
\tab inc( ecx ); \tab\tab\tab // Skip closing the ')'.\par
\tab xor( edx, edx );\par
\tab mov( tosEDI.s, eax );\par
\tab mov( [eax], dl );\tab // Get character code for first character.\par
\tab str.free( eax );\tab\tab // Free the string data associated with the parm.\par
\tab mov( edx, tosEDI.i );\par
\tab mov( Integer_c, al );\par
\tab mov( al, tosEDI.DataType );\par
\tab ret();\par
\tab\par
end asc_f;\par
\f0\fs20\par
\par
This implementation of \b ASC\b0  demonstrates another couple of important things. First of all, if any of the arguments of your function are of type \b String_c\b0  (string data), you must free the storage associated with that string\rquote s data. Otherwise you will end up with a huge memory leak over time.  The second thing that \b ASC\b0  demonstrates is how to raise an exception and display an appropriate error message.  To do this, you must copy the text of your error message to the string variable pointed at by \b (type rtPgmClass [esi]).exceptionMsg\b0  (limit of 256 characters) and then raise the \b BasicErrorWithMessage\b0  exception.\par
\par
When you leave a function return result on the evaluation stack, you must also specify the type of that value by storing \b Integer_c, Real_c, \b0 or\b  String_c\b0  into the DataType field of the top of stack element (i.e., \b tosEDI.DataType\b0 ). You must also return this data type value in the AL register.\par
\par
Consider the following possible implementation of the \b stricmp\b0  function:\par
\par
\f1\fs18 // stricmp( s1, s2 ) \endash  String insensitive comparison\par
//\par
// Compares s1 to s2.  Returns 0 if s1 <> s2\par
// and 1 if s1 = s2.\par
\par
procedure stricmp_f; @noframe;\par
begin stricmp_f;\par
\par
  \tab add( 2, ecx );\tab\tab\tab\tab // Skip the stricmp and '(' tokens.\par
\tab (type rtPgmClass [esi]).evalRPN( ecx, edi );\tab // Evaluate s1.\par
\tab\par
\tab if( al <> String_c ) then\par
\tab\par
\tab\tab str.put\par
\tab\tab ( \par
\tab\tab\tab (type rtPgmClass [esi]).exceptionMsg, \par
\tab\tab\tab "Expected a string expression in stricmp call (arg 1)" \par
\tab\tab );\par
\tab\tab raise( BasicErrorWithMsg );\par
\tab\tab\par
\tab endif;\par
\par
\tab (type rtPgmClass [esi]).evalRPN( ecx, edi );\tab // Evaluate s2.\par
\tab\par
\tab if( al <> String_c ) then\par
\tab\par
\tab\tab str.put\par
\tab\tab ( \par
\tab\tab\tab (type rtPgmClass [esi]).exceptionMsg, \par
\tab\tab\tab "Expected a string expression in stricmp call (arg 2)" \par
\tab\tab );\par
\tab\tab raise( BasicErrorWithMsg );\par
\tab\tab\par
\tab endif;\par
\par
\tab // Okay, s1 is at nosEDI and s2 is at tosEDI. Do a case insensitive\par
\tab // comparison.\par
\par
\tab str.ieq( tosEDI.s, nosEDI.s );\par
\tab str.free( tosEDI.s );\tab\tab\tab\tab // Free the string storage\par
\tab str.free( nosEDI.s );\tab\tab\tab\tab //  associated with the two args.\par
\tab sub( @size( Variant ), edi );\tab\tab // Pop one item off the stack.\par
\par
\tab mov( eax, tosEDI.i );\tab\tab\tab\tab // Save str.ieq result as function\par
\tab mov( Integer_c, al );\tab\tab\tab\tab //  return value.\par
\tab mov( al, tosEDI.DataType );\par
\par
\tab inc( ecx );\tab\tab\tab\tab\tab\tab\tab // Skip trailing \lquote )\rquote\par
\tab ret();\par
\tab\par
end stricmp_f;\par
\f0\fs20\par
Note that all of the standard HLA Basic built-in functions are implemented using this easy method. For more examples of how to write a procedure to implement your own built-in functions using the easy method, check out the source code for the functions in the bx.hla source file. Search for \ldblquote abs_f\rdblquote  to get started.\par
\par
The easy way of adding new functions to the HLA Basic language will probably cover almost all of the functions you will ever want to add. There are a couple of situations where the simplified method won\rquote t work.  If you want to force an argument to be passed by reference (that is, identifier only rather than a general expression) or if you want to modify the syntax of the function call, then you will have to manually modify the system to support your function call.\par
The modification to the compiler is relatively straight-forward. Search for the \ldblquote matched\rdblquote  procedure in the bc.hla source file.  This is the function that processes all built-in function and other identifiers that can appear in expressions in an HLA Basic program.  The body of this function is a huge if..elseif..elseif\'85 chain that compares the string found in the (local) variable \i identifier\i0  against all the built-in function names.  Built-in functions take one of two forms: no parameters, or a list of one or more arguments surrounded by parentheses.  \par
\par
If your new function has no parameters, all you need to do is emit the appropriate token for that function to the byte code stream. For example, consider the built-in \i date\i0  function; here\rquote s its code:\par
\par
\f1\fs18 elseif( str.ieq( identifier, \ldblquote date\rdblquote  )) then\par
\tab\tab\tab\tab\par
\tab PutToken( DATEftkn );\par
\tab\tab\tab\tab\tab\par
\f0\fs20\tab\tab\tab\tab\tab\par
If your new function requires one or more arguments, you can call the \i GetParenExpr\i0  function to process those parameters for you. \i GetParenExpr\i0  requires two arguments: the minimum number of arguments the function requires and the maximum number of arguments it allows.  Most functions will have a fixed number of arguments, so the two parameters you pass to \i GetParenExpr\i0  will have the same value.  However, it is possible to create a function (like \i min\i0  or \i max\i0 ) that allows a variable number of arguments, in which case you\rquote d supply different values to \i GetParenExpr\i0  for the \i minExprs\i0  and \i maxExprs\i0  parameters. Here\rquote s what the code looks like for the HLA Basic \i right\i0  function, that requires exactly two arguments:\par
\par
\f1\fs18 elseif( str.ieq( identifier, \ldblquote right\rdblquote  )) then\par
\tab\tab\tab\tab\par
\tab PutToken( RIGHTftkn );\par
\tab GetParenExpr( 2, 2 );\par
\par
\f0\fs20 Note that the \i GetParenExpr\i0  function automatically emits the byte codes for the expression to the byte code output file. \par
\par
To add a new function to the compiler, all you\rquote ve got to do is to create a new reserved word in the basic.hhf file (see the discussion in pseudo variables for all the details) and then locate the \i matchID\i0  procedure in bc.hla and insert a code sequence like one of the above into the if..elseif chain.\par
\par
As for pseudo variables, the decompiler/detokenizer automatically handles the decompilation of new built-in functions. So as long as you\rquote ve added your new reserved word (for the function name) to the basic.hhf header file, a simple recompilation of the bd.hla file will automatically handle your new built-in function.\par
\par
To add the new function in the interpreter, you first overload the \i functionExtensions\i0  method in the \i myRTPgmClass\i0  object. Here\rquote s a template for the \i functionExtensions\i0  method:\par
\par
\f1\fs18 method myRTPgmClass.functionExtensions( ExprStackPtr:dword );\par
var\par
\tab // Any local variables would go here\par
\tab\par
begin functionExtensions;\par
\par
\tab push( ebx );\par
\tab movzx( (type byte [ecx]), eax );\tab // Get function token\par
\tab add( 1, ecx );\tab\tab\tab // Skip function token\par
\tab mov( ExprStackPtr, edi );\tab\tab // Point EDI at top of eval stack\par
\tab switch( eax )\par
\tab\tab\tab .\par
\tab\tab\tab .\par
\tab\tab\tab .\par
\tab\tab // Cases to handle the new built-in functions\par
\tab\tab\tab .\par
\tab\tab\tab .\par
\tab\tab\tab .\par
\tab   default\par
\tab\tab\par
\tab\tab str.cpy\par
\tab\tab (\par
\tab\tab\tab "Unexpected application-specific function token",\par
\tab\tab\tab this.exceptionMsg\par
\tab\tab );\par
\tab\tab raise( BasicErrorWithMsg );\par
\tab\tab\tab\tab\par
\tab\par
\tab endswitch;\par
\tab pop( ebx );\par
\tab\par
end functionExtensions;\par
\par
\f0\fs20\par
You would add a case to the above switch statement for each new function you want to implement.  You can use the same helper functions described in the section on pseudo-variables to process expressions (e.g., arguments).  When you are done computing your function result, you leave it sitting on the top of the evaluation stack.\par
\par
Note that upon entry, ECX contains a pointer to the byte code associated with the function. It is your responsibility to move ECX past all the tokens you process. On entry, ESI contains a pointer to the interpreter object (which you should preserve). EDI contains the address of the VMT upon entry, it must point at the top of the evaluation stack on exit; note that the single argument \i ExprStackPtr\i0  points at the top of the evaluation stack upon entry into the function. EDX and EAX are scratchpad registers and you can use them as you see fit.  You must preserve EBX in this function.\par
\par
Suppose, for example, that you want to implement a new built-in function that computes \i  arg1^2 + arg2^2 \i0  (that is, the sum of the squares of the function\rquote s two arguments).  Let\rquote s call this function \i sumSqr\i0 .  The first step is to add the reserved word \ldblquote sumSqr\rdblquote  to the HLA Basic language by adding the following entry to the \i mkRWstrs\i0  macro invocation in basic.hhf:\par
\par
\pard\f1\fs18\tab SUMSQRftkn,\tab\tab "sumSqr",\tab\tab @\{\},\tab exprFunc_c,\tab\tab\tab\par
\par
\pard\li360\qj\f0\fs20 Note that built-in functions have the \i exprFunc\i0 _c type associated with them.\par
\pard\fi360\li360\qj\par
The next step is to add an elseif statement to the if..elseif chain in the \i matchID\i0  function in bc.hla.  Because the \i sumSqr\i0  function has exactly two arguments, the code to accomplish this is\par
\par
\pard\f1\fs18\tab elseif( str.ieq( identifier, rw(SUMSQRftkn) )) then\par
\tab\tab\tab\tab\par
\tab\tab PutToken( SUMSQRftkn);\par
\tab\tab GetParenExpr( 2, 2 );\par
\pard\fi360\li360\qj\f0\fs20\par
\par
You will also need to modify the interpreter. For new built-in functions, you extend the functionExtensions method. Do this by overriding the functionExtensions method in the myRTPgmClass object:\par
\par
\pard\li90\qj\f1\fs18 type\par
\tab myRTPgmClass: class inherits( rtPgmClass );\par
\tab\par
\tab\tab override procedure create;\par
\tab\tab override method functionExtensions;\par
\tab\tab\tab\tab\par
\tab endclass;\par
\tab\par
\tab pMyRTPgmClass\tab :pointer to myRTPgmClass;\par
\tab\par
\tab\par
readonly\par
\tab align( 4 );\par
\tab vmt( myRTPgmClass );\par
\pard\fi360\li360\qj\f0\fs20\par
\par
Note that if you are also adding some pseudo variables, your new class declaration will look like the following:\par
\par
\pard\li90\qj\f1\fs18 type\par
\tab myRTPgmClass: class inherits( rtPgmClass );\par
\tab\par
\tab\tab override procedure create;\par
\tab\tab override method pseudoVarExtensions;\par
\tab\tab override method functionExtensions;\par
\tab\tab\tab\tab\par
\tab endclass;\par
\tab\par
\tab pMyRTPgmClass\tab :pointer to myRTPgmClass;\par
\tab\par
\tab\par
readonly\par
\tab align( 4 );\par
\tab vmt( myRTPgmClass );\par
\pard\fi360\li360\qj\f0\fs20\par
Finally, we need to add a case to the switch statement in the \i functionExtensions\i0  procedure.  That code might look like the following:\par
\par
\pard\f1\fs18\tab case( SUMSQRftkn)\par
\par
\tab\tab add( 1, ecx );\tab\tab // Skip \lquote (\lquote  token\par
\par
\tab\tab // Evaluate 1\super st\nosupersub  parameter and leave it on the FPU stack:\par
\par
\tab\tab this.evalRPN( ecx, edi );\par
\tab\tab this.tosInt( al, \ldblquote SUMSQR expects integer parameters\rdblquote  );\par
\par
\tab\tab intmul( eax, eax );\tab\tab // Square it\par
\tab\tab push( eax );\tab\tab\tab // Save it.\line\par
\tab\tab // Skip the \lquote ,\rquote  token\par
\par
\tab\tab add( 1, ecx );\par
\par
 \tab\tab // Evaluate 2nd parameter\par
\par
\tab\tab this.evalRPN( ecx, edi );\par
\tab\tab this.tosInt( al, \ldblquote SUMSQR expects integer parameters\rdblquote  );\par
\par
\par
\tab\tab // Compute the sum of the squares:\par
\par
\tab\tab pop( edx );\par
\tab\tab add( edx, eax );\par
\par
\tab\tab // Remove one of the items pushed on the stack by this.evalRPN:\par
\par
\tab\tab sub( @size( Variant ), edi );\par
\par
\tab\tab // Store the result in the other item pushed on the stack:\par
\par
\tab\tab mov( eax, tosEDI.i );\par
\tab\tab mov( Integer_c, tosEDI.DataType );\par
\tab\tab\tab\tab\par
\pard\fi360\li360\qj\f0\fs20 For more details, consult the source code in bx.hla. Search for the \ldblquote Functions\rdblquote  procedure.\par
\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1144\b\f7  \f0\fs28 Adding New Statements to HLA Basic\par
\pard\fi360\li360\qj\b0\fs20\par
Adding new statements to HLA Basic is a bit more work than adding a pseudo variable or built-in function, but as long as you stick to a command statement format, it\rquote s still pretty easy to add a new statement to the HLA Basic language.\par
\par
As for pseudo-variables and built-in functions, there is an easy way and a more flexible way to add statements to the HLA Basic language. The easy way is suitable for statements that consist of a reserved word followed by a list of zero or more comma-separated identifiers or expressions.  If the statement you want to add to the HLA Basic language fits this constraint, and it is a stand-alone statement (unlike, say, \ldblquote FOR\rdblquote  and \ldblquote NEXT\rdblquote ) then adding a single like to the siteSpecific.hhf header file will automatically generate all the code in the compiler and decompiler; all you will have to supply is the statement-specific code in the interpreter.\par
\par
To create a new statement using the easy method, the first thing you do is to add a line to the \b siteSpecificStmts_c\b0  array in the siteSpecific.hhf header file.  Each element of this array is a value of type \b stmt_t\b0  which has the following definition:\par
\par
\f1\fs18\tab stmt_t\tab :record\par
\tab\par
\tab\tab identifier\tab :string;\par
\tab\tab numArgs\tab\tab :uns32;\par
\tab\tab IDmap\tab\tab :dword;\par
\tab\tab\par
\tab endrecord;\par
\f0\fs20\par
The \b identifier\b0  field is a string that specifies the new reserved word that appears at the beginning of your new statement.  When parsing the statement, the compiler will do a case-insensitive comparison against this string, so the alphabetic case is irrelevant. By convention, \b identifier\b0  strings should contain all lower-case characters (as this leads to slightly faster compilations).  Also, when using the easy method, all identifier strings must be valid HLA assembly language identifiers (that is, identifier must begin with an alphabetic or underscore character and may contain only alphanumeric or underscore characters thereafter).\par
\par
The \b numArgs\b0  field specifies that number of arguments that your statement will have. This may be zero or more, but it is practically limited to 32. Note that, unlike built-in functions, statements you create using the easy method must have a fixed number of arguments. If you want to support a variable number of arguments you will not be able to use the easy method to implement the statement. When using the easy method, all statement arguments must be separated by commas. If you wish to use some other syntax, you will not be able to use the easy method to implement the statement.\par
\par
The \b IDmap\b0  field is a bit array (32 bits) that determines whether each argument (up to 32 arguments) is either a generic expression (bit=0) or must be an identifier (bit=1). Bit #0 of \b IDmap\b0  corresponds to the first argument of the statement, bit #1 of IDmap corresponds to the second argument of the statement, bit #2 of \b IDmap\b0  corresponds to the third argument of the statement, and so on. You would set one of these bits to one when you need to ensure that a statement argument contains \i only\i0  an identifier; this might be necessary, for example, if you want to change the value of that identifier at run-time or if it is an array and you wish to manipulate the entire array (something that is not possible with expressions).  \par
\par
Using the HLA dword bitmap constant syntax (\ldblquote @\{\'85\}\rdblquote ) is probably the easiest way to fill in the \b IDmap\b0  field.  For example,  \b @\{\}\b0  tells the system that all arguments are expressions, \b @\{0\}\b0  tells the system that argument one must be an identifier and all other arguments are expressions, and \b @\{0,2\}\b0  tells the system that arguments one and three must be identifiers and all other arguments are generic expressions.\par
\par
Because HLA constant arrays cannot have zero elements, the \b siteSpecificStmts_c\b0  array must have at least one element. Therefore, the HLA Basic system ignores the last entry in this constant array (which is always a dummy entry). If you look at the default siteSpecific.hhf header file, you\rquote ll discover that the default (i.e., not TRIGA Basic) definition for this array is the following:\par
\par
\f1\fs18\tab\tab const\par
\tab\tab\tab siteSpecificStmts_c\tab :stmt_t[] := \par
\tab\tab\tab [\par
\tab\tab\tab\tab // Last entry isn't referenced.\par
\tab\tab\tab\tab\par
\tab\tab\tab\tab stmt_t:[ "    dummy    ",\tab\tab  0, 0\tab\tab ]\par
\tab\tab\tab ];\par
\f0\fs20\par
Any new \b stmt_t\b0  entries you add to this array must be added before the dummy element. Note that by adding spaces into the string the HLA Basic compiler will never be able to match this \lquote reserved word\rquote  because the compiler strips away all surrounding spaces before attempting to match a reserved word. Generally, you should not put spaces inside or around your reserved word string.\par
\par
As an example of a \b siteSpecificStmts_c\b0  entry, consider a new statement \b drawRect\b0  that takes six arguments.  This statement might have the following syntax:\par
\par
\pard\qj\f1\fs18\tab drawRect x, y, width, height, lineColor, fillColor\par
\pard\fi360\li360\qj\f0\fs20\par
\pard\li360\qj Where \i x, y, width, height, lineColor,\i0  and \i fillColor\i0  all represent integer expressions.  This statement might draw four lines between (\i x,y\i0 ) and (\i x+width,y\i0 ), (\i x,y\i0 ) and (\i x,y+height\i0 ), (\i x+width, y\i0 ) and (\i x+width,y+height\i0 ), and (\i x,y+height\i0 ) and (\i x+width, y+height\i0 ). The line would be drawn using the color specified by \i lineColor\i0  and the interior of the rectangle would be filled with the color value specified by \i fillColor\i0 .\par
\pard\fi360\li360\qj\par
To implement this new statement in HLA Basic using the easy method, you would add the following line to the \b siteSpecificStmts_c\b0  array declaration:\par
\par
\f1\fs18\tab\tab\tab\tab stmt_t:[ "drawrect", 6, @\{\} ]\par
\f0\fs20\par
\pard\li360\qj Note that all of the arguments can be generic expressions (none of them are required to be identifiers), hence the \b IDmap\b0  value of \b @\{\}\b0 .\par
\par
\pard\fi360\li360\qj Adding an entry to the \b siteSpecificStmts_c\b0  array and recompiling the system automatically generates code in the compiler and decompiler to compile and decompile your statement.  This also generates a constant of the form \ldblquote\i <reserved_word>\i0 _tkn\rdblquote  (where \ldblquote\i <reserved_word>\i0\rdblquote  is the identifier string you\rquote ve specified) that you can use to identify the statement in your interpreter code). The \b drawRect\b0  example above, for example, generates a constant definition of the form \b drawRect_tkn\b0 . At this point, it\rquote s up to you to implement the actions associated with the new statement in the interpreter.  Modifying the interpreter is exactly the same whether you\rquote re using the easy or flexible method, so skip down below to find out how to modify the interpreter.\par
\par
When adding a new statement to the HLA Basic language without using the easy method, you will have to make changes to three programs: the Basic compiler, the decompiler, and the interpreter.  Changes to the compiler and decompiler will usually consist of cutting and pasting existing code (and making some minor modifications to support your new statement). The modification to the interpreter (with the code appearing in your main HLA application) will be as simple or as complex as the semantics of your statement dictate.\par
\par
Without question, the most common form of an extended HLA Basic statement is a reserved word following by zero or more comma-separated expressions or identifiers (which is why the easy method implements such statements). Generally, you\rquote d use the easy method to implement such statements unless you have special requirements (such as wanting to use a reserved word that is not a valid HLA identifier).  As an example of a manual implementation, let\rquote s consider the manual implementation of the \b drawRect\b0  statement example given earlier.\par
\par
To add a statement to the compiler, the first step is to add a new keyword to the language.  To do this, edit the basic.hhf header file and add a new entry to the \b mkRWstrs\b0  macro invocation found in that file.  Each line in the \b mkRWstrs\b0  macro contains exactly four fields:\par
\par
\pard\fi-360\li1440\qj\fs24 1.\tab\fs20 A token constant identifier that will be used to identify this reserved word in the interpreter. This must be a valid HLA identifier.  For example, \b drawRect_tkn\b0  is a good choice for the \b drawRect\b0  statement.\par
\fs24 2.\tab\fs20 A string constant the specifies the HLA Basic reserved word. This string must not contain any spaces or control characters and it should look like a standard HLA Basic identifier. In particular, HLA Basic reserved words must begin with an alphabetic or underscore character.\par
\fs24 3.\tab\fs20 A spacing field that the decompiler uses to determine how many spaces to print before and after the reserved word when decompiling a program. If bit #0 is set, then the decompiler will print a space after the reserved word; if bit #1 is set, then the decompiler will print a space before the reserved word.  If your new statement doesn\rquote t have any arguments, then \b @\{\}\b0  is probably the best value (that is, no spaces before or after the reserved word). If your statement has arguments, you\rquote ll probably want to specify \b @\{1\}\b0  (that is, a space after the reserved word).\par
\fs24 4.\tab\fs20 The fourth field contains the reserved word type. For new statements, this must be the constant \b stmt_c\b0 .\par
\pard\fi360\li360\qj\par
The drawRect example would probably have a \b mkRWstrs\b0  entry like the following:\par
\par
\f1\fs18\tab\tab drawRect_tkn, \ldblquote drawRect\rdblquote , @\{1\}, stmt_c,\par
\f0\fs20\par
You can add this statement anywhere in the \b mkRWstrs\b0  macro invocation;  the current entries are sorted by reserved word type and then alphabetically. It probably makes sense to maintain that order (though this isn\rquote t required).\par
\pard\qj\par
\pard\fi360\li360\qj Next, edit the bc.hla source file and search for a statement that is similar in syntax to the one you want to create (e.g., \i drawRect\i0 ).  For example, the COLOR statement is similar in syntax (though it has only two arguments rather than five), so search for \i COLORtkn\i0  in the bc.hla source file.  This code is reproduced below for you:\par
\par
\pard\qj\f1\fs18\tab\par
\pard\li720\qj //////////////////////////////////////////////////////////////////////\tab\par
//\par
// Handle the COLOR <expr>, <expr> statement here.\par
\par
pat.alternate\par
\par
\pard\li1170\qj // COLOR keyword:\par
\par
pat.zeroOrMoreWS();\par
pat.matchiWord( rw(COLORtkn) );\par
PutToken( COLORtkn );\tab\tab\tab\par
Expression( esi, edi );\par
pat.oneChar( ',' );\par
PutToken( COMMAtkn );\par
Expression( esi, edi );\par
pat.endStmt();\tab\tab\par
\pard\fi360\li360\qj\f0\fs20\par
\par
The code for every new statement begins by skipping any leading whitespace on the line and then matching the reserved word.  Note the use of the \b pat.matchiWord\b0  pattern matching function. This makes the test case insensitive (so \ldblquote drawrect\rdblquote , \ldblquote DRAWRECT\rdblquote , and \ldblquote drawRect\rdblquote  are all equivalent to the compiler).  The \b rw\b0  macro invocation converts the token constant to the corresponding string. That is, the above call to \b pat.matchiWord\b0  is equivalent to\b  pat.matchiWord( \ldblquote color\rdblquote  ).\b0\par
\par
Once you\rquote ve matched the reserved word string, you need to emit the corresponding token to the compiled byte code output file. This is accomplished using the \b PutToken\b0  function. The example above emits the token for the COLOR reserved word (\b COLORtkn\b0 ) to the byte code output file.\par
\par
The COLOR statement is followed by two arithmetic expressions (separated by a comma). The call to the \b Expression\b0  function skips all leading (and trailing) white space, parses an arithmetic expression, and emits the byte code for that expression to the byte code output file.   After processing one expression, the code above checks for a comma (and emits the token for the comma to the byte code output file) and then processes the second expression.\par
\par
At the end of an expression, the code for a new statement must call \b pat.endStmt\b0  to clean things up.  The \b pat.endStmt\b0  checks for a valid end-of-statement sequence (either a \lquote :\rquote  character or an end of line).\par
\par
The syntax of the \b drawRect\b0  statement differs from the color statement because \b drawRect\b0  has six expression parameters rather than two (in addition to the fact that it begins with the \ldblquote drawRect\rdblquote  reserved word, of course). This means that we\rquote ve got to duplicate the code that parses the comma and the second expression four additional times to handle these extra arguments:\par
 \par
\par
\pard\qj\f1\fs18\tab\par
\pard\li720\qj //////////////////////////////////////////////////////////////////////\tab\par
//\par
// Handle the DRAWRECT <expr>, <expr>, <expr>, <expr>, <expr> \par
// statement here.\par
\par
pat.alternate\par
\par
\pard\li1170\qj // drawRect keyword:\par
\par
pat.zeroOrMoreWS();\par
pat.matchiWord( rw(DRAWRECTtkn) );\par
PutToken( DRAWRECTtkn );\par
\par
// X-coordinate:\par
\tab\tab\tab\par
Expression( esi, edi );\par
\par
pat.oneChar( ',' );\par
PutToken( COMMAtkn );\par
\par
// Y-coordinate:\par
\par
Expression( esi, edi );\par
\par
pat.oneChar( ',' );\par
PutToken( COMMAtkn );\par
\par
// width:\par
\par
Expression( esi, edi );\par
\par
pat.oneChar( ',' );\par
PutToken( COMMAtkn );\par
\par
// height:\par
\par
Expression( esi, edi );\par
\par
pat.oneChar( ',' );\par
PutToken( COMMAtkn );\par
\par
// lineColor:\par
\par
Expression( esi, edi );\par
\par
pat.oneChar( ',' );\par
PutToken( COMMAtkn );\par
\par
// fillColor:\par
\par
Expression( esi, edi );\par
\par
pat.endStmt();\tab\tab\par
\pard\fi360\li360\qj\f0\fs20\par
Now all that remains is to insert this code into the appropriate spot in the compiler source file.  The sections of code that handle the HLA Basic statements are generally arranged in alphabetical order (by statement name). You might want to consider inserting the code for the above statement in that same order in the source file (i.e., between the code that handles the \ldblquote COLOR\rdblquote  statement and the code that handles the \ldblquote DEBUG\rdblquote  statement).  Another alternative, if you want to differentiate your statement extensions from standard HLA Basic statements is to use conditional assembly to surround the statements that are specific to your version of HLA Basic and place those statements after all the standard HLA Basic statements (i.e., before the default at the end of the \b pat.match\b0  statement that processes whole statements \endash  this will be somewhere around the statement that processes the WHILE statement, so search for the \b WHILEtkn\b0  in a \b pat.matchiWord\b0  function call).\par
\par
The \b drawRect\b0  example is rather simple insofar as the \b drawRect\b0  arguments are all generic expressions that you parse with the \b Expression( esi, edi );\b0  call.  In some cases, you might want to limit a statement argument to an identifier rather than a generic expression. For example, the HLA Basic statement \b readln\b0  expects a single identifier as an argument (the run-time system reads a line of text from the standard input and stores this string data into the identifier supplied as the argument).  To parse a single identifier, you would use the \b ParseID( esi, edi, idTkn );\b0  function call. The ParseID function has three parameters. The first and second arguments are always esi and edi (which is the start of the string to begin matching and the last available byte for matching \endash  these are the standard esi/edi values during pattern matching). The third argument is either zero or the constant \b IDtkn1\b0 .  Generally, you would supply the value \b IDtkn1\b0 ; the only time you would supply zero is when you\rquote ve already emitted some token that expects a two-byte identifier number (some statements, like \b readLn\b0 , simply assume that a two-byte identifier number follows the token without an explicit \b IDtkn\i x\b0\i0  value).  For example, here is the code for the HLA Basic \b next \i id \b0\i0  statement:\par
\pard\qj\par
\pard\fi360\li360\qj\f1\tab\tab   //////////////////////////////////////////////////////////////////////\tab\par
\pard\fi360\qj //\par
\pard\li360\qj // Handle the NEXT <id> statement here \par
// (must have <id> after the NEXT).\par
\pard\fi360\li360\qj\tab\tab   \par
pat.alternate\par
\par
\tab // NEXT <id> statement:\par
\par
\tab mov( index, nextIndex );\tab\tab // Save for next alternate.\par
\tab\tab\tab\par
\tab pat.zeroOrMoreWS();\par
\tab pat.matchiWord( rw(NEXTtkn) );\par
\tab PutToken( NEXTtkn );\par
\par
\tab // Get the identifier following the NEXT:\par
\par
\tab ParseID( esi, edi, IDtkn1 );\par
\tab pat.endStmt();\par
\tab if( nextIndex <> 0 ) then\par
\tab\tab\tab\par
\tab\tab stdout.put\par
\tab\tab ( \par
\tab\tab\tab "Error: NEXT <ID> must be first statement on line "\par
\tab\tab\tab nl\par
\tab\tab );\par
\tab\tab raise( BasicError );\par
\tab\tab\tab\tab\par
\tab endif;\par
\f0\par
The next step is to add support for the new statement to the HLA Basic decompiler/detokenizer (the bd.hla source file). Strictly speaking, adding support to the decompiler is optional. You don\rquote t need to do this in order to compile and run HLA Basic programs that use your new statements. However, if you need to debug the compiler, modifying the decompiler to handle your new statements makes the (debugging) job a whole lot easier.\par
\par
Like adding code to the compiler, the easiest course of action is to locate a statement that has a syntax similar to the statement you\rquote re creating. As the COLOR statement was fairly close in the compiler, we use that same statement as a template when dealing with the decompiler. Searching for the string \ldblquote COLORtkn\rdblquote  in the decompiler locates the following case in the main switch statement of the decompiler:\par
\par
\par
\f1\fs18\tab case( COLORtkn )\par
\tab\tab\tab\tab\par
\tab\tab str.cat2( RWStrs[ eax*4 ], ebp::destStr );\par
\tab\tab str.catc( ebp::destStr, ' ' );\par
\tab\tab detokExpr( esi );\par
\tab\tab str.cat2( eax, ebp::destStr );\par
\tab\tab str.free( eax );\par
\tab\tab\tab\tab\par
\tab\tab add( 1, esi );\tab\tab // Skip ',' token\par
\tab\tab str.cat2( ", ", ebp::destStr );\par
\tab\tab\tab\tab\par
\tab\tab detokExpr( esi );\par
\tab\tab str.cat2( eax, ebp::destStr );\par
\tab\tab str.free( eax );\par
\pard\nowidctlpar\fi-270\li360\tx560\tx720\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\f0\fs20\par
\pard\nowidctlpar\li360\tx560\tx720\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720 Upon executing a case in this switch statement, the following conditions hold:\par
\par
\pard\nowidctlpar\fi-360\li1149\tx560\tx1120\tx1149\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\f1\fs24 o\tab\f0\fs20 EAX contains the token value\par
\pard\nowidctlpar\fi-360\li1149\f1\fs24 o\tab\i\f0\fs20 RWStrs\i0  is an array of strings, indexed by the token value, that contain the reserved word strings.  E.g., \i RWStrs[ COLORtkn*4 ]\i0  is the address of the string \ldblquote color\rdblquote .\par
\f1\fs24 o\tab\f0\fs20 ESI points at the first byte in the byte code stream past the token just processed (e.g., it points just beyond the COLORtkn in the example above).\par
\f1\fs24 o\tab\i\f0\fs20 ebp::destStr\i0  is a string object that contains the line of text being built up by the decompiler.\par
\pard\nowidctlpar\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720 The function \b detokExpr\b0  will decompile a single arithmetic expression starting at the byte addressed by its argument (which will always be ESI). This function returns ESI pointing at the first byte in the byte code stream beyond the expression it processes.  It also returns EAX pointing at the string object containing the character representation of the expression it has detokenized. This string is allocated on the heap and it is the responsibility of the following code to free that storage when it is done with the string.\par
\par
The job of the decompiler is to append an appropriate set of characters to the string pointed at by \b ebp::destStr\b0  to represent the statement being decompiled. Here\rquote s what each of the statements above are doing.\par
\par
\pard\fi360\li360\qj\f1\fs18\tab\tab str.cat2( RWStrs[ eax*4 ], ebp::destStr );\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\f0\fs20\par
The first job when decompiling a statement is to emit the statement\rquote s reserved word to the end of the string pointed at by \b ebp::destStr\b0 .  Note that you must not assume that the reserved word is at the beginning of the line and simply copy the reserved word string to where \b ebp::destStr\b0  points.  Remember, HLA Basic allows multiple statements per source line (separated by \lquote :\rquote  characters) and simply storing the string to \b ebp::destStr\b0  may wipe out part of the source line.  Always concatenate your reserved word string to the end of \b ebp::destStr\b0  to avoid this problem.\par
\par
Note that the example above concatenates the string pointed at by \b RWStrs[eax*4] \b0 to \b ebp::destStr\b0 .  Because we know, by virtue of the case, that the reserved word string is actually \ldblquote color\rdblquote  we could have used the following statement:\par
\par
\pard\fi360\li360\qj\f1\fs18\tab\tab str.cat2( \ldblquote color\rdblquote , ebp::destStr );\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\f0\fs20\par
However, by using the \b\i RWStrs\b0\i0  array we make the program much easier to change in the future (e.g., if you want to change \ldblquote drawRect\rdblquote  to \ldblquote drawRectangle\rdblquote ) because changes to reserved words are made in only one place: the basic.hhf header file. Note that the \b RWStrs\b0  array is automatically built up by the \b mkRWStrs\b0  macro invocation in the basic.hhf header file. So you don\rquote t have to update the \b RWStrs\b0  array each time you add a new reserved word to the system.\par
\par
In order to separate the reserved word from the first expression following the reserved word, we need to emit a space to the string we\rquote re building up. The following call in the code above achieves this result:\par
\par
\pard\fi360\li360\qj\f1\fs18\tab str.catc( ebp::destStr, ' ' );\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\f0\fs20\par
\pard\nowidctlpar\fi21\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720 Note the syntax peculiarity of the \b str.catc\b0  function call: the destination operand is the first operand rather than the last operand.\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\par
The next step is to detokenize the first expression in the \i color\i0  statement.  The following three statements achieve this:\par
\par
\pard\fi360\li360\qj\f1\fs18\tab\tab detokExpr( esi );\par
\tab\tab str.cat2( eax, ebp::destStr );\par
\tab\tab str.free( eax );\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\f0\fs20\par
\pard\nowidctlpar\fi21\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720 Remember, it is the responsibility of this code to free the storage allocated by \b detokExpr\b0  when it is done using that string!\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\par
Next, we have to detokenize the comma that separates the two expressions. Note that a comma token must appear at this point (the compiler always produces syntactically correct byte code output files), so there is no need to actually check to see that a comma is present (you can put an assert in if you\rquote re paranoid).  The following code simply skips the comma token and emits a comma (and a space) to the output string:\par
\par
\pard\fi360\li360\qj\f1\fs18\tab\tab add( 1, esi );\tab\tab // Skip ',' token\par
\tab\tab str.cat2( ", ", ebp::destStr );\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\f0\fs20\par
Finally, the code for the second expression in the COLOR statement concatenates the second expression string to the end of the destination string:\par
\par
\pard\fi360\li360\qj\f1\fs18\tab\tab detokExpr( esi );\par
\tab\tab str.cat2( eax, ebp::destStr );\par
\tab\tab str.free( eax );\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\f0\fs20\par
Note that the detokenization code doesn\rquote t do anything special at the end of the statement. It doesn\rquote t check for end of line or for a statement separator. Nor does this code actually write the string to the standard output. The main detokenizer loop does all this for you.  The job of each case in the main decompiler switch statement is to decompile a string statement and append that string representation to the string pointed at by \b ebp::destStr\b0  and do nothing more.\par
\par
To decompile the \b drawRect\b0  statement we\rquote re creating, the process is very similar to that we employed with the compiler: copy a statement that has a similar syntax (e.g., \i color\i0 ) and adjust the result accordingly.  The \b drawRect\b0  statement is very similar to \i color\i0  with the addition of three extra expressions.  So all we have to do is replicate the code that emits a comma and an expression four times and insert the code at an appropriate place in the main switch statement (e.g., after the code for \i color\i0 ).  Here\rquote s what the \b drawRect\b0  detokenization code might look like:\par
\par
\pard\fi360\li360\qj\f1\fs18\tab case( DRAWRECTtkn )\par
\tab\tab\tab\tab\par
\tab\tab str.cat2( RWStrs[ eax*4 ], ebp::destStr );\par
\tab\tab str.catc( ebp::destStr, ' ' );\par
\par
\tab\tab // Emit \lquote x\rquote  expression:\par
\par
\tab\tab detokExpr( esi );\par
\tab\tab str.cat2( eax, ebp::destStr );\par
\tab\tab str.free( eax );\par
\tab\tab\tab\tab\par
\tab\tab add( 1, esi );\tab\tab // Skip ',' token\par
\tab\tab str.cat2( ", ", ebp::destStr );\par
\tab\tab\tab\tab\par
\tab\tab // Emit \lquote y\rquote  expression:\par
\par
\tab\tab detokExpr( esi );\par
\tab\tab str.cat2( eax, ebp::destStr );\par
\tab\tab str.free( eax );\par
\tab\tab\tab\tab\par
\tab\tab add( 1, esi );\tab\tab // Skip ',' token\par
\tab\tab str.cat2( ", ", ebp::destStr );\par
\tab\tab\tab\tab\par
\tab\tab // Emit \lquote width\rquote  expression:\par
\par
\tab\tab detokExpr( esi );\par
\tab\tab str.cat2( eax, ebp::destStr );\par
\tab\tab str.free( eax );\par
\tab\tab\tab\tab\par
\tab\tab add( 1, esi );\tab\tab // Skip ',' token\par
\tab\tab str.cat2( ", ", ebp::destStr );\par
\tab\tab\tab\tab\par
\tab\tab // Emit \lquote height\rquote  expression:\par
\par
\tab\tab detokExpr( esi );\par
\tab\tab str.cat2( eax, ebp::destStr );\par
\tab\tab str.free( eax );\par
\tab\tab\tab\tab\par
\tab\tab add( 1, esi );\tab\tab // Skip ',' token\par
\tab\tab str.cat2( ", ", ebp::destStr );\par
\tab\tab\tab\tab\par
\tab\tab // Emit \lquote linecolor\rquote  expression:\par
\par
\tab\tab detokExpr( esi );\par
\tab\tab str.cat2( eax, ebp::destStr );\par
\tab\tab str.free( eax );\par
\tab\tab\tab\tab\par
\tab\tab add( 1, esi );\tab\tab // Skip ',' token\par
\tab\tab str.cat2( ", ", ebp::destStr );\par
\tab\tab\tab\tab\par
\tab\tab // Emit \lquote fillcolor\rquote  expression:\par
\par
\tab\tab detokExpr( esi );\par
\tab\tab str.cat2( eax, ebp::destStr );\par
\tab\tab str.free( eax );\par
\pard\nowidctlpar\fi-270\li360\tx560\tx720\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\f0\fs20\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720 The last step in implementing a new HLA Basic statement is to add support for that statement to the interpreter. This step is the same for both the easy and flexible methods.  You could modify the bx.hla file to support your new statements; however, the interpreter code is object-oriented and provides a better solution \endash  overloading the interpreter base class in your main application code. You do this by overriding the \b byteCodeExtensions\b0  method in the new program class (e.g., \b myRTPgmClass\b0  from the earlier examples for pseudo-variables).  Here\rquote s the code you would use:\par
\par
\pard\li90\qj\f1\fs18 type\par
\tab myRTPgmClass: class inherits( rtPgmClass );\par
\tab\par
\tab\tab override procedure create;\par
\tab\tab override method byteCodeExtensions;\par
\tab\tab\tab\tab\par
\tab endclass;\par
\tab\par
\tab pMyRTPgmClass\tab :pointer to myRTPgmClass;\par
\tab\par
\tab\par
readonly\par
\tab align( 4 );\par
\tab vmt( myRTPgmClass );\par
\f0\fs20\par
\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720 Note that if you were also adding pseudo variables and built-in functions (using the flexible, rather than the easy methods), the class description would look like this:\par
\pard\li90\qj\f1\fs18\par
type\par
\tab myRTPgmClass: class inherits( rtPgmClass );\par
\tab\par
\tab   override procedure create;\par
\tab   override method pseudoVarExtensions;\tab // Present for new pseudo vars\par
\tab   override method functionExtensions;\tab // Present for new functions\par
\tab   override method byteCodeExtensions;\tab // Present for new statements\par
\tab\tab\tab\tab\par
\tab endclass;\par
\tab\par
\tab pMyRTPgmClass\tab :pointer to myRTPgmClass;\par
\tab\par
\tab\par
readonly\par
\tab align( 4 );\par
\tab vmt( myRTPgmClass );\par
\pard\li1440\qj\f0\fs20\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720 Whenever HLA Basic encounters a byte code it doesn\rquote t recognize, it invokes the \b byteCodeExtensions\b0  method that takes responsibility for processing unknown byte codes.  Upon entry into the \b byteCodeExtensions\b0  method, the following conditions hold:\par
\par
\pard\nowidctlpar\fi-360\li1440\tx560\tx1120\tx1440\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\f1\fs24 o\tab\f0\fs20 EAX contains the (zero-extended) byte code value. This is the reserved word constant you supply as the first entry on each line in the \b mkRWstrs\b0  macro invocation (using the non-easy implementation) or the \ldblquote\i <reserved_word>\i0 _tkn\rdblquote  constant created by the easy method. You do not need to preserve EAX\rquote s value.\par
\pard\nowidctlpar\fi-360\li1440\f1\fs24 o\tab\f0\fs20 ECX points at the byte code stream (specifically, at the program file where the token held in EAX appears).  You are responsible for updating ECX as you process tokens in the byte code stream.\par
\f1\fs24 o\tab\f0\fs20 ESI points at the \b myRTPgmClass\b0  object (so you can access fields of the object using \ldblquote this\rdblquote ).  It\rquote s a real good idea to preserve this value. You will probably use it throughout your code.\par
\f1\fs24 o\tab\f0\fs20 EDI points at the VMT for \b myRTPgm\b0  class. You may use EDI as a scratchpad register; you do not need to preserve its value. Typically, you will use EDI to point at the run-time evaluation stack if you need to evaluate any expressions.\par
\f1\fs24 o\tab\f0\fs20 EDX is a scratchpad register that you may use as you please.\par
\f1\fs24 o\tab\f0\fs20 You must preserve the value in EBX.\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\par
Here\rquote s the template for a typical \b byteCodeExtensions\b0  method you'd write in your own program:\par
\par
\pard\f1\fs18\tab method myRTPgmClass.byteCodeExtensions;\par
\tab var\par
\tab\tab // Local variables used by your code might go here.\par
\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720 begin byteCodeExtensions;\par
\par
\tab // Skip the statement\rquote s token in the code stream:\par
\par
\tab push( ebx );\par
\tab add( 1, ecx );\par
\tab switch( eax )\par
\par
\tab\tab .\par
\tab\tab .\par
\tab\tab .\par
\tab   // Code for new statement cases goes here\par
\tab\tab .\par
\tab\tab .\par
\tab\tab .\par
\par
\tab\tab\tab\par
\tab   default\par
\tab\tab\tab\par
\tab\tab str.put\par
\tab\tab (\par
\tab\tab\tab this.exceptionMsg,\par
\tab\tab\tab "Unexpected pseudo-variable token = $",\par
\tab\tab\tab al\tab\tab\tab\tab\tab\par
\tab\tab );\par
\tab\tab raise( BasicErrorWithMsg );\par
\tab\tab\tab\tab\tab\par
\tab\tab\par
\tab endswitch;\par
\tab pop( ebx );\par
\par
end byteCodeExtensions;\par
\f0\fs20\par
\par
Most of the support functions you\rquote ll use when implementing a new statement are exactly those same functions described in the section on implementing pseudo variables.  You\rquote ll use functions like \b this.evalExpr, this.makeInt, this.makeReal\b0 , and so on.\par
\par
As is typical in all these examples, the best solution is to find a statement whose syntax is somewhat similar to the new statement you\rquote re creating, cut and paste that case into your new \b byteCodeExtensions\b0  method, and make the appropriate adjustments.  For example, the case for the \b color\b0  statement in bx.hla is the following:\par
\par
\f1\fs18\tab case( COLORtkn )\par
\tab\par
\tab\tab //\tab COLOR expr, expr\par
\tab\par
\tab\tab add( 1, ecx );\tab\tab\tab\tab // Skip the COLOR token.\par
\tab\tab this.evalExpr( ecx );\tab\tab // Get foreground value.\par
\tab\tab this.makeInt( al, "COLOR requires integer operands" );\par
\tab\tab and( $f, eax );\par
\tab\tab push( eax );\par
\tab\tab add( 1, ecx );\tab\tab\tab\tab // Skip the "," token.\par
\tab\tab this.evalExpr( ecx );\tab\tab // Get the background color.\par
\tab\tab this.makeInt( al, "COLOR requires integer operands" );\par
\tab\tab pop( edx );\par
\tab\tab and( $f, eax );\par
\tab\tab console.setAttrs( edx, eax );\par
\par
\f0\fs20 Line-by-line here is what is happening here:\par
\par
\f1\fs18\tab\tab add( 1, ecx );\tab\tab\tab\tab // Skip the COLOR token.\par
\f0\fs20\par
This skips over the color token in the code stream.  Note, however, that the \b byteCodeExtensions\b0  example given earlier already does this at the beginning of the function, before the switch statement, so you would not copy this statement into the code for a \b drawRect\b0  statement extension.\par
\par
\f1\fs18\tab\tab this.evalExpr( ecx );\tab\tab // Get foreground value.\par
\tab\tab this.makeInt( al, "COLOR requires integer operands" );\par
\tab\tab and( $f, eax );\par
\tab\tab push( eax );\par
\f0\fs20\par
This code evaluates the expression immediately following the \b COLORtkn\b0  token and leaves the result of that expression on the top of the evaluation stack (actually, it will be the only value on the evaluation stack).  The call to \b this.makeInt\b0  verifies that the value on the top of the stack is an integer (or can be converted to an integer) and returns that value in EAX. Because HLA Basic color values are in the range 0..15, the AND statement forces the integer result into this range (that is, this statement ignores the H.O. 28 bits of the 32-bit integer value). This code then saves the value on the x86 hardware stack for later use (it could also have put the value in a local variable, but pushing it onto the stack was probably the easiest solution).\par
\par
\f1\fs18\tab\tab add( 1, ecx );\tab\tab\tab\tab // Skip the "," token.\par
\f0\fs20\par
This code skips the comma token appearing in the code stream. We know (by virtue of a correct compilation) that the token is present, so there is no need to verify that there is a comma token in the code stream.  If you are anal retentive, you can put an assert statement here to verify that a comma token is present, but keep in mind that such code will slow down the Basic run-time system and that\rquote s not a good idea.\par
\par
\f1\fs18\tab\tab this.evalExpr( ecx );\tab\tab // Get the background color.\par
\tab\tab this.makeInt( al, "COLOR requires integer operands" );\par
\tab\tab pop( edx );\par
\tab\tab and( $f, eax );\par
\f0\fs20\par
These statements obtain the value of the second expression (into EAX, stripping off all but the L.O. four bits) and put the value of the original expression into EDX.\par
\par
\f1\fs18\tab\tab console.setAttrs( edx, eax );\par
\f0\fs20\par
This statement does the actual work of the \b color\b0  statement \endash  setting the console text color attribute values.\par
\par
The code for a \b drawRect\b0  statement will look similar to this:\par
\par
\f1\fs18\tab case( drawRect_tkn )\par
\tab\par
\tab\tab //\tab DRAWRECT expr, expr, expr, expr, expr, expr\par
\tab\par
\tab\tab this.evalExpr( ecx );\tab\tab // Get x-coord value.\par
\tab\tab this.makeInt( al, "drawRect requires integer operands" );\tab\tab\tab\tab\tab\tab mov( eax, x );\par
\par
\tab\tab add( 1, ecx );\tab\tab\tab\tab // Skip the "," token.\par
\par
\tab\tab this.evalExpr( ecx );\tab\tab // Get the y-coord value.\par
\tab\tab this.makeInt( al, "drawRect requires integer operands" );\par
\tab\tab mov( eax, y );\par
\par
\tab\tab add( 1, ecx );\tab\tab\tab\tab // Skip the "," token.\par
\par
\tab\tab this.evalExpr( ecx );\tab\tab // Get the width value.\par
\tab\tab this.makeInt( al, "drawRect requires integer operands" );\par
\tab\tab mov( eax, width );\par
\par
\tab\tab add( 1, ecx );\tab\tab\tab\tab // Skip the "," token.\par
\par
\tab\tab this.evalExpr( ecx );\tab\tab // Get the height value.\par
\tab\tab this.makeInt( al, "drawRect requires integer operands" );\par
\tab\tab mov( eax, height );\par
\par
\tab\tab add( 1, ecx );\tab\tab\tab\tab // Skip the "," token.\par
\par
\tab\tab this.evalExpr( ecx );\tab\tab // Get the lineColor value.\par
\tab\tab this.makeInt( al, "drawRect requires integer operands" );\par
\tab\tab mov( eax, lineColor );\par
\par
\tab\tab add( 1, ecx );\tab\tab\tab\tab // Skip the "," token.\par
\par
\tab\tab this.evalExpr( ecx );\tab\tab // Get the fillColor value.\par
\tab\tab this.makeInt( al, "drawRect requires integer operands" );\par
\tab\tab mov( eax, fillColor );\par
\par
\tab\tab // Presumably, drawRect is some HLA function that actually\par
\tab\tab // draws the rectangle under your OS:\par
\par
\tab\tab drawRect( x, y, width, height, lineColor, fillColor );\par
\par
\f0\fs20\par
The \b drawRect\b0  example\rquote s argument list consists of six comma-separated expressions.  Suppose that one or more of the arguments has to be an identifier rather than a generic expression.  The run-time environment stores all the program\rquote s variables in a single array of Variant objects.  HLA Basic variable references consist of some token (usually \b IDtkn1\b0  or \b IDtkn2\b0 , but there are several other lead-in tokens as well) followed by a one or two-byte variable number (\b IDtkn1\b0  prefaces a 1-byte variable number, \b IDtkn2\b0  prefaces a 2-byte variable number).  You will have to extract the variable number and use this as an index into the run-time variable table to obtain the address of the specified variable. This is done with code like the following (assume EAX contains the current lead-in token value and ECX points at the byte just beyond the lead-in token value in the token stream):\par
\par
\f1\fs18\tab If( al = IDtkn1 ) then\par
\tab\tab\par
\tab\tab movzx( (type byte [ecx]), edx );\tab // Get the 1-byte var #\par
\tab\tab add( 1, ecx );\tab\tab\tab\tab\tab // Skip past the var #\par
\par
\tab else\par
\par
\tab\tab movzx( (type word [ecx]), edx );\tab // Get 2-byte var #\par
\tab\tab add( 2, ecx );\tab\tab\tab\tab\tab // Skip past the var #\par
\par
\tab endif;\par
\tab intmul( @size( Variant ), edx );\tab\tab // Compute index into vars\par
\tab add( this.varData, edx );\tab\tab\tab\tab // Add in base address\par
\par
\tab // The following handles an optional array index that might follow\par
\tab // the variable reference\par
\par
\tab this.ProcessIndex( ecx, edx );\par
\par
\tab\tab\par
\f0\fs20 At the end of the code sequence above, EDX is pointing at the variable object in the run-time variable table.  This is an object of type \b Variant\b0  and you can easily access the fields of this variant object using the \b varEDX\b0  text constant (which expands to \ldblquote (type Variant [edx])\rdblquote ).  If you plan to overwrite the value of that variable, you must first deallocate any storage it holds via the call:\par
\par
\f1\fs18\tab Deallocate( [edx] );\tab // Assumes EDX is the address of the \par
\tab\tab\tab\tab\tab // variable in this.varData\par
\f0\fs20\par
\par
If you would like to extend HLA Basic\rquote s statement repertoire with a statement that doesn\rquote t follow the restricted simplified syntax the easy method supports, then you will need to make appropriate changes in the compiler, decompiler, and interpreter.\par
\par
First, let\rquote s consider an easy case. Suppose you want to create a new statement that supports a variable number of arguments (zero or more). A good example of this is the HLA Basic \b print\b0  statement. Here\rquote s the compiler code for the HLA Basic \b print\b0  statement (note that this code also demonstrates using \lquote ;\rquote  argument separators in addition to \lquote ,\rquote ):\par
\par
\pard\nowidctlpar\fi160\li560\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\f1\fs18\tab\tab   //////////////////////////////////////////////////////////////////////\tab\par
\pard\nowidctlpar\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tab //\par
\tab // Handle the PRINT <expr list> statement here.\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tab\tab   \par
\pard\nowidctlpar\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tab pat.alternate\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\par
// PRINT keyword:\par
\pard\nowidctlpar\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\par
\tab\tab pat.zeroOrMoreWS();\par
\pard\nowidctlpar\fi291\li429\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\tab\tab\tab\par
\tab // Match PRINT\par
\tab\tab\tab\par
\tab pat.matchiWord( rw(PRINTtkn) );\par
\tab PutToken( PRINTtkn );\par
\tab\tab\tab\tab\par
\par
\tab // Process the expression list following the PRINT keyword:\par
\tab // Since all expressions are optional, we must begin by\par
\tab // seeing if there is at least one expression.\par
\tab\tab\tab\par
\tab pat.match( esi, edi )\par
\tab\tab\tab\par
\tab\tab pat.endStmt();\par
\tab\tab mov( false, al );\par
\tab\tab\tab\tab\par
\tab   pat.if_failure\par
\tab\tab\tab   \par
\tab\tab mov( true, al );\par
\tab\tab\tab\tab\par
\tab pat.endmatch;\par
\tab\tab\tab\par
\tab // AL = true if we're not at the end of a statment and we\par
\tab // must process an expression.\par
\tab\tab\tab\par
\tab while( al ) do\par
\tab\tab\tab\par
\tab\tab Expression( esi, edi );\par
\tab\tab\tab\tab\par
\tab\tab // At this point we could have the end of the\par
\tab\tab // statement or we could have a ';' or a ',' \par
\tab\tab\tab\tab\par
\tab\tab pat.match( esi, edi )\par
\tab\tab\tab\tab\par
\tab\tab\tab pat.endStmt();\par
\tab\tab\tab mov( false, al );\par
\tab\tab\tab\tab\tab\par
\tab\tab   pat.alternate\par
\tab\tab\tab\tab   \par
\tab\tab\tab pat.zeroOrMoreWS();\par
\tab\tab\tab pat.oneChar( ';' );\par
\tab\tab\tab PutToken( SEMICOLONtkn );\par
\tab\tab\tab\tab\tab\par
\tab\tab\tab // If the semicolon appears at the end of a statement,\par
\tab\tab\tab // that's okay too.\par
\tab\tab\tab\tab\tab\par
\tab\tab\tab pat.match( esi, edi )\par
\tab\tab\tab\tab\tab\par
\tab\tab\tab\tab pat.endStmt();\par
\tab\tab\tab\tab mov( false, al );\par
\tab\tab\tab\tab\tab\tab\par
\tab\tab\tab   pat.if_failure\par
\tab\tab\tab\tab\tab   \par
\tab\tab\tab\tab mov( true, al );\par
\tab\tab\tab\tab\tab\tab\par
\tab\tab\tab pat.endmatch;\par
\tab\tab\tab\tab\tab\par
\tab\tab   pat.alternate\par
\tab\tab\tab\tab   \par
\tab\tab\tab pat.zeroOrMoreWS();\par
\tab\tab\tab pat.oneChar( ',' );\par
\tab\tab\tab PutToken( COMMAtkn );\par
\tab\tab\tab\tab\tab\par
\tab\tab\tab // If the comma appears at the end of a statement,\par
\tab\tab\tab // that's okay too.\par
\tab\tab\tab\tab\tab\par
\tab\tab\tab pat.match( esi, edi )\par
\tab\tab\tab\tab\tab\par
\tab\tab\tab\tab pat.endStmt();\par
\tab\tab\tab\tab mov( false, al );\par
\tab\tab\tab\tab\tab\tab\par
\tab\tab\tab   pat.if_failure\par
\tab\tab\tab\tab\tab   \par
\tab\tab\tab\tab mov( true, al );\par
\tab\tab\tab\tab\tab\tab\par
\tab\tab\tab pat.endmatch;\par
\tab\tab\tab\tab\par
\tab\tab   pat.if_failure\par
\tab\tab\tab\tab   \par
\tab\tab\tab stdout.put\par
\tab\tab\tab ( \par
\tab\tab\tab\tab "Syntax error in PRINT statement argument list"\par
\tab\tab\tab\tab nl\par
\tab\tab\tab );\par
\tab\tab\tab raise( BasicError );\par
\tab\tab\tab\tab\tab\par
\tab\tab pat.endmatch;\par
\tab\tab\tab\tab\par
\tab endwhile;\tab\tab\tab\par
\f0\fs20\par
Technically, this code is a bit ugly because you don\rquote t want to use explicit loops (like \b while\b0 ) in pattern matching code \endash  it\rquote s better to use patterns like \b pat.matchOneOrMorePat\b0  \endash  but for the purposes of the HLA Basic language this approach is acceptable.\par
\par
If you wanted to match one or more (or \lquote n\rquote  or more) arguments rather than zero or more (as \b print\b0  matches), then you would simply match those arguments prior to the \b while\b0  loop in the code above.\par
\pard\brdrt\brdrs\brdrw25\brdrcf2\brsp100 \sb398\tx1144\par
\par
}
 
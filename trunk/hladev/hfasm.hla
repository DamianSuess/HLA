// flat assembler  version 1.66
// Copyright (c) 1999-2006, Tomasz Grysztar.  
// All rights reserved.
//
// This programs is free for commercial and non-commercial use as long as
// the following conditions are adhered to.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// The licence and distribution terms for any publically available
// version or derivative of this code cannot be changed. i.e. this code
// cannot simply be copied and put under another distribution licence
// (including the GNU Public Licence).
//
//
// Auxilary note:
//
//	"Randall Hyde" qualifies as a contributor under the above notice.


unit fasm;
?debug := true;
?debug2 := false;

// The definition of "cfunc" (usually on the command line) determines whether
// FASM is being compiled in stand alone mode or as a function that can be
// called from C.

//?cfunc := true;  // Uncomment this to force C function mode.
//?Linux := true;  // Uncomment this if compiling for Linux


#if( @defined( cfunc ))

	?standalone := false;
	
#else

	// If cfunc isn't defined, assume we are
	// creating a stand-along version of FASM.

	?standalone := true;
	
#endif

#if( standalone )

	#include( "stdlib.hhf" )
	
#endif

#if( @defined( Linux ) | @defined( freeBSD ) | @defined( macOS ))
	?unix := true;
#endif




#include( "hfasm.hhf" )

?@exceptions := false;
?@nodisplay := true;
?@noframe := true;
?@noalignstack := true;

// Prototypes (these are all actually forward declarations,
// not external; they were made external just for debugging
// purposes).

procedure fasmAssembler;					@external;
procedure preprocess_line;					@external;
procedure process_symbolic_constants;		@external;
procedure convert_expression;				@external;
procedure preevaluate_logical_expression;	@external;
procedure get_logical_value;				@external;
procedure mark_relocation;					@external;
procedure find_structure_end;				@external;
procedure assemble_line;					@external;
procedure preprocess_file
(
	filename		:string in edx;
	fileException	:dword in eax
); @external; 





// If this is being assembled in stand-alone mode, then use
// the HLA standard library for system function calls. If this
// is being compiled in cfunc mode, then we'll call C standard
// library functions to do the dirty work.

#if( standalone )

	?putc		:text := "stdout.putc";
	//?puts		:text := "stdout.puts";
	?putu32		:text := "stdout.putu32";
	?puthex32	:text := "stdout.putd";
	?put_newln	:text := "stdout.newln";
	?putBuf		:text := "stdout.write";
	
	procedure puts( s:string ); @nodisplay; @nostackalign; @frame;
	begin puts;
	
		pushad();
		mov( s, eax );
		str.zlen( [eax] );
		mov( s, ebx );
		stdout.write( [ebx], eax );
		popad();
		
	end puts;
	
#else

	procedure exitProcess( exitCode:dword );	@forward;
	procedure c_putc( c:char );					@external( "_c_putc" );
	procedure c_puts( s:string );				@external( "_c_puts" );
	procedure c_putu32( u:uns32 );				@external( "_c_putu32" );
	procedure c_puth32( d:dword );  			@external( "_c_puth32" );
	procedure c_newln;							@external( "_c_newln" );
	procedure c_putBuf( buf:dword; size:dword);	@external( "_c_putbuf" );
	
	procedure putc( c:char );
	begin putc;
	
		pushad();
		push( (type dword [esp+9*4]));
		call c_putc;
		add( 4, esp );
		popad();
		ret(4);
		
	end putc;
	
	
	procedure puts( s:string );
	begin puts;
	
		pushad();
		push( (type dword [esp+9*4]));
		call c_puts;
		add( 4, esp );
		popad();
		ret(4);
		
	end puts;
	
	
	procedure putu32( u:uns32 );
	begin putu32;
	
		pushad();
		push( (type dword [esp+9*4]));
		call c_putu32;
		add( 4, esp );
		popad();
		ret(4);
		
	end putu32;
	
	
	procedure puthex32( d:dword );
	begin puthex32;
	
		pushad();
		push( (type dword [esp+9*4]));
		call c_puth32;
		add( 4, esp );
		popad();
		ret(4);
		
	end puthex32;
	
	procedure put_newln;
	begin put_newln;
	
		pushad();
		call c_newln;
		popad();
		ret();
	
	end put_newln;
	
	procedure putBuf( buf:dword; size:dword);
	begin putBuf;
	
	
		pushad();
		push( (type dword [esp+9*4]));
		push( (type dword [esp+11*4]));
		call c_putBuf;
		add( 8, esp );
		popad();
		ret(8);
		
	end putBuf;
	
	
		

#endif

storage(16)

	// This must appear at the beginning of the BSS block.
	// The code will zero out memory from this point to
	// "endOfBSS". Of course, the OS will zero this memory
	// when it loads the file, however, when not operating
	// in standalone mode, it is possible for this code to
	// be called multiple times and we need to initialize
	// the BSS section on each invocation.
	
	startOfBSS						:byte; @nostorage;
	
		hashTable						:dword[65536];
		stack							:dword[65536 div 4];
		saved_Stack_Pointer				:dword;
		
		#if( !standalone )
		
			C_memory					:dword;
			C_memsize					:dword;
						
		#endif
		#if( @defined( unix ) )
		
			ExceptionPtr:dword; @external( "ExceptionPtr__hla_" );
			ExceptionPtr				:dword;

		#endif
		
		org_origin						:qword;
		value							:qword;
		adjustment						:qword;

		bytes_count						:dword;
		displayed_count					:dword;
		memory_start					:dword;
		memory_end						:dword;
		additional_memory				:dword;
		additional_memory_end			:dword;
		stack_limit						:dword;
		input_file						:dword;
		output_file						:dword;
		include_paths					:dword;
		free_additional_memory			:dword;
		source_start					:dword;
		code_start						:dword;
		code_size						:dword;
		real_code_size					:dword;
		written_size					:dword;
		headers_size					:dword;
		current_line					:dword;
		macro_line						:dword;
		macro_block						:dword;
		macro_block_line				:dword;
		macro_block_line_number			:dword;
		macro_symbols					:dword;
		struc_name						:dword;
		struc_label						:dword;
		instant_macro_start				:dword;
		parameters_end					:dword;
		current_locals_prefix			:dword;
		anonymous_reverse				:dword;
		anonymous_forward				:dword;
		labels_list						:dword;
		label_hash						:dword;
		label_leaf						:dword;
		hash_tree						:dword;
		org_registers					:dword;
		org_start						:dword;
		org_symbol						:dword;
		undefined_data_start			:dword;
		undefined_data_end				:dword;
		counter							:dword;
		counter_limit					:dword;
		error_line						:dword;
		error							:dword;
		display_buffer					:dword;
		structures_buffer				:dword;
		number_start					:dword;
		current_offset					:dword;
		fp_value						:dword[8];
		symbol_identifier				:dword;
		address_symbol					:dword;
		address_high					:dword;
		format_flags					:dword;
		symbols_stream					:dword;
		number_of_relocations			:dword;
		number_of_sections				:dword;
		stub_size						:dword;
		stub_file						:dword;
		current_section					:dword;
		subsystem_version				:dword;
		image_base						:dword;
		image_base_high					:dword;
		resource_data					:dword;
		resource_size					:dword;
		parenthesis_stack				:dword;
		blocks_stack					:dword;
		memory_setting					:dword;
		start_time						:dword;
		
		passes_limit					:word;
		current_pass					:word;
		machine							:word;
		subsystem						:word;
		

		g_verbose						:boolean;
		next_pass_needed				:byte;
		macro_status					:byte;
		output_format					:byte;
		code_type						:byte;
		labels_type						:byte;
		prefixed_instruction			:byte;
		virtual_data					:byte;
		fp_sign							:byte;
		fp_format						:byte;
		value_size						:byte;
		size_override					:byte;
		address_size					:byte;
		operand_size					:byte;
		size_declared					:byte;
		value_undefined					:byte;
		value_type						:byte;
		compare_type					:byte;
		base_code						:byte;
		extended_code					:byte;
		postbyte_register				:byte;
		segment_register				:byte;
		mmx_size						:byte;
		jump_type						:byte;
		push_size						:byte;
		operand_prefix					:byte;
		rex_prefix						:byte;
		immediate_size					:byte;
		converted						:byte[$100];
		params							:byte[$1000];
		buffer							:byte[$4000];

		character						:byte;
		last_displayed					:byte[2];
	
	
	// This must appear at the end of the BSS section!
	
	endOfBSS						:dword;





static(16)

	locals_counter					:byte[8]; @nostorage;
										byte 7, "0000000";
									
	
	error_prefix 					:byte; @nostorage;
										byte "error: ",0;
										
	error_suffix 					:byte; @nostorage;
										byte ".";
										
	cr_lf 							:byte; @nostorage;
										byte cr,lf,0;
										
	line_number_start 				:byte; @nostorage;
										byte " [",0;
										
	line_data_start 				:byte; @nostorage;
										byte ":",cr,lf,0;
										
	_copyright 						:byte; @nostorage;
		byte "Copyright (c) 1999-2005, Tomasz Grysztar",cr,lf,0;
	
	_logo 							:byte; @nostorage;
		byte "flat assembler  version ",VERSION_STRING,cr,lf,0;
	
	_usage 							:byte; @nostorage;
		byte "usage: fasm source [output]",cr,lf,0;
	
  
  
	include_variable 				:byte; @nostorage;
										byte "INCLUDE",0;
										
										
 
 
  
 val
 	characters_c	:byte[$100];
	#for( _i_ := 0 to 255 )
	
		characters_c[_i_] := @char( @lowercase( @char(_i_), 0 ));
		
	#endfor;
	
	symbol_chars_cset	:cset := 
		{#9,#$0A,#$0D,char(lenStrTkn)," +-/*=<>()[]{}:,|&~#`;"};
		
	char_c				:char;
	#for( char_c in symbol_chars_cset )
	
		characters_c[ @uns8( char_c )] := 0;
		
	#endfor
	
	
static
	clearedBSS	:boolean := true;
	characters	:byte[$100] := characters_c;
  
  
  
  operators:byte; @nostorage;
		byte 1,"+",$80;
		byte 1,"-",$81;
		byte 1,"*",$90;
		byte 1,"/",$91;
		byte 3,"mod",$0A0;
		byte 3,"and",$0B0;
		byte 2,"or",$0B1;
		byte 3,"xor",$0B2;
		byte 3,"shl",$0C0;
		byte 3,"shr",$0C1;
		byte 0;

  single_operand_operators:byte; @nostorage;
		byte 1,"+",0;
		byte 1,"-",$083;
		byte 3,"not",$0D0;
		byte 3,"rva",$0E0;
		byte 0;


  directive_operators:byte; @nostorage;
		byte 2,"as",$86;
		byte 2,"at",$80;
		byte 7,"defined",$88;
		byte 3,"dup",$81;
		byte 2,"eq",$0F0;
		byte 6,"eqtype",$0F7;
		byte 4,"from",$82;
		byte 2,"in",$0F6;
		byte 2,"on",$84;
		byte 3,"ptr",$85;
		byte 4,"used",$89;
		byte 0;

  formatter_symbols:byte; @nostorage;
		byte 5,"align",$1C,0;
		byte 6,"binary",$18,$10;
		byte 3,"bss",$19,7;
		byte 4,"code",$19,5;
		byte 4,"coff",$18,$40;
		byte 7,"console",$1B,3;
		byte 4,"data",$19,6;
		byte 11,"discardable",$19,25;
		byte 3,"dll",$1B,$80;
		byte 3,"elf",$18,$50;
		byte 5,"elf64",$18,$58;
		byte 10,"executable",$19,29;
		byte 6,"export",$1A,0;
		byte 6,"fixups",$1A,5;
		byte 3,"gui",$1B,2;
		byte 6,"import",$1A,1;
		byte 8,"linkinfo",$19,9;
		byte 10,"linkremove",$19,11;
		byte 2,"ms",$17,$41;
		byte 4,"ms64",$17,$49;
		byte 2,"mz",$18,' ';
		byte 6,"native",$1B,1;
		byte 11,"notpageable",$19,27;
		byte 2,"pe",$18,$30;
		byte 4,"pe64",$18,$38;
		byte 8,"readable",$19,30;
		byte 8,"resource",$1A,2;
		byte 9,"shareable",$19,28;
		byte 3,"wdm",$1B,$81;
		byte 8,"writable",$19,31;
		byte 9,"writeable",$19,31;
		byte 0;

  address_registers:byte; @nostorage;
		byte 2,"bp",0,$25;
		byte 2,"bx",0,$23;
		byte 2,"di",0,$27;
		byte 3,"eax",0,$40;
		byte 3,"ebp",0,$45;
		byte 3,"ebx",0,$43;
		byte 3,"ecx",0,$41;
		byte 3,"edi",0,$47;
		byte 3,"edx",0,$42;
		byte 3,"esi",0,$46;
		byte 3,"esp",0,$44;
		byte 3,"r10",0,$8A;
		byte 4,"r10d",0,$4A;
		byte 3,"r11",0,$8B;
		byte 4,"r11d",0,$4B;
		byte 3,"r12",0,$8C;
		byte 4,"r12d",0,$4C;
		byte 3,"r13",0,$8D;
		byte 4,"r13d",0,$4D;
		byte 3,"r14",0,$8E;
		byte 4,"r14d",0,$4E;
		byte 3,"r15",0,$8F;
		byte 4,"r15d",0,$4F;
		byte 2,"r8",0,$88;
		byte 3,"r8d",0,$48;
		byte 2,"r9",0,$89;
		byte 3,"r9d",0,$49;
		byte 3,"rax",0,$80;
		byte 3,"rbp",0,$85;
		byte 3,"rbx",0,$83;
		byte 3,"rcx",0,$81;
		byte 3,"rdi",0,$87;
		byte 3,"rdx",0,$82;
		byte 3,"rip",0,$0F0;
		byte 3,"rsi",0,$86;
		byte 3,"rsp",0,$84;
		byte 2,"si",0,$26;
		byte 0;


  address_sizes:byte; @nostorage;
		byte 4,"byte",0,1;
		byte 5,"dword",0,4;
		byte 5,"qword",0,8;
		byte 4,"word",0,2;
		byte 0;

  symbols:byte; @nostorage;
		byte 2,"ah",$10,$04;
		byte 2,"al",$10,$10;
		byte 2,"ax",$10,$20;
		byte 2,"bh",$10,$07;
		byte 2,"bl",$10,$13;
		byte 2,"bp",$10,$25;
		byte 3,"bpl",$10,$15;
		byte 2,"bx",$10,$23;
		byte 4,"byte",$11,1;
		byte 2,"ch",$10,$05;
		byte 2,"cl",$10,$11;
		byte 3,"cr0",$10,$50;
		byte 3,"cr1",$10,$51;
		byte 3,"cr2",$10,$52;
		byte 3,"cr3",$10,$53;
		byte 3,"cr4",$10,$54;
		byte 3,"cr5",$10,$55;
		byte 3,"cr6",$10,$56;
		byte 3,"cr7",$10,$57;
		byte 3,"cr8",$10,$58;
		byte 3,"cr9",$10,$59;
		byte 4,"cr10",$10,$5A;
		byte 4,"cr11",$10,$5B;
		byte 4,"cr12",$10,$5C;
		byte 4,"cr13",$10,$5D;
		byte 4,"cr14",$10,$5E;
		byte 4,"cr15",$10,$5F;
		byte 2,"cs",$10,$62;
		byte 2,"cx",$10,$21;
		byte 2,"dh",$10,$06;
		byte 2,"di",$10,$27;
		byte 3,"dil",$10,$17;
		byte 2,"dl",$10,$12;
		byte 6,"dqword",$11,16;
		byte 3,"dr0",$10,$70;
		byte 3,"dr1",$10,$71;
		byte 3,"dr2",$10,$72;
		byte 3,"dr3",$10,$73;
		byte 3,"dr4",$10,$74;
		byte 3,"dr5",$10,$75;
		byte 3,"dr6",$10,$76;
		byte 3,"dr7",$10,$77;
		byte 3,"dr8",$10,$78;
		byte 3,"dr9",$10,$79;
		byte 4,"dr10",$10,$7A;
		byte 4,"dr11",$10,$7B;
		byte 4,"dr12",$10,$7C;
		byte 4,"dr13",$10,$7D;
		byte 4,"dr14",$10,$7E;
		byte 4,"dr15",$10,$7F;
		byte 2,"ds",$10,$64;
		byte 5,"dword",$11,4;
		byte 2,"dx",$10,$22;
		byte 3,"eax",$10,$40;
		byte 3,"ebp",$10,$45;
		byte 3,"ebx",$10,$43;
		byte 3,"ecx",$10,$41;
		byte 3,"edi",$10,$47;
		byte 3,"edx",$10,$42;
		byte 2,"es",$10,$61;
		byte 3,"esi",$10,$46;
		byte 3,"esp",$10,$44;
		byte 3,"far",$12,3;
		byte 2,"fs",$10,$65;
		byte 5,"fword",$11,6;
		byte 2,"gs",$10,$66;
		byte 3,"mm0",$10,$0B0;
		byte 3,"mm1",$10,$0B1;
		byte 3,"mm2",$10,$0B2;
		byte 3,"mm3",$10,$0B3;
		byte 3,"mm4",$10,$0B4;
		byte 3,"mm5",$10,$0B5;
		byte 3,"mm6",$10,$0B6;
		byte 3,"mm7",$10,$0B7;
		byte 4,"near",$12,2;
		byte 5,"pword",$11,6;
		byte 5,"qword",$11,8;
		byte 3,"r10",$10,$8A;
		byte 4,"r10b",$10,$1A;
		byte 4,"r10d",$10,$4A;
		byte 4,"r10w",$10,$2A;
		byte 3,"r11",$10,$8B;
		byte 4,"r11b",$10,$1B;
		byte 4,"r11d",$10,$4B;
		byte 4,"r11w",$10,$2B;
		byte 3,"r12",$10,$8C;
		byte 4,"r12b",$10,$1C;
		byte 4,"r12d",$10,$4C;
		byte 4,"r12w",$10,$2C;
		byte 3,"r13",$10,$8D;
		byte 4,"r13b",$10,$1D;
		byte 4,"r13d",$10,$4D;
		byte 4,"r13w",$10,$2D;
		byte 3,"r14",$10,$8E;
		byte 4,"r14b",$10,$1E;
		byte 4,"r14d",$10,$4E;
		byte 4,"r14w",$10,$2E;
		byte 3,"r15",$10,$8F;
		byte 4,"r15b",$10,$1F;
		byte 4,"r15d",$10,$4F;
		byte 4,"r15w",$10,$2F;
		byte 2,"r8",$10,$88;
		byte 3,"r8b",$10,$18;
		byte 3,"r8d",$10,$48;
		byte 3,"r8w",$10,$28;
		byte 2,"r9",$10,$89;
		byte 3,"r9b",$10,$19;
		byte 3,"r9d",$10,$49;
		byte 3,"r9w",$10,$29;
		byte 3,"rax",$10,$80;
		byte 3,"rbp",$10,$85;
		byte 3,"rbx",$10,$83;
		byte 3,"rcx",$10,$81;
		byte 3,"rdi",$10,$87;
		byte 3,"rdx",$10,$82;
		byte 3,"rsi",$10,$86;
		byte 3,"rsp",$10,$84;
		byte 5,"short",$12,1;
		byte 2,"si",$10,$26;
		byte 3,"sil",$10,$16;
		byte 2,"sp",$10,$24;
		byte 3,"spl",$10,$14;
		byte 2,"ss",$10,$63;
		byte 2,"st",$10,$0A0;
		byte 3,"st0",$10,$0A0;
		byte 3,"st1",$10,$0A1;
		byte 3,"st2",$10,$0A2;
		byte 3,"st3",$10,$0A3;
		byte 3,"st4",$10,$0A4;
		byte 3,"st5",$10,$0A5;
		byte 3,"st6",$10,$0A6;
		byte 3,"st7",$10,$0A7;
		byte 5,"tbyte",$11,$0A;
		byte 3,"tr0",$10,$90;
		byte 3,"tr1",$10,$91;
		byte 3,"tr2",$10,$92;
		byte 3,"tr3",$10,$93;
		byte 3,"tr4",$10,$94;
		byte 3,"tr5",$10,$95;
		byte 3,"tr6",$10,$96;
		byte 3,"tr7",$10,$97;
		byte 5,"tword",$11,$0A;
		byte 5,"use16",$13,16;
		byte 5,"use32",$13,32;
		byte 5,"use64",$13,64;
		byte 4,"word",$11,2;
		byte 4,"xmm0",$10,$0C0;
		byte 4,"xmm1",$10,$0C1;
		byte 5,"xmm10",$10,$0CA;
		byte 5,"xmm11",$10,$0CB;
		byte 5,"xmm12",$10,$0CC;
		byte 5,"xmm13",$10,$0CD;
		byte 5,"xmm14",$10,$0CE;
		byte 5,"xmm15",$10,$0CF;
		byte 4,"xmm2",$10,$0C2;
		byte 4,"xmm3",$10,$0C3;
		byte 4,"xmm4",$10,$0C4;
		byte 4,"xmm5",$10,$0C5;
		byte 4,"xmm6",$10,$0C6;
		byte 4,"xmm7",$10,$0C7;
		byte 4,"xmm8",$10,$0C8;
		byte 4,"xmm9",$10,$0C9;
		byte 0;
  
  data_directives:byte; @nostorage;
		byte 2,"db",1,0;
		byte 2,"dd",4,6;
		byte 2,"df",6,8;
		byte 2,"dp",6,8;
		byte 2,"dq",8,10;
		byte 2,"dt",10,12;
		byte 2,"du",2,4;
		byte 2,"dw",2,3;
		byte 4,"file",1,1;
		byte 2,"rb",1,2;
		byte 2,"rd",4,7;
		byte 2,"rf",6,9;
		byte 2,"rp",6,9;
		byte 2,"rq",8,11;
		byte 2,"rt",10,13;
		byte 2,"rw",2,5;
		byte 0;


  // instrPtrs-
  //	Table of addresses that point at the handlers
  //	for the particular instructions.
  
  ?instrIndex := 0;
  #macro instrptr( instr );
  
  	?@text( @string(instr) +  "_index") := instrIndex;
	?instrIndex := instrIndex + 1;
	dword &instr	
  
  #endmacro
  
  instrHandlerPtrs:dword; @nostorage;

  	instrptr( aa_instruction );
  	instrptr( align_directive );
  	instrptr( amd3dnow_instruction );
  	instrptr( amd_prefetch_instruction );
  	instrptr( arpl_instruction );
  	instrptr( basic_486_instruction );
  	instrptr( basic_fpu_instruction );
  	instrptr( basic_instruction );
  	instrptr( bound_instruction );
  	instrptr( break_directive );
  	instrptr( bs_instruction );
  	instrptr( bswap_instruction );
  	instrptr( bt_instruction );
  	instrptr( call_instruction );
  	instrptr( cmov_instruction );
  	instrptr( cmp_pd_instruction );
  	instrptr( cmp_ps_instruction );
  	instrptr( cmp_sd_instruction );
  	instrptr( cmp_ss_instruction );
  	instrptr( cmppd_instruction );
  	instrptr( cmpps_instruction );
  	instrptr( cmps_instruction );
  	instrptr( cmpsd_instruction );
  	instrptr( cmpss_instruction );
  	instrptr( cmpxchgx_instruction );
  	instrptr( comisd_instruction );
  	instrptr( comiss_instruction );
  	instrptr( conditional_jump );
  	instrptr( cvtdq2pd_instruction );
  	instrptr( cvtpd2dq_instruction );
  	instrptr( cvtpd2pi_instruction );
  	instrptr( cvtpi2pd_instruction );
  	instrptr( cvtpi2ps_instruction );
  	instrptr( cvtps2pd_instruction );
  	instrptr( cvtps2pi_instruction );
  	instrptr( cvtsd2si_instruction );
  	instrptr( cvtsi2sd_instruction );
  	instrptr( cvtsi2ss_instruction );
  	instrptr( cvtss2si_instruction );
	instrptr( data_bytes );
  	instrptr( data_directive );
	instrptr( data_file );
	instrptr( data_dwords );
	instrptr( data_pwords );
	instrptr( data_qwords );
	instrptr( data_twords );
	instrptr( data_unicode );
	instrptr( data_words );
  	instrptr( display_directive );
  	instrptr( else_directive );
  	instrptr( end_directive );
  	instrptr( enter_instruction );
  	instrptr( entry_directive );
  	instrptr( extrn_directive );
  	instrptr( faddp_instruction );
  	instrptr( fbld_instruction );
  	instrptr( fcmov_instruction );
  	instrptr( fcomi_instruction );
  	instrptr( fcomip_instruction );
  	instrptr( fcompp_instruction );
  	instrptr( fence_instruction );
  	instrptr( ffree_instruction );
  	instrptr( ffreep_instruction );
  	instrptr( fi_instruction );
  	instrptr( fild_instruction );
  	instrptr( finit_instruction );
  	instrptr( fld_instruction );
  	instrptr( fldcw_instruction );
  	instrptr( fldenv_instruction );
  	instrptr( fninit_instruction );
  	instrptr( fnsave_instruction );
  	instrptr( fnstsw_instruction );
  	instrptr( format_directive );
  	instrptr( fsave_instruction );
  	instrptr( fstcw_instruction );
  	instrptr( fstsw_instruction );
  	instrptr( fstenv_instruction );
  	instrptr( fucompp_instruction );
  	instrptr( fxsave_instruction );
  	instrptr( fxch_instruction );
  	instrptr( heap_directive );
  	instrptr( if_directive );
  	instrptr( imul_instruction );
  	instrptr( in_instruction );
  	instrptr( inc_instruction );
  	instrptr( ins_instruction );
  	instrptr( int_instruction );
  	instrptr( invlpg_instruction );
  	instrptr( iret_instruction );
  	instrptr( jmp_instruction );
  	instrptr( label_directive );
  	instrptr( lar_instruction );
  	instrptr( lddqu_instruction );
  	instrptr( lea_instruction );
  	instrptr( lgdt_instruction );
  	instrptr( load_directive );
  	instrptr( lods_instruction );
  	instrptr( loop_instruction );
  	instrptr( loop_instruction_16bit );
  	instrptr( loop_instruction_32bit );
  	instrptr( loop_instruction_64bit );
  	instrptr( ls_instruction );
  	instrptr( maskmovq_instruction );
  	instrptr( maskmovdqu_instruction );
  	instrptr( mmx_instruction );
  	instrptr( mmx_ps_instruction );
  	instrptr( monitor_instruction );
  	instrptr( mov_instruction );
  	instrptr( movd_instruction );
  	instrptr( movdq_instruction );
  	instrptr( movdq2q_instruction );
  	instrptr( movhlps_instruction );
  	instrptr( movlpd_instruction );
  	instrptr( movlps_instruction );
  	instrptr( movmskpd_instruction );
  	instrptr( movmskps_instruction );
  	instrptr( movnti_instruction );
  	instrptr( movntq_instruction );
  	instrptr( movntdq_instruction );
  	instrptr( movntps_instruction );
  	instrptr( movpd_instruction );
  	instrptr( movps_instruction );
  	instrptr( movq_instruction );
  	instrptr( movq2dq_instruction );
  	instrptr( movs_instruction );
  	instrptr( movsd_instruction );
  	instrptr( movss_instruction );
  	instrptr( movsxd_instruction );
  	instrptr( movx_instruction );
  	instrptr( org_directive );
  	instrptr( out_instruction );
  	instrptr( outs_instruction );
  	instrptr( pause_instruction );
  	instrptr( pextrw_instruction );
  	instrptr( pinsrw_instruction );
  	instrptr( pm_store_word_instruction );
  	instrptr( pm_word_instruction );
  	instrptr( pop_instruction );
  	instrptr( prefetch_instruction );
  	instrptr( prefix_instruction );
  	instrptr( pshufd_instruction );
  	instrptr( pshufw_instruction );
  	instrptr( ps_dq_instruction );
  	instrptr( ps_dq_instruction );
  	instrptr( public_directive );
  	instrptr( push_instruction );
  	instrptr( repeat_directive );
  	instrptr( reserve_bytes );
  	instrptr( reserve_dwords );
  	instrptr( reserve_pwords );
  	instrptr( reserve_qwords );
  	instrptr( reserve_twords );
  	instrptr( reserve_words );
  	instrptr( ret_instruction );
  	instrptr( ret_instruction_16bit );
  	instrptr( ret_instruction_32bit );
  	instrptr( ret_instruction_32bit_except64 );
  	instrptr( ret_instruction_64bit );
  	instrptr( ret_instruction_only64 );
  	instrptr( retf_instruction );
  	instrptr( retf_instruction );
  	instrptr( section_directive );
  	instrptr( segment_directive );
  	instrptr( set_instruction );
  	instrptr( sh_instruction );
  	instrptr( shd_instruction );
  	instrptr( simple_extended_instruction );
  	instrptr( simple_fpu_instruction );
  	instrptr( simple_instruction );
  	instrptr( simple_instruction_16bit );
  	instrptr( simple_instruction_16bit_except64 );
  	instrptr( simple_instruction_32bit );
  	instrptr( simple_instruction_32bit_except64 );
  	instrptr( simple_instruction_64bit );
  	instrptr( simple_instruction_except64 );
  	instrptr( simple_instruction_only64 );
  	instrptr( simple_vmx_instruction );
  	instrptr( single_operand_instruction );
  	instrptr( sse_pd_instruction );
  	instrptr( sse_ps_instruction );
  	instrptr( sse_sd_instruction );
  	instrptr( sse_ss_instruction );
  	instrptr( stack_directive );
  	instrptr( store_directive );
  	instrptr( stos_instruction );
  	instrptr( swapgs_instruction );
  	instrptr( test_instruction );
  	instrptr( times_directive );
  	instrptr( virtual_directive );
  	instrptr( vmclear_instruction );
  	instrptr( vmread_instruction );
  	instrptr( vmwrite_instruction );
  	instrptr( vmx_instruction );
  	instrptr( vmxon_instruction );
  	instrptr( while_directive );
  	instrptr( xchg_instruction );
  	instrptr( xlat_instruction );
	

  data_handlers:dword; @nostorage;
		dword data_bytes_index;
		dword data_file_index;
		dword reserve_bytes_index;
		dword data_words_index;
		dword data_unicode_index;
		dword reserve_words_index;
		dword data_dwords_index;
		dword reserve_dwords_index;
		dword data_pwords_index;
		dword reserve_pwords_index;
		dword data_qwords_index;
		dword reserve_qwords_index;
		dword data_twords_index;
		dword reserve_twords_index;
		
  if_directive_assembler		:word := if_directive_index;
  repeat_directive_assembler	:word := repeat_directive_index;
  while_directive_assembler		:word := while_directive_index;
  end_directive_assembler		:word := end_directive_index;
  else_directive_assembler		:word := else_directive_index;
  prefix_instruction_assembler	:word := prefix_instruction_index;
  times_directive_assembler		:word := times_directive_index;
  label_directive_assembler		:word := label_directive_index;
  segment_directive_assembler	:word := segment_directive_index;
  load_directive_assembler		:word := load_directive_index;
  extrn_directive_assembler		:word := extrn_directive_index;
  public_directive_assembler	:word := public_directive_index;
  virtual_directive_assembler	:word := virtual_directive_index;								
  data_directive_assembler		:word := data_directive_index;



	
		
  


	
  
  instructions:dword; @nostorage;
		dword &instructions_2;
		dword &instructions_3;
		dword &instructions_4;
		dword &instructions_5;
		dword &instructions_6;
		dword &instructions_7;
		dword &instructions_8;
		dword &instructions_9;
		dword &instructions_10;
		dword &instructions_11;

  #macro instr_t(strng,code,adrs);
  
  	byte strng,code;
	dword adrs;
	
  #endmacro
  

	// Two-character mnemonics.
	// Must be in alphabetical order.
	
  instructions_2:byte; @nostorage;
  		instr_t( "bt", 4, bt_instruction_index );
  		instr_t( "if", 0, if_directive_index );
  		instr_t( "in", 0, in_instruction_index );
  		instr_t( "ja", $77, conditional_jump_index );
  		instr_t( "jb", $72, conditional_jump_index );
  		instr_t( "jc", $72, conditional_jump_index );
  		instr_t( "je", $74, conditional_jump_index );
  		instr_t( "jg", $7f, conditional_jump_index );
  		instr_t( "jl", $7c, conditional_jump_index );
  		instr_t( "jo", $70, conditional_jump_index );
  		instr_t( "jp", $7A, conditional_jump_index );
  		instr_t( "js", $78, conditional_jump_index );
  		instr_t( "jz", $74, conditional_jump_index );
  		instr_t( "or", $08, basic_instruction_index );
		byte 0;

  instructions_3:byte; @nostorage;
  		instr_t( "aaa", $37, simple_instruction_except64_index );
  		instr_t( "aad", $d5, aa_instruction_index );
  		instr_t( "aam", $d4, aa_instruction_index );
  		instr_t( "aas", $3f, simple_instruction_except64_index );
  		instr_t( "adc", $10, basic_instruction_index );
  		instr_t( "add", $00, basic_instruction_index );
  		instr_t( "and", $20, basic_instruction_index );
  		instr_t( "bsf", $0BC, bs_instruction_index );
  		instr_t( "bsr", $0BD, bs_instruction_index );
  		instr_t( "btc", $07, bt_instruction_index );
  		instr_t( "btr", $06, bt_instruction_index );
  		instr_t( "bts", $05, bt_instruction_index );
  		instr_t( "cbw", $98, simple_instruction_16bit_index );
  		instr_t( "cdq", $99, simple_instruction_32bit_index );
		instr_t( "clc", $0F8, simple_instruction_index );
		instr_t( "cld", $0FC, simple_instruction_index );
		instr_t( "cli", $0FA, simple_instruction_index );
		instr_t( "cmc", $0F5, simple_instruction_index );
		instr_t( "cmp", $38, basic_instruction_index );
		instr_t( "cqo", $99, simple_instruction_64bit_index );
		instr_t( "cwd", $99, simple_instruction_16bit_index );
		instr_t( "daa", $27, simple_instruction_except64_index );
		instr_t( "das", $2F, simple_instruction_except64_index );
		instr_t( "dec", 1, inc_instruction_index );
		instr_t( "div", 6, single_operand_instruction_index );
		instr_t( "end", 0, end_directive_index );
		instr_t( "fld", 0, fld_instruction_index );
		instr_t( "fst", 2, fld_instruction_index );
		instr_t( "hlt", $0F4, simple_instruction_index );
		instr_t( "inc", 0, inc_instruction_index );
		instr_t( "ins", $6C, ins_instruction_index );
		instr_t( "int", $0CD, int_instruction_index );
		instr_t( "jae", $73, conditional_jump_index );
		instr_t( "jbe", $76, conditional_jump_index );
		instr_t( "jge", $7D, conditional_jump_index );
		instr_t( "jle", $7E, conditional_jump_index );
		instr_t( "jmp", 0, jmp_instruction_index );
		instr_t( "jna", $76, conditional_jump_index );
		instr_t( "jnb", $73, conditional_jump_index );
		instr_t( "jnc", $73, conditional_jump_index );
		instr_t( "jne", $75, conditional_jump_index );
		instr_t( "jng", $7E, conditional_jump_index );
		instr_t( "jnl", $7D, conditional_jump_index );
		instr_t( "jno", $71, conditional_jump_index );
		instr_t( "jnp", $7B, conditional_jump_index );
		instr_t( "jns", $79, conditional_jump_index );
		instr_t( "jnz", $75, conditional_jump_index );
		instr_t( "jpe", $7A, conditional_jump_index );
		instr_t( "jpo", $7B, conditional_jump_index );
		instr_t( "lar", 2, lar_instruction_index );
		instr_t( "lds", 3, ls_instruction_index );
		instr_t( "lea", 0, lea_instruction_index );
		instr_t( "les", 0, ls_instruction_index );
		instr_t( "lfs", 4, ls_instruction_index );
		instr_t( "lgs", 5, ls_instruction_index );
		instr_t( "lsl", 3, lar_instruction_index );
		instr_t( "lss", 2, ls_instruction_index );
		instr_t( "ltr", 3, pm_word_instruction_index );
		instr_t( "mov", 0, mov_instruction_index );
		instr_t( "mul", 4, single_operand_instruction_index );
		instr_t( "neg", 3, single_operand_instruction_index );
		instr_t( "nop", $90, simple_instruction_index );
		instr_t( "not", 2, single_operand_instruction_index );
		instr_t( "org", 0, org_directive_index );
		instr_t( "out", 0, out_instruction_index );
		instr_t( "pop", 0, pop_instruction_index );
		instr_t( "por", $0EB, mmx_instruction_index );
		instr_t( "rcl", 2, sh_instruction_index );
		instr_t( "rcr", 3, sh_instruction_index );
		instr_t( "rep", $0F3, prefix_instruction_index );
		instr_t( "ret", $0C2, ret_instruction_index );
		instr_t( "rol", 0, sh_instruction_index );
		instr_t( "ror", 1, sh_instruction_index );
		instr_t( "rsm", $0AA, simple_extended_instruction_index );
		instr_t( "sal", 4, sh_instruction_index );
		instr_t( "sar", 7, sh_instruction_index );
		instr_t( "sbb", $18, basic_instruction_index );
		instr_t( "shl", 4, sh_instruction_index );
		instr_t( "shr", 5, sh_instruction_index );
		instr_t( "stc", $0F9, simple_instruction_index );
		instr_t( "std", $0FD, simple_instruction_index );
		instr_t( "sti", $0FB, simple_instruction_index );
		instr_t( "str", 1, pm_store_word_instruction_index );
		instr_t( "sub", $28, basic_instruction_index );
		instr_t( "ud2", $0B, simple_extended_instruction_index );
		instr_t( "xor", $30, basic_instruction_index );
		byte 0;

  instructions_4:byte; @nostorage;
		instr_t( "arpl", 0, arpl_instruction_index );
		instr_t( "call", 0, call_instruction_index );
		instr_t( "cdqe", $98, simple_instruction_64bit_index );
		instr_t( "clts", 6, simple_extended_instruction_index );
		instr_t( "cmps", $0A6, cmps_instruction_index );
		instr_t( "cwde", $98, simple_instruction_32bit_index );
		instr_t( "data", 0, data_directive_index );
		instr_t( "else", 0, else_directive_index );
		instr_t( "emms", $77, simple_extended_instruction_index );
		instr_t( "fabs", %100001, simple_fpu_instruction_index );
		instr_t( "fadd", 0, basic_fpu_instruction_index );
		instr_t( "fbld", 4, fbld_instruction_index );
		instr_t( "fchs", %100000, simple_fpu_instruction_index );
		instr_t( "fcom", 2, basic_fpu_instruction_index );
		instr_t( "fcos", %111111, simple_fpu_instruction_index );
		instr_t( "fdiv", 6, basic_fpu_instruction_index );
		instr_t( "feni", $0E0, finit_instruction_index );
		instr_t( "fild", 0, fild_instruction_index );
		instr_t( "fist", 2, fild_instruction_index );
		instr_t( "fld1", %101000, simple_fpu_instruction_index );
		instr_t( "fldz", %101110, simple_fpu_instruction_index );
		instr_t( "fmul", 1, basic_fpu_instruction_index );
		instr_t( "fnop", %010000, simple_fpu_instruction_index );
		instr_t( "fsin", %111110, simple_fpu_instruction_index );
		instr_t( "fstp", 3, fld_instruction_index );
		instr_t( "fsub", 4, basic_fpu_instruction_index );
		instr_t( "ftst", %100100, simple_fpu_instruction_index );
		instr_t( "fxam", %100101, simple_fpu_instruction_index );
		instr_t( "fxch", 0, fxch_instruction_index );
		instr_t( "heap", 0, heap_directive_index );
		instr_t( "idiv", 7, single_operand_instruction_index );
		instr_t( "imul", 0, imul_instruction_index );
		instr_t( "insb", $6C, simple_instruction_index );
		instr_t( "insd", $6D, simple_instruction_32bit_index );
		instr_t( "insw", $6D, simple_instruction_16bit_index );
		instr_t( "int1", $0F1, simple_instruction_index );
		instr_t( "int3", $0CC, simple_instruction_index );
		instr_t( "into", $0CE, simple_instruction_except64_index );
		instr_t( "invd", 8, simple_extended_instruction_index );
		instr_t( "iret", $0CF, iret_instruction_index );
		instr_t( "jcxz", $0E3, loop_instruction_16bit_index );
		instr_t( "jnae", $72, conditional_jump_index );
		instr_t( "jnbe", $77, conditional_jump_index );
		instr_t( "jnge", $7C, conditional_jump_index );
		instr_t( "jnle", $7F, conditional_jump_index );
		instr_t( "lahf", $9F, simple_instruction_index );
		instr_t( "lgdt", 2, lgdt_instruction_index );
		instr_t( "lidt", 3, lgdt_instruction_index );
		instr_t( "lldt", 2, pm_word_instruction_index );
		instr_t( "lmsw", $16, pm_word_instruction_index );
		instr_t( "load", 0, load_directive_index );
		instr_t( "lock", $0F0, prefix_instruction_index );
		instr_t( "lods", $0AC, lods_instruction_index );
		instr_t( "loop", $0E2, loop_instruction_index );
		instr_t( "movd", 0, movd_instruction_index );
		instr_t( "movq", 0, movq_instruction_index );
		instr_t( "movs", $0A4, movs_instruction_index );
		instr_t( "orpd", $56, sse_pd_instruction_index );
		instr_t( "orps", $56, sse_ps_instruction_index );
		instr_t( "outs", $6E, outs_instruction_index );
		instr_t( "pand", $0DB, mmx_instruction_index );
		instr_t( "popa", $61, simple_instruction_except64_index );
		instr_t( "popd", 4, pop_instruction_index );
		instr_t( "popf", $9D, simple_instruction_index );
		instr_t( "popq", 8, pop_instruction_index );
		instr_t( "popw", 2, pop_instruction_index );
		instr_t( "push", 0, push_instruction_index );
		instr_t( "pxor", $0EF, mmx_instruction_index );
		instr_t( "repe", $0F3, prefix_instruction_index );
		instr_t( "repz", $0F3, prefix_instruction_index );
		instr_t( "retd", $0C2, ret_instruction_32bit_except64_index );
		instr_t( "retf", $0CA, retf_instruction_index );
		instr_t( "retn", $0C2, ret_instruction_index );
		instr_t( "retq", $0C2, ret_instruction_only64_index );
		instr_t( "retw", $0C2, ret_instruction_16bit_index );
		instr_t( "sahf", $9E, simple_instruction_index );
		instr_t( "salc", $0D6, simple_instruction_except64_index );
		instr_t( "scas", $0AE, stos_instruction_index );
		instr_t( "seta", $97, set_instruction_index );
		instr_t( "setb", $92, set_instruction_index );
		instr_t( "setc", $92, set_instruction_index );
		instr_t( "sete", $94, set_instruction_index );
		instr_t( "setg", $9F, set_instruction_index );
		instr_t( "setl", $9C, set_instruction_index );
		instr_t( "seto", $90, set_instruction_index );
		instr_t( "setp", $9A, set_instruction_index );
		instr_t( "sets", $98, set_instruction_index );
		instr_t( "setz", $94, set_instruction_index );
		instr_t( "sgdt", 0, lgdt_instruction_index );
		instr_t( "shld", $0A4, shd_instruction_index );
		instr_t( "shrd", $0AC, shd_instruction_index );
		instr_t( "sidt", 1, lgdt_instruction_index );
		instr_t( "sldt", 0, pm_store_word_instruction_index );
		instr_t( "smsw", $14, pm_store_word_instruction_index );
		instr_t( "stos", $0AA, stos_instruction_index );
		instr_t( "test", 0, test_instruction_index );
		instr_t( "verr", 4, pm_word_instruction_index );
		instr_t( "verw", 5, pm_word_instruction_index );
		instr_t( "wait", $9B, simple_instruction_index );
		instr_t( "xadd", $0C0, basic_486_instruction_index );
		instr_t( "xchg", 0, xchg_instruction_index );
		instr_t( "xlat", $0D7, xlat_instruction_index );
		byte 0;

  instructions_5:byte; @nostorage;
		instr_t( "addpd", $58, sse_pd_instruction_index );
		instr_t( "addps", $58, sse_ps_instruction_index );
		instr_t( "addsd", $58, sse_sd_instruction_index );
		instr_t( "addss", $58, sse_ss_instruction_index );
		instr_t( "align", 0, align_directive_index );
		instr_t( "andpd", $54, sse_pd_instruction_index );
		instr_t( "andps", $54, sse_ps_instruction_index );
		instr_t( "bound", 0, bound_instruction_index );
		instr_t( "break", 0, break_directive_index );
		instr_t( "bswap", 0, bswap_instruction_index );
		instr_t( "cmova", $47, cmov_instruction_index );
		instr_t( "cmovb", $42, cmov_instruction_index );
		instr_t( "cmovc", $42, cmov_instruction_index );
		instr_t( "cmove", $44, cmov_instruction_index );
		instr_t( "cmovg", $4F, cmov_instruction_index );
		instr_t( "cmovl", $4C, cmov_instruction_index );
		instr_t( "cmovo", $40, cmov_instruction_index );
		instr_t( "cmovp", $4A, cmov_instruction_index );
		instr_t( "cmovs", $48, cmov_instruction_index );
		instr_t( "cmovz", $44, cmov_instruction_index );
		instr_t( "cmppd", 0, cmppd_instruction_index );
		instr_t( "cmpps", 0, cmpps_instruction_index );
		instr_t( "cmpsb", $0A6, simple_instruction_index );
		instr_t( "cmpsd", 0, cmpsd_instruction_index );
		instr_t( "cmpsq", $0A7, simple_instruction_64bit_index );
		instr_t( "cmpss", 0, cmpss_instruction_index );
		instr_t( "cmpsw", $0A7, simple_instruction_16bit_index );
		instr_t( "cpuid", $0A2, simple_extended_instruction_index );
		instr_t( "divpd", $5E, sse_pd_instruction_index );
		instr_t( "divps", $5E, sse_ps_instruction_index );
		instr_t( "divsd", $5E, sse_sd_instruction_index );
		instr_t( "divss", $5E, sse_ss_instruction_index );
		instr_t( "enter", 0, enter_instruction_index );
		instr_t( "entry", 0, entry_directive_index );
		instr_t( "extrn", 0, extrn_directive_index );
		instr_t( "f2xm1", %110000, simple_fpu_instruction_index );
		instr_t( "faddp", 0, faddp_instruction_index );
		instr_t( "fbstp", 6, fbld_instruction_index );
		instr_t( "fclex", $0E2, finit_instruction_index );
		instr_t( "fcomi", $0F0, fcomi_instruction_index );
		instr_t( "fcomp", 3, basic_fpu_instruction_index );
		instr_t( "fdisi", $0E1, finit_instruction_index );
		instr_t( "fdivp", 7, faddp_instruction_index );
		instr_t( "fdivr", 7, basic_fpu_instruction_index );
		instr_t( "femms", $0E, simple_extended_instruction_index );
		instr_t( "ffree", 0, ffree_instruction_index );
		instr_t( "fiadd", 0, fi_instruction_index );
		instr_t( "ficom", 2, fi_instruction_index );
		instr_t( "fidiv", 6, fi_instruction_index );
		instr_t( "fimul", 1, fi_instruction_index );
		instr_t( "finit", $0E3, finit_instruction_index );
		instr_t( "fistp", 3, fild_instruction_index );
		instr_t( "fisub", 4, fi_instruction_index );
		instr_t( "fldcw", 5, fldcw_instruction_index );
		instr_t( "fldpi", %101011, simple_fpu_instruction_index );
		instr_t( "fmulp", 1, faddp_instruction_index );
		instr_t( "fneni", $0E0, fninit_instruction_index );
		instr_t( "fprem", %111000, simple_fpu_instruction_index );
		instr_t( "fptan", %110010, simple_fpu_instruction_index );
		instr_t( "fsave", 6, fsave_instruction_index );
		instr_t( "fsqrt", %111010, simple_fpu_instruction_index );
		instr_t( "fstcw", 7, fstcw_instruction_index );
		instr_t( "fstsw", 0, fstsw_instruction_index );
		instr_t( "fsubp", 5, faddp_instruction_index );
		instr_t( "fsubr", 5, basic_fpu_instruction_index );
		instr_t( "fucom", 4, ffree_instruction_index );
		instr_t( "fwait", $9B, simple_instruction_index );
		instr_t( "fyl2x", %110001, simple_fpu_instruction_index );
		instr_t( "iretd", $0CF, simple_instruction_32bit_index );
		instr_t( "iretq", $0CF, simple_instruction_64bit_index );
		instr_t( "iretw", $0CF, simple_instruction_16bit_index );
		instr_t( "jecxz", $0E3, loop_instruction_32bit_index );
		instr_t( "jrcxz", $0E3, loop_instruction_64bit_index );
		instr_t( "label", 0, label_directive_index );
		instr_t( "lddqu", 0, lddqu_instruction_index );
		instr_t( "leave", $0C9, simple_instruction_index );
		instr_t( "lodsb", $0AC, simple_instruction_index );
		instr_t( "lodsd", $0AD, simple_instruction_32bit_index );
		instr_t( "lodsq", $0AD, simple_instruction_64bit_index );
		instr_t( "lodsw", $0AD, simple_instruction_16bit_index );
		instr_t( "loopd", $0E2, loop_instruction_32bit_index );
		instr_t( "loope", $0E1, loop_instruction_index );
		instr_t( "loopq", $0E2, loop_instruction_64bit_index );
		instr_t( "loopw", $0E2, loop_instruction_16bit_index );
		instr_t( "loopz", $0E1, loop_instruction_index );
		instr_t( "maxpd", $5F, sse_pd_instruction_index );
		instr_t( "maxps", $5F, sse_ps_instruction_index );
		instr_t( "maxsd", $5F, sse_sd_instruction_index );
		instr_t( "maxss", $5F, sse_ss_instruction_index );
		instr_t( "minpd", $5D, sse_pd_instruction_index );
		instr_t( "minps", $5D, sse_ps_instruction_index );
		instr_t( "minsd", $5D, sse_sd_instruction_index );
		instr_t( "minss", $5D, sse_ss_instruction_index );
		instr_t( "movsb", $0A4, simple_instruction_index );
		instr_t( "movsd", 0, movsd_instruction_index );
		instr_t( "movsq", $0A5, simple_instruction_64bit_index );
		instr_t( "movss", 0, movss_instruction_index );
		instr_t( "movsw", $0A5, simple_instruction_16bit_index );
		instr_t( "movsx", $0BE, movx_instruction_index );
		instr_t( "movzx", $0B6, movx_instruction_index );
		instr_t( "mulpd", $59, sse_pd_instruction_index );
		instr_t( "mulps", $59, sse_ps_instruction_index );
		instr_t( "mulsd", $59, sse_sd_instruction_index );
		instr_t( "mulss", $59, sse_ss_instruction_index );
		instr_t( "mwait", $0C9, monitor_instruction_index );
		instr_t( "outsb", $6E, simple_instruction_index );
		instr_t( "outsd", $6F, simple_instruction_32bit_index );
		instr_t( "outsw", $6F, simple_instruction_16bit_index );
		instr_t( "paddb", $0FC, mmx_instruction_index );
		instr_t( "paddd", $0FE, mmx_instruction_index );
		instr_t( "paddq", $0D4, mmx_instruction_index );
		instr_t( "paddw", $0FD, mmx_instruction_index );
		instr_t( "pandn", $0DF, mmx_instruction_index );
		instr_t( "pause", 0, pause_instruction_index );
		instr_t( "pavgb", $0E0, mmx_instruction_index );
		instr_t( "pavgw", $0E3, mmx_instruction_index );
		instr_t( "pf2id", $1D, amd3dnow_instruction_index );
		instr_t( "pf2iw", $1C, amd3dnow_instruction_index );
		instr_t( "pfacc", $0AE, amd3dnow_instruction_index );
		instr_t( "pfadd", $9E, amd3dnow_instruction_index );
		instr_t( "pfmax", $0A4, amd3dnow_instruction_index );
		instr_t( "pfmin", $94, amd3dnow_instruction_index );
		instr_t( "pfmul", $0B4, amd3dnow_instruction_index );
		instr_t( "pfrcp", $96, amd3dnow_instruction_index );
		instr_t( "pfsub", $9A, amd3dnow_instruction_index );
		instr_t( "pi2fd", $0D, amd3dnow_instruction_index );
		instr_t( "pi2fw", $0C, amd3dnow_instruction_index );
		instr_t( "popad", $61, simple_instruction_32bit_except64_index );
		instr_t( "popaw", $61, simple_instruction_16bit_except64_index );
		instr_t( "popfd", $9D, simple_instruction_32bit_except64_index );
		instr_t( "popfw", $9D, simple_instruction_16bit_index );
		instr_t( "popfq", $9D, simple_instruction_only64_index );
		instr_t( "pslld", $0F2, mmx_ps_instruction_index );
		instr_t( "psllq", $0F3, mmx_ps_instruction_index );
		instr_t( "psllw", $0F1, mmx_ps_instruction_index );
		instr_t( "psrad", $0E2, mmx_ps_instruction_index );
		instr_t( "psraw", $0E1, mmx_ps_instruction_index );
		instr_t( "psrld", $0D2, mmx_ps_instruction_index );
		instr_t( "psrlq", $0D3, mmx_ps_instruction_index );
		instr_t( "psrlw", $0D1, mmx_ps_instruction_index );
		instr_t( "psubb", $0F8, mmx_instruction_index );
		instr_t( "psubd", $0FA, mmx_instruction_index );
		instr_t( "psubq", $0FB, mmx_instruction_index );
		instr_t( "psubw", $0F9, mmx_instruction_index );
		instr_t( "pusha", $60, simple_instruction_except64_index );
		instr_t( "pushd", 4, push_instruction_index );
		instr_t( "pushf", $9C, simple_instruction_index );
		instr_t( "pushq", 8, push_instruction_index );
		instr_t( "pushw", 2, push_instruction_index );
		instr_t( "rcpps", $53, sse_ps_instruction_index );
		instr_t( "rcpss", $53, sse_ss_instruction_index );
		instr_t( "rdmsr", $32, simple_extended_instruction_index );
		instr_t( "rdpmc", $33, simple_extended_instruction_index );
		instr_t( "rdtsc", $31, simple_extended_instruction_index );
		instr_t( "repne", $0F2, prefix_instruction_index );
		instr_t( "repnz", $0F2, prefix_instruction_index );
		instr_t( "retfd", $0CA, ret_instruction_32bit_index );
		instr_t( "retfq", $0CA, ret_instruction_64bit_index );
		instr_t( "retfw", $0CA, ret_instruction_16bit_index );
		instr_t( "retnd", $0C2, ret_instruction_32bit_except64_index );
		instr_t( "retnq", $0C2, ret_instruction_only64_index );
		instr_t( "retnw", $0C2, ret_instruction_16bit_index );
		instr_t( "scasb", $0AE, simple_instruction_index );
		instr_t( "scasd", $0AF, simple_instruction_32bit_index );
		instr_t( "scasq", $0AF, simple_instruction_64bit_index );
		instr_t( "scasw", $0AF, simple_instruction_16bit_index );
		instr_t( "setae", $93, set_instruction_index );
		instr_t( "setbe", $96, set_instruction_index );
		instr_t( "setge", $9D, set_instruction_index );
		instr_t( "setle", $9E, set_instruction_index );
		instr_t( "setna", $96, set_instruction_index );
		instr_t( "setnb", $93, set_instruction_index );
		instr_t( "setnc", $93, set_instruction_index );
		instr_t( "setne", $95, set_instruction_index );
		instr_t( "setng", $9E, set_instruction_index );
		instr_t( "setnl", $9D, set_instruction_index );
		instr_t( "setno", $91, set_instruction_index );
		instr_t( "setnp", $9B, set_instruction_index );
		instr_t( "setns", $99, set_instruction_index );
		instr_t( "setnz", $95, set_instruction_index );
		instr_t( "setpe", $9A, set_instruction_index );
		instr_t( "setpo", $9B, set_instruction_index );
		instr_t( "stack", 0, stack_directive_index );
		instr_t( "store", 0, store_directive_index );
		instr_t( "stosb", $0AA, simple_instruction_index );
		instr_t( "stosd", $0AB, simple_instruction_32bit_index );
		instr_t( "stosq", $0AB, simple_instruction_64bit_index );
		instr_t( "stosw", $0AB, simple_instruction_16bit_index );
		instr_t( "subpd", $5C, sse_pd_instruction_index );
		instr_t( "subps", $5C, sse_ps_instruction_index );
		instr_t( "subsd", $5C, sse_sd_instruction_index );
		instr_t( "subss", $5C, sse_ss_instruction_index );
		instr_t( "times", 0, times_directive_index );
		instr_t( "vmxon", 6, vmxon_instruction_index );
		instr_t( "while", 0, while_directive_index );
		instr_t( "wrmsr", $30, simple_extended_instruction_index );
		instr_t( "xlatb", $0D7, simple_instruction_index );
		instr_t( "xorpd", $57, sse_pd_instruction_index );
		instr_t( "xorps", $57, sse_ps_instruction_index );
		byte 0;


  instructions_6:byte; @nostorage;
		instr_t( "andnpd", $55, sse_pd_instruction_index );
		instr_t( "andnps", $55, sse_ps_instruction_index );
		instr_t( "cmovae", $43, cmov_instruction_index );
		instr_t( "cmovbe", $46, cmov_instruction_index );
		instr_t( "cmovge", $4D, cmov_instruction_index );
		instr_t( "cmovle", $4E, cmov_instruction_index );
		instr_t( "cmovna", $46, cmov_instruction_index );
		instr_t( "cmovnb", $43, cmov_instruction_index );
		instr_t( "cmovnc", $43, cmov_instruction_index );
		instr_t( "cmovne", $45, cmov_instruction_index );
		instr_t( "cmovng", $4E, cmov_instruction_index );
		instr_t( "cmovnl", $4D, cmov_instruction_index );
		instr_t( "cmovno", $41, cmov_instruction_index );
		instr_t( "cmovnp", $4B, cmov_instruction_index );
		instr_t( "cmovns", $49, cmov_instruction_index );
		instr_t( "cmovnz", $45, cmov_instruction_index );
		instr_t( "cmovpe", $4A, cmov_instruction_index );
		instr_t( "cmovpo", $4B, cmov_instruction_index );
		instr_t( "comisd", $2F, comisd_instruction_index );
		instr_t( "comiss", $2F, comiss_instruction_index );
		instr_t( "fcmovb", $0C0, fcmov_instruction_index );
		instr_t( "fcmove", $0C8, fcmov_instruction_index );
		instr_t( "fcmovu", $0D8, fcmov_instruction_index );
		instr_t( "fcomip", $0F0, fcomip_instruction_index );
		instr_t( "fcompp", 0, fcompp_instruction_index );
		instr_t( "fdivrp", 6, faddp_instruction_index );
		instr_t( "ffreep", 0, ffreep_instruction_index );
		instr_t( "ficomp", 3, fi_instruction_index );
		instr_t( "fidivr", 7, fi_instruction_index );
		instr_t( "fisttp", 1, fild_instruction_index );
		instr_t( "fisubr", 5, fi_instruction_index );
		instr_t( "fldenv", 4, fldenv_instruction_index );
		instr_t( "fldl2e", %101010, simple_fpu_instruction_index );
		instr_t( "fldl2t", %101001, simple_fpu_instruction_index );
		instr_t( "fldlg2", %101100, simple_fpu_instruction_index );
		instr_t( "fldln2", %101101, simple_fpu_instruction_index );
		instr_t( "fnclex", $0E2, fninit_instruction_index );
		instr_t( "fndisi", $0E1, fninit_instruction_index );
		instr_t( "fninit", $0E3, fninit_instruction_index );
		instr_t( "fnsave", 6, fnsave_instruction_index );
		instr_t( "fnstcw", 7, fldcw_instruction_index );
		instr_t( "fnstsw", 0, fnstsw_instruction_index );
		instr_t( "format", 0, format_directive_index );
		instr_t( "fpatan", %110011, simple_fpu_instruction_index );
		instr_t( "fprem1", %110101, simple_fpu_instruction_index );
		instr_t( "frstor", 4, fnsave_instruction_index );
		instr_t( "frstpm", $0E5, fninit_instruction_index );
		instr_t( "fscale", %111101, simple_fpu_instruction_index );
		instr_t( "fsetpm", $0E4, fninit_instruction_index );
		instr_t( "fstenv", 6, fstenv_instruction_index );
		instr_t( "fsubrp", 4, faddp_instruction_index );
		instr_t( "fucomi", $0E8, fcomi_instruction_index );
		instr_t( "fucomp", 5, ffree_instruction_index );
		instr_t( "fxsave", 0, fxsave_instruction_index );
		instr_t( "haddpd", $07C, sse_pd_instruction_index );
		instr_t( "haddps", $07C, cvtpd2dq_instruction_index );
		instr_t( "hsubpd", $07D, sse_pd_instruction_index );
		instr_t( "hsubps", $07D, cvtpd2dq_instruction_index );
		instr_t( "invlpg", 0, invlpg_instruction_index );
		instr_t( "lfence", $0E8, fence_instruction_index );
		instr_t( "looped", $0E1, loop_instruction_32bit_index );
		instr_t( "loopeq", $0E1, loop_instruction_64bit_index );
		instr_t( "loopew", $0E1, loop_instruction_16bit_index );
		instr_t( "loopne", $0E0, loop_instruction_index );
		instr_t( "loopnz", $0E0, loop_instruction_index );
		instr_t( "loopzd", $0E1, loop_instruction_32bit_index );
		instr_t( "loopzq", $0E1, loop_instruction_64bit_index );
		instr_t( "loopzw", $0E1, loop_instruction_16bit_index );
		instr_t( "mfence", $0F0, fence_instruction_index );
		instr_t( "movapd", $28, movpd_instruction_index );
		instr_t( "movaps", $28, movps_instruction_index );
		instr_t( "movdqa", $66, movdq_instruction_index );
		instr_t( "movdqu", $0F3, movdq_instruction_index );
		instr_t( "movhpd", $16, movlpd_instruction_index );
		instr_t( "movhps", $16, movlps_instruction_index );
		instr_t( "movlpd", $12, movlpd_instruction_index );
		instr_t( "movlps", $12, movlps_instruction_index );
		instr_t( "movnti", $0C3, movnti_instruction_index );
		instr_t( "movntq", $0E7, movntq_instruction_index );
		instr_t( "movsxd", $63, movsxd_instruction_index );
		instr_t( "movupd", $10, movpd_instruction_index );
		instr_t( "movups", $10, movps_instruction_index );
		instr_t( "paddsb", $0EC, mmx_instruction_index );
		instr_t( "paddsw", $0ED, mmx_instruction_index );
		instr_t( "pextrw", $0C5, pextrw_instruction_index );
		instr_t( "pfnacc", $8A, amd3dnow_instruction_index );
		instr_t( "pfsubr", $0AA, amd3dnow_instruction_index );
		instr_t( "pinsrw", $0C4, pinsrw_instruction_index );
		instr_t( "pmaxsw", $0EE, mmx_instruction_index );
		instr_t( "pmaxub", $0DE, mmx_instruction_index );
		instr_t( "pminsw", $0EA, mmx_instruction_index );
		instr_t( "pminub", $0DA, mmx_instruction_index );
		instr_t( "pmulhw", $0E5, mmx_instruction_index );
		instr_t( "pmullw", $0D5, mmx_instruction_index );
		instr_t( "psadbw", $0F6, mmx_instruction_index );
		instr_t( "pshufd", $66, pshufd_instruction_index );
		instr_t( "pshufw", 0, pshufw_instruction_index );
		instr_t( "pslldq", %111, ps_dq_instruction_index );
		instr_t( "psrldq", %011, ps_dq_instruction_index );
		instr_t( "psubsb", $0E8, mmx_instruction_index );
		instr_t( "psubsw", $0E9, mmx_instruction_index );
		instr_t( "pswapd", $0BB, amd3dnow_instruction_index );
		instr_t( "public", 0, public_directive_index );
		instr_t( "pushad", $60, simple_instruction_32bit_except64_index );
		instr_t( "pushaw", $60, simple_instruction_16bit_except64_index );
		instr_t( "pushfd", $9C, simple_instruction_32bit_except64_index );
		instr_t( "pushfq", $9C, simple_instruction_only64_index );
		instr_t( "pushfw", $9C, simple_instruction_16bit_index );
		instr_t( "rdtscp", 1, swapgs_instruction_index );
		instr_t( "repeat", 0, repeat_directive_index );
		instr_t( "setalc", $0D6, simple_instruction_except64_index );
		instr_t( "setnae", $92, set_instruction_index );
		instr_t( "setnbe", $97, set_instruction_index );
		instr_t( "setnge", $9C, set_instruction_index );
		instr_t( "setnle", $9F, set_instruction_index );
		instr_t( "sfence", $0F8, fence_instruction_index );
		instr_t( "shufpd", $0C6, sse_pd_instruction_index );
		instr_t( "shufps", $0C6, sse_ps_instruction_index );
		instr_t( "sqrtpd", $51, sse_pd_instruction_index );
		instr_t( "sqrtps", $51, sse_ps_instruction_index );
		instr_t( "sqrtsd", $51, sse_sd_instruction_index );
		instr_t( "sqrtss", $51, sse_ss_instruction_index );
		instr_t( "swapgs", 0, swapgs_instruction_index );
		instr_t( "sysret", $07, simple_extended_instruction_index );
		instr_t( "vmcall", $0C1, simple_vmx_instruction_index );
		instr_t( "vmread", 0, vmread_instruction_index );
		instr_t( "vmxoff", $0C4, simple_vmx_instruction_index );
		instr_t( "wbinvd", 9, simple_extended_instruction_index );
		byte 0;

  instructions_7:byte; @nostorage;
		instr_t( "clflush", %111, fxsave_instruction_index );
		instr_t( "cmovnae", $42, cmov_instruction_index );
		instr_t( "cmovnbe", $47, cmov_instruction_index );
		instr_t( "cmovnge", $4C, cmov_instruction_index );
		instr_t( "cmovnle", $4F, cmov_instruction_index );
		instr_t( "cmpeqpd", 0, cmp_pd_instruction_index );
		instr_t( "cmpeqps", 0, cmp_ps_instruction_index );
		instr_t( "cmpeqsd", 0, cmp_sd_instruction_index );
		instr_t( "cmpeqss", 0, cmp_ss_instruction_index );
		instr_t( "cmplepd", 2, cmp_pd_instruction_index );
		instr_t( "cmpleps", 2, cmp_ps_instruction_index );
		instr_t( "cmplesd", 2, cmp_sd_instruction_index );
		instr_t( "cmpless", 2, cmp_ss_instruction_index );
		instr_t( "cmpltpd", 1, cmp_pd_instruction_index );
		instr_t( "cmpltps", 1, cmp_ps_instruction_index );
		instr_t( "cmpltsd", 1, cmp_sd_instruction_index );
		instr_t( "cmpltss", 1, cmp_ss_instruction_index );
		instr_t( "cmpxchg", $0B0, basic_486_instruction_index );
		instr_t( "display", 0, display_directive_index );
		instr_t( "fcmovbe", $0D0, fcmov_instruction_index );
		instr_t( "fcmovnb", $0C0, fcomi_instruction_index );
		instr_t( "fcmovne", $0C8, fcomi_instruction_index );
		instr_t( "fcmovnu", $0D8, fcomi_instruction_index );
		instr_t( "fdecstp", %110110, simple_fpu_instruction_index );
		instr_t( "fincstp", %110111, simple_fpu_instruction_index );
		instr_t( "fnstenv", 6, fldenv_instruction_index );
		instr_t( "frndint", %111100, simple_fpu_instruction_index );
		instr_t( "fsincos", %111011, simple_fpu_instruction_index );
		instr_t( "fucomip", $0E8, fcomip_instruction_index );
		instr_t( "fucompp", 0, fucompp_instruction_index );
		instr_t( "fxrstor", 1, fxsave_instruction_index );
		instr_t( "fxtract", %110100, simple_fpu_instruction_index );
		instr_t( "fyl2xp1", %111001, simple_fpu_instruction_index );
		instr_t( "ldmxcsr", %10, fxsave_instruction_index );
		instr_t( "loopned", $0E0, loop_instruction_32bit_index );
		instr_t( "loopneq", $0E0, loop_instruction_64bit_index );
		instr_t( "loopnew", $0E0, loop_instruction_16bit_index );
		instr_t( "loopnzd", $0E0, loop_instruction_32bit_index );
		instr_t( "loopnzq", $0E0, loop_instruction_64bit_index );
		instr_t( "loopnzw", $0E0, loop_instruction_16bit_index );
		instr_t( "monitor", $0C8, monitor_instruction_index );
		instr_t( "movddup", $12, sse_sd_instruction_index );
		instr_t( "movdq2q", 0, movdq2q_instruction_index );
		instr_t( "movhlps", $12, movhlps_instruction_index );
		instr_t( "movlhps", $16, movhlps_instruction_index );
		instr_t( "movntdq", $0E7, movntdq_instruction_index );
		instr_t( "movntpd", $2B, movntdq_instruction_index );
		instr_t( "movntps", $2B, movntps_instruction_index );
		instr_t( "movq2dq", 0, movq2dq_instruction_index );
		instr_t( "paddusb", $0DC, mmx_instruction_index );
		instr_t( "paddusw", $0DD, mmx_instruction_index );
		instr_t( "pavgusb", $0BF, amd3dnow_instruction_index );
		instr_t( "pcmpeqb", $74, mmx_instruction_index );
		instr_t( "pcmpeqd", $76, mmx_instruction_index );
		instr_t( "pcmpeqw", $75, mmx_instruction_index );
		instr_t( "pcmpgtb", $64, mmx_instruction_index );
		instr_t( "pcmpgtd", $66, mmx_instruction_index );
		instr_t( "pcmpgtw", $65, mmx_instruction_index );
		instr_t( "pfcmpeq", $0B0, amd3dnow_instruction_index );
		instr_t( "pfcmpge", $90, amd3dnow_instruction_index );
		instr_t( "pfcmpgt", $0A0, amd3dnow_instruction_index );
		instr_t( "pfpnacc", $8E, amd3dnow_instruction_index );
		instr_t( "pfrsqrt", $97, amd3dnow_instruction_index );
		instr_t( "pmaddwd", $0F5, mmx_instruction_index );
		instr_t( "pmulhrw", $0B7, amd3dnow_instruction_index );
		instr_t( "pmulhuw", $0E4, mmx_instruction_index );
		instr_t( "pmuludq", $0F4, mmx_instruction_index );
		instr_t( "pshufhw", $0F3, pshufd_instruction_index );
		instr_t( "pshuflw", $0F2, pshufd_instruction_index );
		instr_t( "psubusb", $0D8, mmx_instruction_index );
		instr_t( "psubusw", $0D9, mmx_instruction_index );
		instr_t( "rsqrtps", $52, sse_ps_instruction_index );
		instr_t( "rsqrtss", $52, sse_ss_instruction_index );
		instr_t( "section", 0, section_directive_index );
		instr_t( "segment", 0, segment_directive_index );
		instr_t( "stmxcsr", %11, fxsave_instruction_index );
		instr_t( "syscall", $05, simple_extended_instruction_index );
		instr_t( "sysexit", $35, simple_extended_instruction_index );
		instr_t( "ucomisd", $2E, comisd_instruction_index );
		instr_t( "ucomiss", $2E, comiss_instruction_index );
		instr_t( "virtual", 0, virtual_directive_index );
		instr_t( "vmclear", 6, vmclear_instruction_index );
		instr_t( "vmptrld", 6, vmx_instruction_index );
		instr_t( "vmptrst", 7, vmx_instruction_index );
		instr_t( "vmwrite", 0, vmwrite_instruction_index );
		byte 0;

  instructions_8:byte; @nostorage;
		instr_t( "addsubpd", $0D0, sse_pd_instruction_index );
		instr_t( "addsubps", $0D0, cvtpd2dq_instruction_index );
		instr_t( "cmpneqpd", 4, cmp_pd_instruction_index );
		instr_t( "cmpneqps", 4, cmp_ps_instruction_index );
		instr_t( "cmpneqsd", 4, cmp_sd_instruction_index );
		instr_t( "cmpneqss", 4, cmp_ss_instruction_index );
		instr_t( "cmpnlepd", 6, cmp_pd_instruction_index );
		instr_t( "cmpnleps", 6, cmp_ps_instruction_index );
		instr_t( "cmpnlesd", 6, cmp_sd_instruction_index );
		instr_t( "cmpnless", 6, cmp_ss_instruction_index );
		instr_t( "cmpnltpd", 5, cmp_pd_instruction_index );
		instr_t( "cmpnltps", 5, cmp_ps_instruction_index );
		instr_t( "cmpnltsd", 5, cmp_sd_instruction_index );
		instr_t( "cmpnltss", 5, cmp_ss_instruction_index );
		instr_t( "cmpordpd", 7, cmp_pd_instruction_index );
		instr_t( "cmpordps", 7, cmp_ps_instruction_index );
		instr_t( "cmpordsd", 7, cmp_sd_instruction_index );
		instr_t( "cmpordss", 7, cmp_ss_instruction_index );
		instr_t( "cvtdq2pd", $0E6, cvtdq2pd_instruction_index );
		instr_t( "cvtdq2ps", $5B, sse_ps_instruction_index );
		instr_t( "cvtpd2dq", $0E6, cvtpd2dq_instruction_index );
		instr_t( "cvtpd2pi", $2D, cvtpd2pi_instruction_index );
		instr_t( "cvtpd2ps", $5A, sse_pd_instruction_index );
		instr_t( "cvtpi2pd", $2A, cvtpi2pd_instruction_index );
		instr_t( "cvtpi2ps", $2A, cvtpi2ps_instruction_index );
		instr_t( "cvtps2dq", $5B, sse_pd_instruction_index );
		instr_t( "cvtps2pd", $5A, cvtps2pd_instruction_index );
		instr_t( "cvtps2pi", $2D, cvtps2pi_instruction_index );
		instr_t( "cvtsd2si", $2D, cvtsd2si_instruction_index );
		instr_t( "cvtsd2ss", $5A, sse_sd_instruction_index );
		instr_t( "cvtsi2sd", $2A, cvtsi2sd_instruction_index );
		instr_t( "cvtsi2ss", $2A, cvtsi2ss_instruction_index );
		instr_t( "cvtss2sd", $5A, sse_ss_instruction_index );
		instr_t( "cvtss2si", $2D, cvtss2si_instruction_index );
		instr_t( "fcmovnbe", $0D0, fcomi_instruction_index );
		instr_t( "maskmovq", 0, maskmovq_instruction_index );
		instr_t( "movmskpd", 0, movmskpd_instruction_index );
		instr_t( "movmskps", 0, movmskps_instruction_index );
		instr_t( "movshdup", $16, cvtdq2pd_instruction_index );
		instr_t( "movsldup", $12, cvtdq2pd_instruction_index );
		instr_t( "packssdw", $6B, mmx_instruction_index );
		instr_t( "packsswb", $63, mmx_instruction_index );
		instr_t( "packuswb", $67, mmx_instruction_index );
		instr_t( "pfrcpit1", $0A6, amd3dnow_instruction_index );
		instr_t( "pfrcpit2", $0B6, amd3dnow_instruction_index );
		instr_t( "pfrsqit1", $0A7, amd3dnow_instruction_index );
		instr_t( "pmovmskb", $0D7, pextrw_instruction_index );
		instr_t( "prefetch", 0, amd_prefetch_instruction_index );
		instr_t( "sysenter", $34, simple_extended_instruction_index );
		instr_t( "unpckhpd", $15, sse_pd_instruction_index );
		instr_t( "unpckhps", $15, sse_ps_instruction_index );
		instr_t( "unpcklpd", $14, sse_pd_instruction_index );
		instr_t( "unpcklps", $14, sse_ps_instruction_index );
		instr_t( "vmlaunch", $0C2, simple_vmx_instruction_index );
		instr_t( "vmresume", $0C3, simple_vmx_instruction_index );
		byte 0;

  instructions_9:byte; @nostorage;
		instr_t( "cmpxchg8b", 8, cmpxchgx_instruction_index );
		instr_t( "cvttpd2dq", $0E6, sse_pd_instruction_index );
		instr_t( "cvttpd2pi", $2C, cvtpd2pi_instruction_index );
		instr_t( "cvttps2dq", $5B, cvtdq2pd_instruction_index );
		instr_t( "cvttps2pi", $2C, cvtps2pi_instruction_index );
		instr_t( "cvttsd2si", $2C, cvtsd2si_instruction_index );
		instr_t( "cvttss2si", $2C, cvtss2si_instruction_index );
		instr_t( "prefetchw", 1, amd_prefetch_instruction_index );
		instr_t( "punpckhbw", $68, mmx_instruction_index );
		instr_t( "punpckhdq", $6A, mmx_instruction_index );
		instr_t( "punpckhwd", $69, mmx_instruction_index );
		instr_t( "punpcklbw", $60, mmx_instruction_index );
		instr_t( "punpckldq", $62, mmx_instruction_index );
		instr_t( "punpcklwd", $61, mmx_instruction_index );
		byte 0;

  instructions_10:byte; @nostorage;
		instr_t( "cmpunordpd", 3, cmp_pd_instruction_index );
		instr_t( "cmpunordps", 3, cmp_ps_instruction_index );
		instr_t( "cmpunordsd", 3, cmp_sd_instruction_index );
		instr_t( "cmpunordss", 3, cmp_ss_instruction_index );
		instr_t( "cmpxchg16b", 16, cmpxchgx_instruction_index );
		instr_t( "loadall286", 5, simple_extended_instruction_index );
		instr_t( "loadall386", 7, simple_extended_instruction_index );
		instr_t( "maskmovdqu", 0, maskmovdqu_instruction_index );
		instr_t( "prefetcht0", 1, prefetch_instruction_index );
		instr_t( "prefetcht1", 2, prefetch_instruction_index );
		instr_t( "prefetcht2", 3, prefetch_instruction_index );
		instr_t( "punpckhqdq", $6D, sse_pd_instruction_index );
		instr_t( "punpcklqdq", $6C, sse_pd_instruction_index );
		byte 0;

  instructions_11:byte; @nostorage;
		instr_t( "prefetchnta", 0, prefetch_instruction_index );
		byte 0;




////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// Environment-dependent functions


#if( standalone )

	static(4)

		filenameStr		:str.strvar( 512 );


	// exists-
	//
	//	Pass a pointer to a zero-terminated string in ESI.
	//  Returns carry clear if the file exists, carry set
	//	if it does not exist.


	proc( exists( filename:zstring in esi ));

		str.cpyz( [esi], filenameStr );
		fileio.exists( filenameStr );
		shr( 1, eax );
		cmc;
		ret();
			
		
	end exists;



	// open-
	//	Opens the file whose filename (zstring ptr) is passed in edx.
	//  Returns the file handled in EBX (and EAX).

	proc( open( filename:zstring in edx ));

		str.cpyz( [edx], filenameStr );
		try
		
			fileio.open( filenameStr, fileio.r );
			
		  exception( ex.FileOpenFailure )
		  
		  	mov( -1, eax );
			stc;
			ret();
			
		  anyexception
		  
		  	raise( eax );
			
		endtry;
		mov( eax, ebx );
		clc;
		ret();
		
	end open;


	// create-
	//	Opens a new file whose filename (zstring ptr) is passed in edx.
	//  Returns the file handled in EBX (and EAX).

	proc( create( filename:zstring in edx ));

		str.cpyz( [edx], filenameStr );
		try
		
			fileio.openNew( filenameStr );
			
		  exception( ex.FileOpenFailure )
		  
		  	raise( fatal.write_failed );
			
		  anyexception
		  
		  	raise( eax );
			
		endtry;
		mov( eax, ebx );
		clc;
		ret();
		
		
		
	end create;


	// write-
	//	Writes (ECX) bytes at address (EDX) to the file specified
	//  by the file handle in EBX.

	proc
	(
		write
		( 
			handle	:dword in ebx; 
			buffer	:dword in edx; 
			len		:dword in ecx
		) 
	);

		try
		
			fileio.write( ebx, [edx], ecx );
			
		  exception( ex.DiskFullError )
		  	
			raise( fatal.write_failed );
		  
		  exception( ex.FileWriteError )
		  	
			raise( fatal.write_failed );
		  
		  anyexception
		  
		  	raise( eax );
			
		endtry;
		clc;
		ret();
		
	end write;


	// read-
	//	Read (ECX) bytes to address (EDX) from the file specified
	//  by the file handle in EBX.

	proc
	(
		read
		( 
			handle	:dword in ebx; 
			buffer	:dword in edx; 
			len		:dword in ecx
		) 
	);

		try
		
			fileio.read( ebx, [edx], ecx );
			
		  exception( ex.FileReadError )
		  	
			stc;
			ret();
		  
		  anyexception
		  
		  	raise( eax );

		endtry;
		clc;
		ret();
		
	end read;


	// close-
	//	Closes the file whose file handle is specified by EBX.

	proc( close( handle:dword in ebx ));

		fileio.close( ebx );
		ret();
		
	end close;


	// Seek -- from the beginning of the file.

	proc
	(
		seek
		( 
			handle		:dword in ebx; 
			posn		:dword in edx
		) 
	);

		fileio.seek( ebx, edx );
		ret();
		
	end seek;


	// mseek- from the current file position
	// (okay, this is disgusting; I ought to
	// add the corresponding routine to the
	// HLA stdlib).

	proc
	(
		mseek
		( 
			handle		:dword in ebx; 
			posn		:dword in edx 
		)
	);

		fileio.position( ebx );
		add( eax, edx );
		fileio.seek( ebx, edx );
		ret();
		
	end mseek;


	// rseek -- from the end of the file.


	proc
	(
		rseek
		( 
			handle		:dword in ebx; 
			posn		:dword in edx
		)
	);

		fileio.rSeek( ebx, edx );
		ret();
		
	end rseek;


	// readFileIntoMemory-
	//
	// Opens the specified file, determines its length, allocates storage
	// for the entire file (plus a little room at the end so we can write
	// a sentinel value there), and then reads the entire file into the
	// buffer.
	//
	// Returns:
	//	Pointer to the buffer in ESI.
	//	Length of the file in ECX.

	proc
	( 
		readFileIntoMemory( filename:string; fileException:dword );
		var
			handle		:dword;
			filesize	:dword;
			filedata	:dword;
	);

		push( ebp );
		mov( esp, ebp );
		sub( _vars_, esp );
		push( eax );
		

		try
		
			fileio.open( filename, fileio.r );
			mov( eax, handle );
			fileio.size( eax );
			mov( eax, filesize );
			mov( eax, ecx );
			add( 16, eax );				// Give us some padding.
			mem.alloc( eax );
			mov( eax, filedata );
			
			// Put a lenStrTkn at the end of file
			// This is a sentinel that marks the end of the file.
		
			mov( lenStrTkn, (type byte [eax+ecx]));	
			
			fileio.read( handle, val filedata, filesize );
			fileio.close( handle );

		  exception( ex.FileCloseError );
		  
		  	raise( aerr.error_reading_file );
			
		  exception( ex.FileReadError )
		  
		  	raise( aerr.error_reading_file );
			
		  exception( ex.FileOpenFailure )
		  
		  	raise( fileException );
			
		  exception( ex.MemoryAllocationFailure )
		  
		  	raise( fatal.out_of_memory_reading_file );
			
		  anyexception
		  
		  	raise( eax );
			
		endtry;
		mov( filedata, esi );
		mov( filesize, ecx );
		
		pop( eax );
		mov( ebp, esp );
		pop( ebp );
		ret( _parms_ );

	end readFileIntoMemory;



	proc
	( 
		getenv( envVarName:zstring );
		var
			envVar	:string;
	);
	
		push( ebp );
		mov( esp, ebp );
		sub( _vars_, esp );
		str.zlen( val envVarName );
		add( 4, eax );
		str.talloc( eax );
		mov( eax, envVar );
		str.cpyz( envVarName, envVar );
		env.a_get( envVar );
		if( eax = NULL ) then
		
			str.a_cpy( "" );	// If not there, return the empty string.
			
		endif;
		mov( ebp, esp );
		pop( ebp );
		ret( _parms_ );
		
	end getenv;
		
		
		


	// get_environment_variable-
	//
	//	esi points at a zstring.
	//	Fetch the associated environment variable (allocate in new storage)
	//	and copy that data to the end of memory (where EDI points)
	//  and return a pointer to it in EDI.

	proc( get_environment_variable( envVarName:zstring ));

		push( ebp );
		mov( esp, ebp );
		
		getenv( envVarName );

		mov( memory_end, ecx );
		sub( (type str.strRec [eax]).length, ecx );
		cmp( ecx, edi );
		jbe out_of_memory;
		
		push( eax );
		str.zcpy( [eax], [edi] );
		
		// EDI needs to point at the end of the string on return
		
		add( eax, edi );
		
		// Clean up the allocated storage:
		
		pop( eax );
		str.free( eax );
		pop( eax );
		str.free( eax );
		pop( ebp );
		ret( _parms_ );
		
			
		
	out_of_memory:
		raise( fatal.out_of_memory );
		
	end get_environment_variable;



	// Initialize the FASM memory manager.
	//
	// This just calls the system for a big block of memory
	// and then parcels it out in chuncks as required.
	// Ultimately, the FASM memory manager should be dumped
	// and replaced entirely by calls to the HLA stdlib memory
	// management package.

	proc( init_memory );

		
		// Note: HLA stdlib memory management system requires one malloc
		// operation in order to initialize the system. So lets allocate
		// a one-byte block to kick things off. Don't worry about 
		// freeing this guy (we can afford to leak 16 bytes).
	
	
		mem.alloc(256*1024*1024);	// Ask for a really big chunk to make sure
		mem.free( eax );			// it's there, then free it.
		mem.alloc( 16 );			// Just to make sure something's on the mem list.

		
		mov( memory_setting, eax );
		shl( 10, eax );
		jnz allocate_memory;
		
		// Find the largest free block in the HLA stdlib memory
		// management subsystem.
		
		push( edi );
		push( ebx );
		mem.stat();
		mov( ecx, eax );	// Largest free block (should be all).
		pop( ebx );
		pop( edx );
		
	  allocate_memory:
		mov( eax, edx );
		shr( 2, edx );
		mov( eax, ecx );
		sub( edx, ecx );
		sub( 4, ecx );
		mov( ecx, memory_end );
		mov( 0, (type dword [ecx]));
		sub( 4, edx );
		mov( edx, additional_memory_end );
		mov( 0, (type dword [edx]));
		try
		
			mem.alloc( eax );
			
		  exception( ex.MemoryAllocationFailure )
		  
		  	xor( eax, eax );
			
		  anyexception
		  
		  	raise( eax );
			
		endtry;
		or( eax, eax );
		jz not_enough_memory;

		mov( eax, memory_start );
		add( memory_end, eax );
		mov( eax, memory_end );
		mov( eax, additional_memory );
		add( eax, additional_memory_end );
		ret();

	  not_enough_memory:
		mov( additional_memory_end, eax );
		shl( 1, eax );
		cmp( eax, $4000 );
		jb out_of_memory;
		jmp allocate_memory;

	out_of_memory:
		raise( fatal.could_not_allocate_memory );	

	end init_memory;
	
	
	// display_string-
	//
	//	Writes a zstring to the stdout.

	proc( display_string );

	    str.zlen( [esi] );
		putBuf( [esi], eax );
		ret();
		
	end display_string;
	
	
	proc( exitProcess( exitCode:dword ));
	
		push( ebp );
		mov( esp, ebp );
		os.exitProcess( exitCode );
		
	end exitProcess;
	
	
	
	
	
	// Read the system time and convert it to a dword that we can use
	// as a timestamp value in object files (and for the %t symbol).

	proc
	( 
		make_timestamp;
		var
			theTime	:time.timerec;
			theDate	:date.daterec;
	);

		push( ebp );
		mov( esp, ebp );
		sub( _vars_, esp );
		
		lea( eax, theTime );
		time.curTime( [eax] );
		
		lea( eax, theDate );
		date.today( [eax] );
		
		// Convert a system time to a file time.
		//
		// Begin by converting years to the number of days
		// since 1/1/1601:
		
		movzx( theDate.year, ecx );
		mov( ecx, eax );
		sub( 1970, eax );
		mul( 365, eax );
		mov( eax, ebx );
		mov( ecx, eax );
		sub( 1969, eax );
		shr( 2, eax );
		add( eax, ebx );
		mov( ecx, eax );
		sub( 1901, eax );
		div( 100, edx:eax );
		sub( eax, ebx );
		mov( ecx, eax );
		xor( edx, edx );
		sub( 1601, eax );
		div( 400, edx:eax );
		add( eax, ebx );
		
		// Now convert the month value to some number of days:
		
		movzx( theDate.month, ecx );
		mov( ecx, eax );
		dec( eax );
		mul( 30, eax );
		add( eax, ebx );
		cmp( ecx, 8 );
		jbe months_correction;
		
		mov( ecx, eax );
		sub( 7, eax );
		shr( 1, eax );
		add( eax, ebx );
		mov( 8, ecx );
		
	  months_correction:
		mov( ecx, eax );
		shr( 1, eax );
		add( eax, ebx );
		cmp( ecx, 2 );
		jbe day_correction_ok;
		
		sub( 2, ebx );
		movzx( theDate.year, ecx );
		test( %11, ecx );
		jnz day_correction_ok;
		
		xor( edx, edx );
		mov( ecx, eax );
		div( 100, edx:eax );
		or( edx, edx );
		jnz day_correction;
		
		mov( ecx, eax );
		div( 400, edx:eax );
		or( edx, edx );
		jnz day_correction_ok;
		
	  day_correction:
		inc( ebx );
		
	  day_correction_ok:
		movzx( theDate.day, eax );
		dec( eax );
		add( ebx, eax );
		
		// Now convert the days to hours:
		
		mul( 24, eax );
		
		// Convert the hours to minutes:
		
		movzx( theTime.hours, ecx );
		add( ecx, eax );
		mul( 60, eax );
		
		// Convert the minutes to seconds:
		
		movzx( theTime.mins, ecx );
		add( ecx, eax );
		mul( 60, eax );
		
		// Finish up with seconds.
		
		movzx( theTime.secs, ecx );
		add( ecx, eax );
		
		mov( ebp, esp );
		pop( ebp );
		ret();

	end make_timestamp;
	
	


///////////////////////////////////
	
#else // C function, not standalone

///////////////////////////////////

	// exists-
	//
	//	Pass a pointer to a zero-terminated string in ESI.
	//  Returns carry clear if the file exists, carry set
	//	if it does not exist.


	procedure _fasm_exists( filename:zstring ); @cdecl; @external;
	proc( exists( filename:zstring in esi ) );

		push( ebx );
		push( ecx );
		push( edx );
		push( edi );
		push( esi );		// Contains the parameter
		call _fasm_exists;
		pop( esi );			// Removes the parameter
		pop( edi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		shr( 1, eax );
		cmc;
		ret();
		
	end exists;



	// open-
	//	Opens the file whose filename (zstring ptr) is passed in edx.
	//  Returns the file handled in EBX (and EAX).

	procedure _fasm_open( filename:zstring ); @cdecl; @external;
	proc( open( filename:zstring in edx ) );

		push( ecx );
		push( edi );
		push( esi );
		push( edx );
		call _fasm_open;
		pop( edx );
		pop( esi );
		pop( edi );
		pop( ecx );
		mov( eax, ebx );
		cmp( eax, -1 );
		je rtnError;
		clc;
		ret();
		
	  rtnError:
	  	stc();
		ret();
		
	end open;


	// create-
	//	Opens a new file whose filename (zstring ptr) is passed in edx.
	//  Returns the file handled in EBX (and EAX).

	procedure _fasm_create( filename:zstring ); @cdecl; @external;
	proc( create( filename:zstring in edx ) );

		push( ecx );
		push( edi );
		push( esi );
		push( edx );
		call _fasm_create;
		pop( edx );
		pop( esi );
		pop( edi );
		pop( ecx );
		mov( eax, ebx );
		cmp( eax, -1 );
		je rtnError;
		clc;
		ret();
		
	  rtnError:
	  	stc();
		ret();
		
	end create;


	// write-
	//	Writes (ECX) bytes at address (EDX) to the file specified
	//  by the file handle in EBX.

	procedure _fasm_write
	( 
		handle	:dword; 
		buffer	:dword; 
		len		:dword 
	); @cdecl; @external;
		
	proc(
		write
		( 
			handle	:dword in ebx; 
			buffer	:dword in edx; 
			len		:dword in ecx 
		)
	);

		push( ebx );
		push( ecx );
		push( edx );
		push( edi );
		push( esi );
		_fasm_write( handle, buffer, len );
		add( 12, esp );
		pop( esi );
		pop( edi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		cmp( eax, -1 );
		je write_failed;
		clc;
		ret();
		
	  write_failed:
		raise( fatal.write_failed );
		
	end write;


	// read-
	//	Read (ECX) bytes to address (EDX) from the file specified
	//  by the file handle in EBX.

	procedure _fasm_read
	( 
		handle	:dword; 
		buffer	:dword; 
		len		:dword 
	); @cdecl; @external;
	
	proc
	(
		read
		( 
			handle	:dword in ebx; 
			buffer	:dword in edx; 
			len		:dword in ecx
		) 
	);

		push( ebx );
		push( ecx );
		push( edx );
		push( edi );
		push( esi );
		_fasm_read( handle, buffer, len );
		add( 12, esp );
		pop( esi );
		pop( edi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		cmp( eax, -1 );
		je read_failed;
		clc;
		ret();
		
	  read_failed:
		raise( aerr.error_reading_file );
		
	end read;


	// close-
	//	Closes the file whose file handle is specified by EBX.

	procedure _fasm_close( handle:dword ); @cdecl; @external;
	proc( close( handle:dword in ebx ) );

		push( ebx );
		push( ecx );
		push( edx );
		push( edi );
		push( esi );
		_fasm_close( ebx );
		add( 4, esp );
		pop( esi );
		pop( edi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		ret();
		
	end close;


	// Seek -- from the beginning of the file.

	procedure _fasm_seek( handle:dword; posn:dword ); @cdecl; @external;
	proc 
	(
		seek
		( 
			handle		:dword in ebx; 
			posn		:dword in edx
		) 
	);

		push( ebx );
		push( ecx );
		push( edx );
		push( edi );
		push( esi );
		_fasm_seek( ebx, edx );
		add( 8, esp );
		pop( esi );
		pop( edi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		ret();
		
	end seek;


	// mseek- from the current file position
	// (okay, this is disgusting; I ought to
	// add the corresponding routine to the
	// HLA stdlib).

	procedure _fasm_mseek( handle:dword; posn:dword ); @cdecl; @external;
	proc 
	(
		mseek
		( 
			handle		:dword in ebx; 
			posn		:dword in edx 
		)
	);

		push( ebx );
		push( ecx );
		push( edx );
		push( edi );
		push( esi );
		_fasm_mseek( ebx, edx );
		add( 8, esp );
		pop( esi );
		pop( edi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		ret();
		
	end mseek;


	// rseek -- from the end of the file.


	procedure _fasm_rseek( handle:dword; posn:dword ); @cdecl; @external;
	proc
	(
		rseek
		( 
			handle		:dword in ebx; 
			posn		:dword in edx
		)
	);

		push( ebx );
		push( ecx );
		push( edx );
		push( edi );
		push( esi );
		_fasm_rseek( ebx, edx );
		add( 8, esp );
		pop( esi );
		pop( edi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		ret();
		
	end rseek;

	procedure _fasm_getenv( envVarName:dword ); @cdecl; @external;
	proc( getenv( envVarName:zstring ));
	
		push( ebp );
		mov( esp, ebp );
		push( ebx );
		push( ecx );
		push( edx );
		push( edi );
		push( esi );
		_fasm_getenv( envVarName );
		add( 4, esp );
		pop( esi );
		pop( edi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		pop( ebp );
		ret( _parms_ );

	end getenv;
		


	proc( get_environment_variable( envVarName:zstring ));
	
		push( ebp );
		mov( esp, ebp );
		
		push( esi );
		push( ebx );
		push( ecx );
		push( edx );
		push( edi );
		
		_fasm_getenv( envVarName );
		add( 4, esp );
		
		pop( edi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		
		test( eax, eax );
		jz out_of_memory;
		
		
		mov( eax, esi );
	  copyEnvVar:
	  	lodsb;
		stosb;
		cmp( al, 0 );
		jne copyEnvVar;
		
		dec( edi );	// EDI needs to point at the end of the string on return
		pop( esi );
		
		pop( ebp );
		ret( _parms_ );
		
	out_of_memory:
		raise( fatal.out_of_memory );	

	end	get_environment_variable;
		

	proc( init_memory );
		
		// If FASM is being invoked as a C function, the calling
		// C program has passed in the block of memory that we
		// get to use.
		//
		// FASM uses 3/4 of the available memory for the main
		// memory block and 1/4 of the memory for the "additional"
		// memory block.
		
		mov( C_memsize, ecx );
		shr( 2, ecx );				// div by 4;
		mov( ecx, edx );			// Compute 1/4 + 1/2 = 3/4
		lea( edx, [edx+ecx*2] );	// Does some rounding, but that's good.
		
		mov( C_memory, eax );
		mov( eax, memory_start );
		add( edx, eax );
		mov( eax, memory_end );
		mov( eax, additional_memory );
		add( ecx, eax );
		mov( eax, additional_memory_end );		
		ret();
			

	end init_memory;
	
	
	// display_string-
	//
	//	Writes a zstring to the stdout.

	proc( display_string );

		push( ebx );
		push( ecx );
		push( edx );
		push( edi );
		push( esi );
		call c_puts;
		pop( esi );		// Also removes cdecl parm.
		pop( edi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		ret();
		
	end display_string;
	
	// exitProcess-
	// Quits the program.
	
	procedure _fasm_exitProcess( exitCode:dword ); @cdecl; @external;
	proc( exitProcess( exitCode:dword ));
	
		push( ebp );
		mov( esp, ebp );
		_fasm_exitProcess( exitCode );
		
	end exitProcess;
	
	procedure _fasm_readFileIntoMemory(  filename:string; var size:dword );
		@cdecl; @external;
		
	proc
	( 
		readFileIntoMemory( filename:string; fileException:dword );
		var
			filesize	:dword;
	);	
	
		push( ebp );
		mov( esp, ebp );
		sub( _vars_, esp );
		
		push( eax );
		push( ebx );
		push( ecx );
		push( edx );
		push( edi );
		push( esi );
		
		_fasm_readFileIntoMemory( filename, filesize );
		cmp( eax, NULL );
		je out_of_memory_reading_file;
		cmp( eax, -1 );
		je raiseFileException;
	
		add( 8, esp );
		pop( esi );
		pop( edi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		
		// Emit a sentinel that marks the end of the file:
		
		mov( eax, esi );
		mov( filesize, ecx );
		mov( lenStrTkn, (type byte [esi+ecx]));

		pop( eax );
		leave();
		ret( _parms_ );
				
	out_of_memory_reading_file:
		raise( fatal.out_of_memory_reading_file );
		
	raiseFileException:
		raise( fileException );
	
	end readFileIntoMemory;
	
	
	
	
	
	
	
	// Read the system time and convert it to a dword that we can use
	// as a timestamp value in object files (and for the %t symbol).

	procedure _fasm_curDateTime
	(
		var month	:dword;
		var day		:dword;
		var year	:dword;
		var hour	:dword;
		var min		:dword;
		var sec		:dword
	); @cdecl; @external;
	
	proc
	( 
		make_timestamp;
		var
			month	:dword;
			day		:dword;
			year	:dword;
			hour	:dword;
			min		:dword;
			sec		:dword;
	);

		push( ebp );
		mov( esp, ebp );
		sub( _vars_, esp );
		
		_fasm_curDateTime( month,day,year,hour,min,sec );
		add( 24, esp );
		
		// Convert a system time to a file time.
		//
		// Begin by converting years to the number of days
		// since 1/1/1601:
		
		mov( year, ecx );
		mov( ecx, eax );
		sub( 1970, eax );
		mul( 365, eax );
		mov( eax, ebx );
		mov( ecx, eax );
		sub( 1969, eax );
		shr( 2, eax );
		add( eax, ebx );
		mov( ecx, eax );
		sub( 1901, eax );
		div( 100, edx:eax );
		sub( eax, ebx );
		mov( ecx, eax );
		xor( edx, edx );
		sub( 1601, eax );
		div( 400, edx:eax );
		add( eax, ebx );
		
		// Now convert the month value to some number of days:
		
		mov( month, ecx );
		mov( ecx, eax );
		dec( eax );
		mul( 30, eax );
		add( eax, ebx );
		cmp( ecx, 8 );
		jbe months_correction;
		
		mov( ecx, eax );
		sub( 7, eax );
		shr( 1, eax );
		add( eax, ebx );
		mov( 8, ecx );
		
	  months_correction:
		mov( ecx, eax );
		shr( 1, eax );
		add( eax, ebx );
		cmp( ecx, 2 );
		jbe day_correction_ok;
		
		sub( 2, ebx );
		mov( year, ecx );
		test( %11, ecx );
		jnz day_correction_ok;
		
		xor( edx, edx );
		mov( ecx, eax );
		div( 100, edx:eax );
		or( edx, edx );
		jnz day_correction;
		
		mov( ecx, eax );
		div( 400, edx:eax );
		or( edx, edx );
		jnz day_correction_ok;
		
	  day_correction:
		inc( ebx );
		
	  day_correction_ok:
		mov( day, eax );
		dec( eax );
		add( ebx, eax );
		
		// Now convert the days to hours:
		
		mul( 24, eax );
		
		// Convert the hours to minutes:
		
		mov( hour, ecx );
		add( ecx, eax );
		mul( 60, eax );
		
		// Convert the minutes to seconds:
		
		mov( min, ecx );
		add( ecx, eax );
		mul( 60, eax );
		
		// Finish up with seconds.
		
		mov( sec, ecx );
		add( ecx, eax );
		
		mov( ebp, esp );
		pop( ebp );
		ret();

	end make_timestamp;
	
	
	
	
	
	
	
#endif







//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////



// A convenient place to put all the exception targets:


proc( allTheExceptions );

address_sizes_do_not_agree::
	raise( aerr.address_sizes_do_not_agree );

code_cannot_be_generated::
	raise( fatal.code_cannot_be_generated );
	
data_already_defined::
	raise( aerr.data_already_defined );
	
error_reading_file::
	raise( aerr.error_reading_file );
	
extra_characters_on_line::
	raise( aerr.extra_characters_on_line );
	
file_not_found::
	raise( aerr.file_not_found );
	
format_limitations_exceeded::
	raise( fatal.format_limitations_exceeded );

illegal_instruction::
	raise( aerr.illegal_instruction );
	
incomplete_macro::
	raise( aerr.incomplete_macro );
	
invalid_address::
	raise( aerr.invalid_address );
	
invalid_address_size::
	raise( aerr.invalid_address_size );
	
invalid_argument::
	raise( aerr.invalid_argument );
	
invalid_expression::
	raise( aerr.invalid_expression );
	
invalid_file_format::
	raise( aerr.invalid_file_format );
	
invalid_macro_arguments::
	raise( aerr.invalid_macro_arguments );

invalid_name::
	raise( aerr.invalid_name );

invalid_operand::
	raise( aerr.invalid_operand );
	
invalid_operand_size::
	raise( aerr.invalid_operand_size );
	
invalid_use_of_symbol::
	raise( aerr.invalid_use_of_symbol );
	
invalid_value::
	raise( aerr.invalid_value );

long_immediate_not_encodable::
	raise( aerr.long_immediate_not_encodable );
	
missing_end_directive::
	raise( aerr.missing_end_directive );
	
missing_end_quote::
	raise( aerr.missing_end_quote );

name_too_long::
	raise( aerr.name_too_long );
	
operand_sizes_do_not_match::
	raise( aerr.operand_sizes_do_not_match );
	
operand_size_not_specified::
	raise( aerr.operand_size_not_specified );

out_of_memory::
	raise( fatal.out_of_memory );
	
out_of_memory_reading_file::
	raise( fatal.out_of_memory_reading_file );
	
prefix_conflict::
	raise( aerr.prefix_conflict );
	
relative_jump_out_of_range::
	raise( aerr.relative_jump_out_of_range );
	
reserved_word_used_as_symbol::
	raise( aerr.reserved_word_used_as_symbol );
	
section_not_aligned_enough::
	raise( aerr.section_not_aligned_enough );
	
setting_already_specified::
	raise( aerr.setting_already_specified );
	
stack_overflow::
	raise( fatal.stack_overflow );
		
symbol_already_defined::
	raise( aerr.symbol_already_defined );
	
too_many_repeats::
	raise( aerr.too_many_repeats );
	
undefined_symbol::
	raise( aerr.undefined_symbol );

unexpected_characters::
	raise( aerr.unexpected_characters );
	
unexpected_end_of_file::
	raise( fatal.unexpected_end_of_file );
	
unexpected_instruction::
	raise( aerr.unexpected_instruction );

value_out_of_range::
	raise( aerr.value_out_of_range );
	
write_failed::
	raise( fatal.write_failed );


end allTheExceptions;



// Translates the string of characters pointed at by ESI
// (of length passed in ECX) to lowercase and stores the
// result in the "converted" array.

proc
( 
	lower_case
	( 
		strToConvert:dword in esi;
		sizeOfStr	:dword in ecx 
	);
);

	mov( &converted, edi );
	mov( &characters, ebx );
  convert_case:
	lodsb;
	xlat;
	stosb;
	loop convert_case;
  case_ok:
	ret();
	
end lower_case;




// search_rsrvd_word_table-
//
//	On entry, EDI points at a table that uses the following format:
//
//	<strlen>, <string>, <dword ptr>
//
// The length of the string appears in the first byte of the
// string (just like Pascal strings).
//
// The entries in the table are sorted alphabetically by the string.
// (This allows for a small optimization in the search algorithm.)
//
// The table ends with a zero byte as the first character of the
// string entry.

proc
( 
	search_rsrvd_word_table( tbl:dword in edi ) 
);

	// First, convert the string argument to lower case
	// so that this will be a case insensitive search.
	
	mov( esi, edx );
	mov( ecx, ebp );
	push( edi );
	lower_case( esi, ecx );
	pop( edi );
	
  scan_symbols:
	mov( &converted, esi );				// lower_case puts str here.
	
	// See if we've reached the end of the table:
	
	movzx( (type byte [edi]), eax );	// Get the length byte.
	or( al, al );						// If the strlen is zero,
	jz no_symbol;						// it's the end of the table.
	
	// Point EBX at the DWORD at the end of the string:
	
	mov( ebp, ecx );
	inc( edi );
	mov( edi, ebx );
	add( eax, ebx );
	
	// Optimization: see if the first character is less than,
	// equal, or greater than the current table entry. Only
	// do a string comparison if equal. Quit if the string
	// is less than the current table entry.
	
	mov( [esi], ah );	
	cmp( ah, [edi] );	
	jb no_symbol;
	ja next_symbol;
	
	// Compare the lengths of the two strings. The strings are
	// not equal if their lengths don't match.
	
	cmp( cl, al );
	jne next_symbol;
	
	// If the lengths and first characters agree, do a full
	// string comparision:
	
	repe.cmpsb;
	jb no_symbol;
	je symbol_ok;
	
  next_symbol:
	mov( ebx, edi );	// Skip over the string.
	add( 4, edi );		// Skip over the dword.
	jmp scan_symbols;	// Try the next table entry.
	
	// Come down here if the symbol was not found
	// in the table (return carry set for failure).
		
  no_symbol:
	mov( edx, esi );
	mov( ebp, ecx );
	stc;
	ret();

	// Come down here if the symbol was found in
	// the table.
	
  symbol_ok:
	lea( esi, [edx+ebp] );
	mov( [ebx], eax );
	clc;
	ret();
	
end search_rsrvd_word_table;




// get_symbol-
//
// Just like search_rsrvd_word_table except that there is a
// word entry, rather than a dword entry, following the string.
// (This is being phased out).

proc( get_symbol( tbl:dword in edi ) );

	mov( esi, edx );
	mov( ecx, ebp );
	push( edi );
	lower_case( esi, ecx );
	pop( edi );
	
  scan_symbols:
	mov( &converted, esi );
	movzx( (type byte [edi]), eax );
	or( al, al );
	jz no_symbol;
	
	mov( ebp, ecx );
	inc( edi );
	mov( edi, ebx );
	add( eax, ebx );
	mov( [esi], ah );
	cmp( ah, [edi] );
	jb no_symbol;
	ja next_symbol;
	cmp( cl, al );
	jne next_symbol;
	repe.cmpsb;
	jb no_symbol;
	je symbol_ok;
	
  next_symbol:
	mov( ebx, edi );
	add( 2, edi );
	jmp scan_symbols;
	
  no_symbol:
	mov( edx, esi );
	mov( ebp, ecx );
	stc;
	ret();

  symbol_ok:
	lea( esi, [edx+ebp] );
	mov( [ebx], ax );
	clc;
	ret();
	
end get_symbol;




// This function is used to search for a mnemonic
// in one of the instruction tables.
//
//	ESI-	Points into source code
//	ECX-	Length of string to test against mnemonics.

proc( get_instruction );

	// First, convert the string we're looking
	// at to lower case so we get a case insensitive
	// comparison.  This leaves the converted
	// string in the "converted" buffer.
	
	mov( esi, edx );
	mov( ecx, ebp );
	call lower_case;
	mov( ebp, ecx );
	
	// All mnemonic string lengths are in the
	// range 2..11:
	
	cmp( cl, 11 );
	ja no_instruction;
	sub( 2, cl );
	jb no_instruction;
	
	// Get a pointer into the specific instruction
	// table for the mnemonic length we're processing.
	// Note that there are ten different tables (instructions2,
	// instructions3, ..., instructions11), one for each
	// of the possible mnemonic lengths.
	
	mov( instructions[ecx*4], edi );
	
	// Do a linear search to find the mnemonic
	// in the table. Note that the table is assumed
	// to be sorted alphabetically, so we can bail
	// whenever we find a mnemonic whose string value
	// is greater than the string we're comparing
	// against.  Also note that a zero byte marks
	// the end of the table.  Each entry in
	// the table takes the form:
	//
	// "string", baseOpcodeByte, &dwordPtr
	//
	// Where the dwordPtr value is the address of some
	// code to handle this particular mnemonic and
	// baseOpcodeByte is a single byte containing the
	// opcode value.
	//
	// For each partcular table, the string length is fixed.
	
  scan_instructions:
	mov( &converted, esi );
	
	// Get the first character from the current mnemonic:
	
	mov( [edi], al );
	
	// Check for the end of the list.
	
	or( al, al );
	jz no_instruction;
	
	// Okay	compare the string against the table entry:
	
	mov( ebp, ecx );
	mov( edi, ebx );
	add( ecx, ebx );	// Compute address of dword entry.
	repe.cmpsb;
	jb no_instruction;	// Bail if less than
	je instruction_ok;	// Success!
	
	// Didn't find the string yet, so move
	// on to the next string. Note that we need
	// to skip the dword and the opcode byte.
	
  next_instruction:
  	lea( edi, [ebx+5] ); 
	jmp scan_instructions;

	// Reset the pointers and return carry set if we didn't
	// match a mnemonic in the list.
		
  no_instruction:
	mov( edx, esi );
	mov( ebp, ecx );
	stc;
	ret();

	// If we did match the mnemonic, return the 16-bit
	// offset into the instrHandlerPtrs table.
	
  instruction_ok:
	lea( esi, [edx+ebp] );
	mov( [ebx], al );		// Get Opcode Byte
	mov( [ebx+1], ebx );
//fasmassembler:	sub( &fasmAssembler, ebx );
	clc;
	ret();
	
end get_instruction;






// get_operator-
//
// ESI points at the (operator) string we want to search for.
// EDI points at an operator table that uses the following format:
//
//	<strlen>, <opstring>, <byte value>
//
// A length byte containing zero marks the end of the table.
//
// Tables typically passed to this code (in EDI):
//
//	operators, single_operand_operators, directive_operators 

proc( get_operator( tbl:dword in edi ) );

	cmp( (type byte [esi]), lenStrTkn );
	jne get_simple_operator;
	
	// A lenStrTkn character precedes an
	// identifer string in the source file.
	// The format is <$1A><len><identifier>:
	//
	// Convert the identifier to lower case
	// so we can do a case insensitive compare:
	
	mov( esi, edx );	// Save ptr to beginning of search string.
	push( ebp );
	inc( esi );
	lodsb;
	movzx( al, ebp );	// Length of search string.
	push( edi );
	mov( ebp, ecx );
	call lower_case;
	pop( edi );
	
  check_operator:
	mov( &converted, esi );
	
	// Check to see if we're at the end of the table
	// (marked with a 0 byte in the length field).
	
	movzx( (type byte [edi]), ecx );
	jecxz no_operator;
	
	// Skip beyond the string to point at the 
	// data byte just beyond the string (leave
	// ebx pointing there).
	
	inc( edi );
	mov( edi, ebx );
	add( ecx, ebx );
	
	// If the length of our search string doesn't
	// match the length of the entry in the table,
	// the two don't agree and we can move on to
	// the next entry in the table:
	
	cmp( ecx, ebp );
	jne next_operator;
	
	// If the lengths match, do a string comparison.
	
	repe.cmpsb;
	je operator_found;
	
	// Move on to the next entry in the table:
	
  next_operator:
	mov( ebx, edi );
	inc( edi );
	jmp check_operator;
	
	// Drop down here if we didn't find an
	// entry in the table.
	
  no_operator:
	mov( edx, esi );
	mov( ebp, ecx );
	pop( ebp );
	
  no_simple_operator:
	xor( al, al );
	ret();

	// If we found the operator, 
  operator_found:
	lea( esi, [edx+ebp+2] );	// Point beyond the operator in the src.
	mov( ebp, ecx );			// Return length in ECX.
	pop( ebp );
	mov( [edi], al );			// Get byte value associated with operator.
	ret();

	// If the operator wasn't an identifier
	// (beginning with lenStrTkn/$1A), then drop
	// down here to do the comparison.
	
  get_simple_operator:
	mov( [esi], al );
	cmp( al, '"' );
	je no_simple_operator;
	
  simple_operator:
	cmp( (type byte [edi]), 1 );
	jb no_simple_operator;
	ja simple_next_operator;
	cmp( al, [edi+1] );
	je simple_operator_found;
	
  simple_next_operator:
	movzx( (type byte [edi]), ecx );
	lea( edi, [edi+ecx+2] );
	jmp simple_operator;
	
  simple_operator_found:
	inc( esi );
	mov( [edi+2], al );
	ret();

end get_operator;


// allocate_label-
//
//	Allocates storage for a label in the memory
// immediately preceding "labels_list". Sets all
// the bytes to zeroes.
//
// It returns a pointer to the newly cleared symbol object
// in EAX (and stores this into labels_list for the next
// label allocation).

proc( allocate_label );

	mov( labels_list, eax );
	mov( LABEL_STRUCTURE_SIZE >> 2, ecx );
	
  initialize_label:
	sub( 4, eax );
	mov( 0, (type dword [eax]) );
	loop initialize_label;
	mov( eax, labels_list );
	ret();
	
end allocate_label;




// get_label_id-
//
// On entry, ESI points into the source code at the label to process
// and ECX contains the length of the symbol to process.
//
// Return value in EAX:
//
//	$0					- Use the current location counter value.
//  $1					- Use a timestamp ID.
//	$2					- Use the ORG value.
//	none of the above	- Pointer to symbol table entry for the ID.


proc( get_label_id );

	// Because strings in FASM have a one-byte
	// length associated with them, labels are
	// limited (!) to 255 characters.
	
	cmp( ecx, $100 );
	jae name_too_long;
	
	// Check for anonymous labels here (@r, @b, @f).
	
	cmp( (type byte [esi]), '@' );
	je anonymous_label;
	
	// Check for labels beginning with ".", and "..".
	
	cmp( (type byte [esi]), '.' );
	jne standard_label;
	cmp( (type byte [esi+1]), '.' );
	je standard_label;
	
	// Check to see if we're processing a local
	// macro symbol. If so, current_locals_prefix
	// points at the pString that should prefix
	// the current symbol.
	
	cmp( current_locals_prefix, 0 );
	je standard_label;
	
	// Allocate storage for the local symbol
	// at the end of the free space
	// (room for the string, the prefix,
	// and two bytes).
	
	push( edi );
	mov( additional_memory_end, edi );
	sub( 2, edi );
	sub( ecx, edi );
	push( ecx );
	push( esi );
	mov( current_locals_prefix, esi );
	lodsb;
	movzx( al, ecx );
	sub( ecx, edi );
	out_of_mem( b, edi, free_additional_memory );   
	
	mov( 0, (type word [edi]) );
	add( 2, edi );
	
	// Copy the prefix data:
	
	mov( edi, ebx );
	rep.movsb;
	pop( esi );
	pop( ecx );
	add( cl, al ); 		// ensure prefix+symbol length < 256 chars.
	jc name_too_long;
	
	// Copy the label data:
	
	rep.movsb;
	
	// Now that we've constructed the
	// full local symbol, recursively call
	// get_label_id to process the new label.
	
	pop( edi );
	push( ebx );
	push( esi );
	movzx( al, ecx );
	mov( al, (type byte [ebx-1]) );
	mov( ebx, esi );
	call get_label_id;
	pop( esi );
	pop( ebx );
	cmp( ebx, [eax+24] );
	jne composed_label_id_ok;
	
	lea( edx, [ebx-2] );
	mov( edx, additional_memory_end );
  composed_label_id_ok:
	ret();

  anonymous_label:
	cmp( ecx, 2 );
	jne standard_label;
	
	mov( [esi+1], al );
	mov( &characters, ebx );
	xlat;
	
	// Check for @@, @b, @r, and @f here:
	
	cmp( al, '@' );
	je new_anonymous;
	cmp( al, 'b' );
	je anonymous_back;
	cmp( al, 'r' );
	je anonymous_back;
	cmp( al, 'f' );
	jne standard_label;
	
	// Handle @f here:
	
	add( 2, esi );
	mov( anonymous_forward, eax );
	or( eax, eax );
	jnz anonymous_ok;
	
	mov( current_line, eax );
	mov( eax, error_line );
	call allocate_label;
	mov( eax, anonymous_forward );
	
  anonymous_ok:
	xor( ebx, ebx );
	ret();

	// Handle @b / @r here:
	
  anonymous_back:
	add( 2, esi );
	mov( anonymous_reverse, eax );
	or( eax, eax );
	jz invalid_value;
	jmp anonymous_ok;
	
	// Handle @@ here:
	
  new_anonymous:
	add( 2, esi );
	mov( anonymous_forward, eax );
	or( eax, eax );
	jnz new_anonymous_ok;
	call allocate_label;
	
	// When a new anonymous label comes along,
	// the current "forward" anonymous symbol
	// becomes the new "reverse" symbol.
	
  new_anonymous_ok:
	mov( eax, anonymous_reverse );
	mov( 0, anonymous_forward );
	jmp anonymous_ok;
	
	// Handle regular (non-anonymous) symbols here.
	
  standard_label:
  
  	// Some special predefined IDs (e.g., '%t') begin with '%',
	// check for those here.
	
	cmp( (type byte [esi]), '%' );
	je get_predefined_id;
	
	// '$' by itself is the current value
	// of the location counter.
	// '$$' is
	
	cmp( (type byte [esi]), '$' );
	jne find_label;
	
	// If this item is more than two characters long,
	// then it's nether '$' nor '$$', so treat it
	// like a standard label.
	
	cmp( ecx, 2 );
	ja find_label;
	
	// If only one '$', then use the current
	// location counter value.
	
	inc( esi );
	jb get_current_offset_id;
	
	// See if we have '$$':
	
	inc( esi );
	cmp( (type byte [esi-1]), '$' );
	je get_org_origin_id;
	
	// Just a regular symbol.
	
	sub( ecx, esi );
	jmp find_label;
	
	// Come here if the symbol is '$'
	
  get_current_offset_id:
	xor( eax, eax );
	ret();

	// Come here if we encounter '%' by itself.
	
  get_counter_id:
	mov( 1, eax );
	ret();


	// Come here if we encounter '%t'
	
  get_timestamp_id:
	mov( 2, eax );
	ret();

	// Come here if we encounter '$$'
	
  get_org_origin_id:
	mov( 3, eax );
	ret();
	
	
	// If we've seen a '%', then check for
	// %t and % (by itself) here.
	
  get_predefined_id:
	cmp( ecx, 2 );	// If the length is greater than
	ja find_label;	// 2, it's not a predefined ID.
	
	inc( esi );
	cmp( cl, 1 );		// If the length is one, then it's '%' by itself,
	je get_counter_id;	// (which is a predefined counter ID)
	
	// If the length is two, check for '%t'
	
	lodsb;
	mov( &characters, ebx );
	xlat;
	cmp( al, 't' );
	je get_timestamp_id;
	
	// If it wasn't '%t', then treat it like a regular symbol.
	
	sub( 2, esi );
	
	
  find_label:
    
  	// Compute a hash value for the current symbol.
	// (This looks to be a typical hash function based
	// on a linear congruential random number generator,
	// somewhat expensive to compute, but produces a good
	// spread of hash values; but that's only a guess based
	// on a quick inspection -- RLH).
	
	xor( ebx, ebx );
	xor( ebp, ebp );
	xor( eax, eax );
	
  hash_label:
	ror( 1, ax );
	xor( [esi+ebx], al );
	add( 1, ebx );
	cmp( ebx, ecx );
	jb hash_label;
	mov( eax, ebp );
  	
	
	push( edi );
	push( esi );
	push( ecx );
	
	// Point EBX at the entry in the hash table where this
	// symbol will link:
	
	lea( ebx, hashTable[ebp*4] );
	mov( ebx, label_leaf );	// Save the pointer to the table link element.
	
	pop( edx );
	mov( [ebx], eax );	// See if there is already a label here
	
	mov( esi, ebx );
	while( eax <> NULL ) do
	
	  compare_labels:
		mov( ebx, esi );		// EBX holds the pointer to the label.
		mov( edx, ecx );		// EDX holds the label's length (in chars)
		mov( [eax+4], edi );	// EAX+4 points at a symbol table entry (?)
		mov( [edi+24], edi );	// Symtab entry +24 points at the symbol (?)
		repe.cmpsb;
		je label_found;
		mov( [eax], eax );		// Link to next entry in the linear list.
		
	endwhile;
	
  add_label:
	mov( edx, ecx );
	pop( esi );
	
	// Let's check this label to make sure it
	// is valid (proper syntax, and is not a
	// reserved word):
	
	cmp( (type byte [esi-2]), 0 );
	je label_name_ok;
	
	// If it begins with a digit, it's not legal:
	
	mov( [esi], al );
	cmp( al, '0' );
	jb name_first_char_ok;
	
	cmp( al, '9' );
	jbe invalid_name;
	
	
  name_first_char_ok:
	cmp( ecx, 1 );
	jne check_for_reserved_word;
	
	// If it's '$' by itself, then
	// it's a reserved word.
	
	cmp( al, '$' );
	je reserved_word;
	
  check_for_reserved_word:
  
  	// See if it's a mnemonic:
	
	call get_instruction;
	jnc reserved_word;
	
	// See if it's one of the data directives:
	
	mov( &data_directives, edi );
	call get_symbol;
	jnc reserved_word;
	
	// See if it's a register name:
	
	mov( &symbols, edi );
	call get_symbol;
	jnc reserved_word;
	
	// See if it's one of the code generation
	// reserved words:
	
	mov( &formatter_symbols, edi );
	call get_symbol;
	jnc reserved_word;
	
	// See if it's one of the operator reserved
	// words (e.g., mod, and, or, xor, shl, shr )
	
	sub( 2, esi );
	mov( &operators, edi );
	call get_operator;
	or( al, al );
	jnz reserved_word;
	
	// See if it's a single operand operator,
	// such as "not" or "rva":
	
	mov( &single_operand_operators, edi );
	call get_operator;
	or( al, al );
	jnz reserved_word;
	
	// See if it's one of the reserved words such
	// as "as", "at", "defined", etc.
	
	mov( &directive_operators, edi );
	call get_operator;
	or( al, al );
	jnz reserved_word;
	
	// At this point, it's just a plain old identifier:
	
	inc( esi );
	movzx( (type byte [esi]), ecx );	// Get length
	inc( esi );
  label_name_ok:
	mov( free_additional_memory, edx );
	lea( eax, [edx+8] );
	out_of_mem( a, eax, additional_memory_end );
	mov( eax, free_additional_memory );
	
	mov( esi, ebx );
	add( ecx, esi );		// Point ESI at end of symbol.
	mov( label_leaf, eax );	// Get address of link to new node.
	mov( [eax], edi );
	mov( edi, [edx] );
	mov( edx, [eax] );
	call allocate_label;
	mov( eax, [edx+4] );	// Save ptr to new sym entry in hash tree.
	mov( ebx, [eax+24] );	// Save ptr to symbol here.
	pop( edi );
	ret();
	
	
  label_found:
	add( 4, esp );			// Remove pointer to label pushed earlier
	pop( edi );
	mov( [eax+4], eax );	// Return pointer to symbol table entry.
	ret();

  reserved_word:
	mov( $0F, eax );
	pop( edi );
	ret();

end get_label_id;










// Error messages are "pushed" onto a stack for later
// playback. The following routines do that "later playback."


proc( display_block );

	add( ecx, displayed_count );
	cmp( ecx, 1 );
	ja take_last_two_characters;
	jb block_displayed;
	mov( last_displayed[1], al );
	mov( [esi], ah );
	mov( ax, (type word last_displayed) );
	jmp block_ok;
	
  take_last_two_characters:
	mov( [esi+ecx-2], ax );
	mov( ax, (type word last_displayed) );
	
  block_ok:
  	putBuf( [esi], ecx );
  block_displayed:
	ret();
	
end display_block;


proc( flush_display_buffer );

	mov( display_buffer, eax );
	or( eax, eax );
	jz display_done;
	mov( labels_list, esi );
	cmp( esi, eax );
	je display_done;
  display_messages:
	sub( 4, esi );
	mov( [esi], ecx );
	sub( ecx, esi );
	push( esi );
	call display_block;
	pop( esi );
	cmp( esi, display_buffer );
	jne display_messages;
	mov( labels_list, eax );
	mov( eax, display_buffer );
  display_done:
	ret();
	
end flush_display_buffer;





proc( display_user_messages );

	mov( 0, displayed_count );
	call flush_display_buffer;
	cmp( displayed_count, 1 );
	jb line_break_ok;
	je make_line_break;
	mov( (type word last_displayed), ax );
	cmp( ax, $0A0D );
	je line_break_ok;
	cmp( ax, $0D0A );
	je line_break_ok;
  make_line_break:
  	put_newln();
  line_break_ok:
	ret();
	
end display_user_messages;
	

// Fatal errors occur when the assembler cannot
// proceed. We can't even print the stacked up
// error messages when a fatal error occurs (because
// a memory overflow may have wiped out the playback
// stack).

proc( fatal_error );

	puts( "error: " );
	pop( esi );
	call display_string;
	putc( '.' );
	put_newln();
	exitProcess( $ff );
	
end fatal_error;



// assembler_error-
//
//	Called when we have a non-fatal error.
// Unwinds and displays all the messages that have been
// stacked up.

proc
( 
	assembler_error;
	
	static
		errMsgPtr	:dword;
);

	pop( errMsgPtr );
	try
	
		// Display all the saved error messages:
		
		call display_user_messages;
		pushd( 0 );
		mov( current_line, ebx );
		
	  get_error_lines:
		push( ebx );
		test( $80, (type byte [ebx+7]) );
		jz display_error_line;
		
		mov( ebx, edx );	
	  find_definition_origin:
		mov( [edx+12], edx );
		test( $80, (type byte [edx+7]) );
		jnz find_definition_origin;
		
		push( edx );
		mov( [ebx+8], ebx );
		jmp get_error_lines;
		
	  display_error_line:
		mov( [ebx], esi );
		call display_string;
		mov( &line_number_start, esi );
		call display_string;
		mov( [ebx+4], eax );
		and( $7FFFFFFF, eax );
		putu32( eax );
		putc( ']' );	 
		pop( esi );
		cmp( ebx, esi );
		je line_number_ok;
		
		putc( ' ' );
		push( esi );
		mov( [esi], esi );
		movzx( (type byte [esi]), ecx );
		inc( esi );
		call display_block;
		mov( &line_number_start, esi );
		call display_string;
		pop( esi );
		mov( [esi+4], eax );
		and( $7FFFFFFF, eax );
		putu32( eax );
		putc( ']' );	 
		
	  line_number_ok:
		mov( &line_data_start, esi );
		call display_string;
		mov( ebx, esi );
		#if( standalone )
		
			mov( [esi], edx );
			call open;
			xor( edx, edx );
			rseek( ebx, edx );
			mov( [esi+8], edx );
			sub( edx, eax );
			push( eax );
			seek( ebx, edx );
			mov( [esp], ecx );
			mov( additional_memory, edx );
			lea(       eax, [edx+ecx] );
			out_of_mem( a, eax, additional_memory_end );
			read( ebx, edx, ecx );
			close( ebx );
			pop( ecx );
			mov( additional_memory, esi );
			
			// Search for the end of the line
			
		  get_line_data:
			mov( [esi], al );
			cmp( al, lf );
			je display_line_data;
			cmp( al, cr );
			je display_line_data;
			cmp( al, #$1a );			// CTLZ = EOF
			je display_line_data;
			or( al, al );
			jz display_line_data;
			inc( esi );
			loop get_line_data;
			
		  display_line_data:
			mov( esi, ecx );
			mov( additional_memory, esi );
			sub( esi, ecx );
			call display_block;
			put_newln();

		#endif
		pop( ebx );
		or( ebx, ebx );
		jnz display_error_line;
		puts( "error: " );
		puts( errMsgPtr );
		putc( '.' );
		put_newln();
		exitProcess( 2 );
		
	  anyexception
	  
	  	puts( "Exception occured while processing error messages: $" );
		puthex32( eax );
		put_newln();
		
	endtry;
	exitProcess(2);
	
end assembler_error;
	





// Process FASM command-line parameters
// The command-line parameters are:
//
// FASM {options} sourceFilename destFileName
//
// {options}:
//	-mxxxx or -m xxxxx
//		xxxx is a decimal number specifying, in kilobytes, the maximum amount
//		of memory to allocate (max: 2**21 kilobytes, which is 2GB).
//
//	-pxxxx or -p xxxxx
//		xxxx is a decimal number specifying the maximum number of passes to allow. 
//
// Returns -1 ($FFFF_FFFF, a "way too big" value) if there was an error.

#if( standalone )

	// getOption -
	//	Processes the decimal number following the 
	//  -m or -p command-line option.
	//	Note that the number may immediately follow the 
	//  'm' or 'p', or it can
	//	be the next command-line parameter.
	
	proc
	( 
		getOption;
		static
			minusOne:string := "-1";
	);
	
		push( edx );
		lea( esi, [eax+2] );
		if( (type char [esi]) not in '0'..'9' ) then
		
			inc( edx );
			mov( minusOne, esi );
			if( edx<ecx ) then
				arg.v( edx );
				mov( eax, esi );
				
			endif;
			
		endif;
		try
		
			conv.atoi( );
			
		  exception( ex.ValueOutOfRange )
		  
		  	or( -1, eax );
			
		  anyexception
		  
		  	raise( eax );
			
		endtry;
		pop( edx );
		ret();		
			
	end getOption;


	proc( get_params );

		push( esi );
		mov( 0, memory_setting );
		mov( 100, passes_limit );
		mov( null, input_file );
		mov( null, output_file );
		
		arg.c();			// Get parameter count.
		mov( eax, ecx );
		mov( 1, edx );		// Start
		while( edx < ecx ) do
		
			arg.v( edx );
			if( (type char [eax]) = '-' ) then
			
				mov( [eax+1], bl );
				cmp( bl, 'm' );
				je memArg;
				cmp( bl, 'M' );
				je memArg;
				cmp( bl, 'p' );
				je passesArg;
				cmp( bl, 'P' );
				jne badArgument;
				
			  passesArg:
			  		getOption();
					mov( ax, passes_limit );
					cmp( eax, $10000 );
					jae badArgument;
					inc( edx );
					continue;
					
			  memArg:
			  		getOption();
					mov( eax, memory_setting );
					cmp( eax, 1 << (32-10) );
					jae badArgument;
					inc( edx );
					continue;
					
			endif;
			
			// If we haven't yet grabbed an input file, then this parameter
			// is going to be the input file.
			
			if( input_file = NULL ) then
			
				mov( eax, input_file );
				inc( edx );
				continue;
				
			endif;
			
			// If we already have an input file, and this is the second parameter
			// that doesn't begin with '-', then it must be the output_file. If
			// we're already seen to parameters, then it's an error.
			
			cmp( output_file, NULL );
			jne badArgument;
			mov( eax, output_file );
			inc( edx );
			
		endwhile;
		pop( esi );
		clc();
		ret();
		
				
	badArgument:
		pop( esi );
		stc();
		ret();	
		
	end get_params;
	
#endif




// convert_line-
//
//	Does a quick scan of the input source line and performs the
//  following operations:
//
// Eliminates whitespace (spaces and tabs).

proc( convert_line );

	push( ecx );
	test( $0F, macro_status );
	jz convert_line_data;
	
	// If processing a macro...
	
	mov( auxDataToken, ax );
	stosw;
	
  convert_line_data:
	out_of_mem( ae, edi, memory_end );
	
	
	// Get rid of spaces and tabs.

	repeat
	
		// Get the next character from the source file.
		
		mov( [esi], al );
		add( 1, esi );
		
	until( al <> ' ' && al <> tab );
	
	
	// Check for operator symbols.
	
	mov( al, ah );
	mov( &characters, ebx );
	xlat;
	
	// Look for operator characters (they get mapped to zero
	// by the xlat above):
	
	cmp( al, 0 );
	jz convert_separator;
	
	// Look for string literals.
	
	cmp( ah, '''' );
	je convert_string;
	cmp( ah, '"' );
	je convert_string;
	

	mov( lenStrTkn, (type byte [edi]) );
	
	// Skip lenStrTkn and make room for a length byte:
	
	add( 2, edi );		// was: scasw; 
	
	// Retrieve original character and store it into
	// the string we are creating.
	
	xchg( ah, al );
	stosb;
	
	// Process an identifier:
	
	mov( &characters, ebx );
	xor( ecx, ecx );
	
  convert_symbol:
	lodsb;
	stosb;
	xlat;
	cmp( al, 0 );			// Zero if we hit a delimiter character
	loopnz convert_symbol;
	
	// Compute the length of the name and make sure it's not too long.
	
	neg( ecx );
	cmp( ecx, 255 );
	ja name_too_long;
	
	// Store away the name's length in the byte immediately
	// preceding the ID string:
	
	mov( edi, ebx );
	sub( ecx, ebx );
	mov( cl, (type byte [ebx-2]) );
	
  found_separator:
	dec( edi );
	mov( [esi-1], ah );
	
  convert_separator:
	xchg( ah, al );
	cmp( al, ' ' );
	jb control_character;
	je convert_line_data;
	
  symbol_character:
	cmp( al, ';' );
	je ignore_comment;
	cmp( al, $5C );
	je backslash_character;
	stosb;
	jmp convert_line_data;
	
  control_character:
	cmp( al, lenStrTkn );
	je line_end;
	
	cmp( al, cr );
	je cr_character;
	cmp( al, lf );
	je lf_character;
	cmp( al, tab );
	je convert_line_data;
	or( al, al );
	jnz symbol_character;
	jmp line_end;
	
  lf_character:
	lodsb;
	cmp( al, cr );
	je line_end;
	dec( esi );
	jmp line_end;
	
  cr_character:
	lodsb;
	cmp( al, lf );
	je line_end;
	dec( esi );
	jmp line_end;
	
  convert_string:
	mov( '"', al );
	stosb;
	scasd;
	mov( edi, ebx );
	
  copy_string:
	lodsb;
	stosb;
	cmp( al, lf );
	je missing_end_quote;
	cmp( al, cr );
	je missing_end_quote;
	or( al, al );
	jz missing_end_quote;
	cmp( al, lenStrTkn );
	je missing_end_quote;
	cmp( al, ah );
	jne copy_string;
	lodsb;
	cmp( al, ah );
	je copy_string;
	dec( esi );
	dec( edi );
	mov( edi, eax );
	sub( ebx, eax );
	mov( eax, [ebx-4] );
	jmp convert_line_data;
	
  backslash_character:
	mov( 0, (type byte [edi]) );
	lodsb;
	cmp( al, ' ' );
	je concatenate_lines;
	cmp( al, tab );
	je concatenate_lines;
	cmp( al, lenStrTkn );
	je unexpected_end_of_file;
	cmp( al, lf );
	je concatenate_lf;
	cmp( al, cr );
	je concatenate_cr;
	cmp( al, auxDataToken );
	je find_concatenated_line;
	mov( lenStrTkn, al );
	stosb;
	mov( edi, ecx );
	mov( $5C01, ax );
	stosw;
	dec( esi );
	
  group_backslashes:
	lodsb;
	cmp( al, $5C );
	jne backslashed_symbol;
	stosb;
	inc( (type byte [ecx]) );
	jmp group_backslashes;
	
  backslashed_symbol:
	cmp( al, lenStrTkn );
	je unexpected_end_of_file;
	cmp( al, lf );
	je extra_characters_on_line;
	cmp( al, cr );
	je extra_characters_on_line;
	cmp( al, ' ' );
	je extra_characters_on_line;
	cmp( al, tab );
	je extra_characters_on_line;
	cmp( al, '"' );
	je extra_characters_on_line;
	cmp( al, $27 );
	je extra_characters_on_line;
	cmp( al, auxDataToken );
	je extra_characters_on_line;
	mov( al, ah );
	mov( &characters, ebx );
	xlat;
	or( al, al );
	jz backslashed_symbol_character;
	mov( ah, al );
	
  convert_backslashed_symbol:
	stosb;
	xlat;
	or( al, al );
	jz found_separator;
	inc( (type byte [ecx]) );
	jz name_too_long;
	lodsb;
	jmp convert_backslashed_symbol;
	
  backslashed_symbol_character:
	mov( ah, al );
	stosb;
	inc( (type byte [ecx]) );
	jmp convert_line_data;
	
  concatenate_lines:
	lodsb;
	cmp( al, ' ' );
	je concatenate_lines;
	cmp( al, tab );
	je concatenate_lines;
	cmp( al, lenStrTkn );
	je unexpected_end_of_file;
	cmp( al, lf );
	je concatenate_lf;
	cmp( al, cr );
	je concatenate_cr;
	cmp( al, auxDataToken );
	jne extra_characters_on_line;
	
  find_concatenated_line:
	lodsb;
	cmp( al, lf );
	je concatenate_lf;
	cmp( al, cr );
	je concatenate_cr;
	or( al, al );
	jz concatenate_ok;
	cmp( al, lenStrTkn );
	jne find_concatenated_line;
	jmp unexpected_end_of_file;
	
  concatenate_lf:
	lodsb;
	cmp( al, cr );
	je concatenate_ok;
	dec( esi );
	jmp concatenate_ok;
	
  concatenate_cr:
	lodsb;
	cmp( al, lf );
	je concatenate_ok;
	dec( esi );
	
  concatenate_ok:
	inc( (type dword [esp]) );
	jmp convert_line_data;
	
  ignore_comment:
	lodsb;
	cmp( al, lf );
	je lf_character;
	cmp( al, cr );
	je cr_character;
	or( al, al );
	jz line_end;
	cmp( al, lenStrTkn );
	jne ignore_comment;
	
  line_end:
	xor( al, al );
	stosb;
	pop( ecx );
	ret();
	
end convert_line;


proc( move_data );

	shr( 1, ecx );
	jnc movsb_ok;
	movsb;
	
  movsb_ok:
	shr( 1, ecx );
	jnc movsw_ok;
	movsw;
	
  movsw_ok:
	rep.movsd;
	ret();
	
end move_data;


proc( calculate_hash );

	xor( ebx, ebx );
	mov( 2166136261, eax );
	mov( 16777619, ebp );
  fnv1a_hash:
	xor( [esi+ebx], al );
	mul( ebp );
	inc( bl );
	cmp( bl, cl );
	jb fnv1a_hash;
	ret();
	
end calculate_hash;



proc( get_preprocessor_symbol );

	push( ebp );
	push( edi );
	push( esi );
	mov( ecx, ebp );
	shl( 22, ebp );
	movzx( cl, ecx );
	mov( &hash_tree, ebx );
	mov( 10, edi );
  follow_hashes_roots:
	mov( [ebx], edx );
	or( edx, edx );
	jz preprocessor_symbol_not_found;
	xor( eax, eax );
	shl( 1, ebp );
	adc( 0, eax );
	lea( ebx, [edx+eax*4] );
	dec( edi );
	jnz follow_hashes_roots;
	mov( ebx, edi );
	call calculate_hash;
	mov( eax, ebp );
	and( $3FF, ebp );
	shl( 10, ebp );
	xor( eax, ebp );
	mov( edi, ebx );
	mov( 22, edi );
  follow_hashes_tree:
	mov( [ebx], edx );
	or( edx, edx );
	jz preprocessor_symbol_not_found;
	xor( eax, eax );
	shl( 1, ebp );
	adc( 0, eax );
	lea( ebx, [edx+eax*4] );
	dec( edi );
	jnz follow_hashes_tree;
	mov( cl, al );
	mov( [ebx], edx );
	or( edx, edx );
	jz preprocessor_symbol_not_found;
  compare_with_preprocessor_symbol:
	mov( [edx+4], edi );
	cmp( edi, 1 );
	jbe next_equal_hash;
	repe.cmpsb;
	je preprocessor_symbol_found;
	mov( al, cl );
	mov( [esp], esi );
  next_equal_hash:
	mov( [edx], edx );
	or( edx, edx );
	jnz compare_with_preprocessor_symbol;
  preprocessor_symbol_not_found:
	pop( esi );
	pop( edi );
	pop( ebp );
	stc;
	ret();

  preprocessor_symbol_found:
	pop( ebx );
	pop( edi );
	pop( ebp );
	clc;
	ret();
	
end get_preprocessor_symbol;






proc( process_macro_operators );

	xor( dl, dl );
	mov( edi, ebp );
	
  before_macro_operators:
	mov( esi, edi );
	lodsb;
	cmp( al, '`' );
	je symbol_conversion;
	cmp( al, '#' );
	je concatenation;
	cmp( al, lenStrTkn );
	je symbol_before_macro_operators;
	cmp( al, auxDataToken );
	je no_more_macro_operators;
	cmp( al, '"' );
	je string_before_macro_operators;
	xor( dl, dl );
	or( al, al );
	jnz before_macro_operators;
	mov( esi, edi );
	ret();

  no_more_macro_operators:
	mov( ebp, edi );
	ret();

  symbol_before_macro_operators:
	mov( lenStrTkn, dl );
	mov( esi, ebx );
	lodsb;
	movzx( al, ecx );
	jecxz symbol_before_macro_operators_ok;
	mov( esi, edi );
	cmp( (type byte [esi]), '\' );
	je escaped_symbol;
	
  symbol_before_macro_operators_ok:
	add( ecx, esi );
	jmp before_macro_operators;
	
  string_before_macro_operators:
	mov( '"', dl );
	mov( esi, ebx );
	lodsd;
	add( eax, esi );
	jmp before_macro_operators;
	
  escaped_symbol:
	dec( (type byte [edi-1]) );
	dec( ecx );
	inc( esi );
	cmp( ecx, 1 );
	rep.movsb;
	jne after_macro_operators;
	mov( [esi-1], al );
	mov( ebx, ecx );
	mov( &characters, ebx );
	xlat;
	mov( ecx, ebx );
	or( al, al );
	jnz after_macro_operators;
	sub( 3, edi );
	mov( [esi-1], al );
	stosb;
	xor( dl, dl );

  after_macro_operators:
	lodsb;
	cmp( al, '`' );
	je symbol_conversion;
	cmp( al, '#' );
	je concatenation;
	stosb;
	cmp( al, lenStrTkn );
	je symbol_after_macro_operators;
	cmp( al, auxDataToken );
	je no_more_macro_operators;
	cmp( al, '"' );
	je string_after_macro_operators;
	xor( dl, dl );
	or( al, al );
	jnz after_macro_operators;
	ret();

  symbol_after_macro_operators:
	mov( lenStrTkn, dl );
	mov( edi, ebx );
	lodsb;
	stosb;
	movzx( al, ecx );
	jecxz symbol_after_macro_operatorss_ok;
	cmp( (type byte [esi]), '\' );
	je escaped_symbol;
	
  symbol_after_macro_operatorss_ok:
	rep.movsb;
	jmp after_macro_operators;
	
  string_after_macro_operators:
	mov( '"', dl );
	mov( edi, ebx );
	lodsd;
	stosd;
	mov( eax, ecx );
	rep.movsb;
	jmp after_macro_operators;
	
	
  concatenation:
	cmp( dl, lenStrTkn );
	je symbol_concatenation;
	cmp( dl, '"' );
	je string_concatenation;
	
  no_concatenation:
	cmp( esi, edi );
	je before_macro_operators;
	jmp after_macro_operators;
	
  symbol_concatenation:
	cmp( (type byte [esi]), lenStrTkn );
	jne no_concatenation;
	inc( esi );
	lodsb;
	movzx( al, ecx );
	jecxz do_symbol_concatenation;
	cmp( (type byte [esi]), '\' );
	jne do_symbol_concatenation;
	sub( 2, esi );
	jmp no_concatenation;
	
  do_symbol_concatenation:
	add( al, [ebx] );
	jc name_too_long;
	rep.movsb;
	jmp after_macro_operators;
	
  string_concatenation:
	cmp( (type byte [esi]), '"' );
	je do_string_concatenation;
	cmp( (type byte [esi]), '`' );
	jne no_concatenation;
	
  concatenate_converted_symbol:
	inc( esi );
	mov( [esi], al );
	cmp( al, '`' );
	je concatenate_converted_symbol;
	cmp( al, '"' );
	je do_string_concatenation;
	cmp( al, lenStrTkn );
	jne concatenate_converted_symbol_character;
	inc( esi );
	lodsb;
	movzx( al, ecx );
	add( ecx, [ebx] );
	rep.movsb;
	jmp after_macro_operators;
	
  concatenate_converted_symbol_character:
	or( al, al );
	jz after_macro_operators;
	cmp( al, '#' );
	je after_macro_operators;
	inc( (type dword [ebx]) );
	movsb;
	jmp after_macro_operators;
	
  do_string_concatenation:
	inc( esi );
	lodsd;
	mov( eax, ecx );
	add( eax, [ebx] );
	rep.movsb;
	jmp after_macro_operators; 
	
  reduce_symbol_conversion:
	inc( esi );
	
  symbol_conversion:
	mov( esi, edx );
	mov( [esi], al );
	cmp( al, lenStrTkn );
	jne symbol_character_conversion;
	lodsw;
	movzx( ah, ecx );
	lea( ebx, [edi+3] );
	jmp convert_to_quoted_string;
	
  symbol_character_conversion:
	cmp( al, '"' );
	je after_macro_operators;
	cmp( al, '`' );
	je reduce_symbol_conversion;
	lea( ebx, [edi+5] );
	xor( ecx, ecx );
	or( al, al );
	jz convert_to_quoted_string;
	cmp( al, '#' );
	je convert_to_quoted_string;
	inc( ecx );
	
  convert_to_quoted_string:
	sub( edx, ebx );
	ja shift_line_data;
	mov( '"', al );
	mov( al, dl );
	stosb;
	mov( edi, ebx );
	mov( ecx, eax );
	stosd;
	rep.movsb;
	cmp( edi, esi );
	je before_macro_operators;
	jmp after_macro_operators;
	
  shift_line_data:
	push( ecx );
	mov( esi, edx );
	lea( esi, [ebp-1] );
	add( ebx, ebp );
	lea( edi, [ebp-1] );
	lea( ecx, [esi+1] );
	sub( edx, ecx );
	std;
	rep.movsb;
	cld;
	pop( eax );
	sub( 3, edi );
	mov( '"', dl );
	mov( dl, [edi-1] );
	mov( edi, ebx );
	mov( eax, [edi] );
	lea( esi, [edi+eax+4] );
	jmp before_macro_operators;
	
end process_macro_operators;



proc( process_fix_constants );

	mov( %11, value_type );
	jmp process_symbolic_constants;
	
end process_fix_constants;
	
proc( process_equ_constants );

	mov( %10, value_type );
	
	// Falls through to process_symbolic_constants
	
end process_equ_constants; 
	
// Note: process_symbolic_constants must immediately
//       follow process_equ_constants.

procedure process_symbolic_constants;
begin process_symbolic_constants;

  do_symbolic_constants:
	mov( esi, ebp );
	lodsb;
	cmp( al, lenStrTkn );
	je check_symbol;
	cmp( al, '"' );
	je ignore_string;
	cmp( al, '{' );
	je check_brace;
	or( al, al );
	jnz do_symbolic_constants;
	ret();

  ignore_string:
	lodsd;
	add( eax, esi );
	jmp do_symbolic_constants;
	
  check_brace:
	test( $80, value_type );
	jz do_symbolic_constants;
	ret();
	
  no_replacing:
	movzx( (type byte [esi-1]), ecx );
	add( ecx, esi );
	jmp do_symbolic_constants;
	
  check_symbol:
	mov( [esi], cl );
	inc( esi );
	mov( value_type, ch );
	call get_preprocessor_symbol;
	jc no_replacing;
	mov( edi, current_section );
	
	// Falls through to replace_symbolic_constant
	
end process_symbolic_constants;
	



procedure replace_symbolic_constant;
begin replace_symbolic_constant;

  replaceSymbolicConstant:
	mov( [edx+12], ecx );
	mov( [edx+8], edx );
	xchg( edx, esi );
	call move_data;
	mov( edx, esi );

  process_after_replaced:
	lodsb;
	cmp( al, lenStrTkn );
	je symbol_after_replaced;
	stosb;
	cmp( al, '"' );
	je string_after_replaced;
	cmp( al, '{' );
	je brace_after_replaced;
	or( al, al );
	jnz process_after_replaced;
	mov( edi, ecx );
	sub( esi, ecx );
	mov( ebp, edi );
	call move_data;
	mov( edi, esi );
	ret();

  string_after_replaced:
	lodsd;
	stosd;
	mov( eax, ecx );
	call move_data;
	jmp process_after_replaced;
	
  brace_after_replaced:
	test( $80, value_type );
	jz process_after_replaced;
	mov( edi, edx );
	mov( current_section, ecx );
	sub( ecx, edx );
	sub( esi, ecx );
	rep.movsb;
	mov( edi, ecx );
	sub( esi, ecx );
	mov( ebp, edi );
	call move_data;
	lea( esi, [ebp+edx] );
	ret();

  symbol_after_replaced:
	mov( [esi], cl );
	inc( esi );
	mov( value_type, ch );
	call get_preprocessor_symbol;
	jnc replaceSymbolicConstant;
	movzx( (type byte [esi-1]), ecx );
	mov( lenStrTkn, al );
	mov( cl, ah );
	stosw;
	call move_data;
	jmp process_after_replaced;
	
end replace_symbolic_constant;


proc( find_macro_symbol_leaf );

	shl( 8, eax );
	mov( cl, al );
	mov( eax, ebp );
	mov( &macro_symbols, ebx );
  follow_macro_symbols_tree:
	mov( [ebx], edx );
	or( edx, edx );
	jz no_such_macro_symbol;
	xor( eax, eax );
	shr( 1, ebp );
	adc( 0, eax );
	lea( ebx, [edx+eax*4] );
	or( ebp, ebp );
	jnz follow_macro_symbols_tree;
	add( 8, ebx );
	clc;
	ret();

  no_such_macro_symbol:
	stc;
	ret();
	
end find_macro_symbol_leaf;


proc( add_macro_symbol );

	push( ebx );
	push( ebp );
	call find_macro_symbol_leaf;
	jc extend_macro_symbol_tree;
	mov( [ebx], eax );
	
  make_macro_symbol:
	mov( free_additional_memory, edx );
	add( 16, edx );
	out_of_mem( a, edx, labels_list );
	xchg( free_additional_memory, edx );
	mov( edx, [ebx] );
	mov( eax, [edx] );
	mov( esi, [edx+4] );
	pop( ebp );
	pop( ebx );
	ret();

  extend_macro_symbol_tree:
	mov( free_additional_memory, edx );
	add( 16, edx );
	out_of_mem( a, edx, labels_list );
	xchg( free_additional_memory, edx );
	xor( eax, eax );
	mov( eax, [edx] );
	mov( eax, [edx+4] );
	mov( eax, [edx+8] );
	mov( eax, [edx+12] );
	shr( 1, ebp );
	adc( 0, eax );
	mov( edx, [ebx] );
	lea( ebx, [edx+eax*4] );
	or( ebp, ebp );
	jnz extend_macro_symbol_tree;
	add( 8, ebx );
	xor( eax, eax );
	jmp make_macro_symbol;
	
end add_macro_symbol;


proc( get_macro_argument );

	lodsb;
	movzx( al, ecx );
	mov( counter_limit, eax );
	call add_macro_symbol;
	add( ecx, esi );
	xchg( ebx, esi );
	mov( esi, [edx+12] );
	cmp( (type byte [esi]), '<' );
	jne simple_argument;
	inc( esi );
	mov( esi, [edx+12] );
	mov( 1, ecx );
	
  enclosed_argument:
	lodsb;
	or( al, al );
	jz invalid_macro_arguments;
	cmp( al, lenStrTkn );
	je enclosed_symbol;
	cmp( al, '"' );
	je enclosed_string;
	cmp( al, '>' );
	je enclosed_argument_end;
	cmp( al, '<' );
	jne enclosed_argument;
	inc( ecx );
	jmp enclosed_argument;
	
  enclosed_symbol:
	movzx( (type byte [esi]), eax );
	inc( esi );
	add( eax, esi );
	jmp enclosed_argument;
	
  enclosed_string:
	lodsd;
	add( eax, esi );
	jmp enclosed_argument;
	
  enclosed_argument_end:
  	dec( ecx );
	jnz enclosed_argument;
	mov( [esi], al );
	or( al, al );
	jz enclosed_argument_ok;
	cmp( al, ',' );
	jne invalid_macro_arguments;
	
  enclosed_argument_ok:
	mov( esi, eax );
	sub( [edx+12], eax );
	dec( eax );
	or( $80000000, eax );
	mov( eax, [edx+8] );
	jmp argument_value_ok;
	
  simple_argument:
	lodsb;
	or( al, al );
	jz argument_value_end;
	cmp( al, ',' );
	je argument_value_end;
	cmp( al, '"' );
	je argument_string;
	cmp( al, lenStrTkn );
	jne simple_argument;
	movzx( (type byte [esi]), eax );
	inc( esi );
	add( eax, esi );
	jmp simple_argument;
	
  argument_string:
	lodsd;
	add( eax, esi );
	jmp simple_argument;
	
  argument_value_end:
	dec( esi );
	mov( esi, eax );
	sub( [edx+12], eax );
	mov( eax, [edx+8] );
	
  argument_value_ok:
	xchg( ebx, esi );
	cmp( (type byte [esi]), '*' );
	jne macro_argument_ok;
	cmp( (type dword [edx+8]), 0 );
	je invalid_macro_arguments;
	inc( esi );
	
  macro_argument_ok:
	ret();
	
end get_macro_argument;


proc( get_number );

	xor( ebp, ebp );
	lodsb;
	cmp( al, '"' );
	je get_text_number;
	cmp( al, lenStrTkn );
	jne not_number;
	lodsb;
	movzx( al, ecx );
	mov( esi, number_start );
	mov( [esi], al );
	cmp( al, '$' );
	je number_begin;
	sub( '0', al );
	cmp( al, tab );
	ja invalid_number;
	
  number_begin:
	mov( esi, ebx );
	add( ecx, esi );
	push( esi );
	dec( esi );
	mov( 0, (type dword [edi]) );
	mov( 0, (type dword [edi+4]) );
	cmp( (type byte [ebx]), '$' );
	je pascal_hex_number;
	cmp( (type word [ebx]), asWord( "0x" ) );
	je get_hex_number;
	mov( [esi], al );
	dec( esi );
	cmp( al, 'h' );
	je get_hex_number;
	cmp( al, 'b' );
	je get_bin_number;
	cmp( al, 'd' );
	je get_dec_number;
	cmp( al, 'o' );
	je get_oct_number;
	cmp( al, 'H' );
	je get_hex_number;
	cmp( al, 'B' );
	je get_bin_number;
	cmp( al, 'D' );
	je get_dec_number;
	cmp( al, 'O' );
	je get_oct_number;
	inc( esi );
	
  get_dec_number:
	mov( esi, ebx );
	mov( number_start, esi );
	
  get_dec_digit:
	cmp( esi, ebx );
	ja number_ok;
	xor( edx, edx );
	mov( [edi], eax );
	shld( 2, eax, edx );
	shl( 2, eax );
	add( [edi], eax );
	adc( 0, edx );
	add( eax, eax );
	adc( edx, edx );
	mov( eax, [edi] );
	mov( [edi+4], eax );
	add( eax, eax );
	jc dec_out_of_range;
	add( eax, eax );
	jc dec_out_of_range;
	add( [edi+4], eax );
	jc dec_out_of_range;
	add( eax, eax );
	jc dec_out_of_range;
	add( edx, eax );
	jc dec_out_of_range;
	mov( eax, [edi+4] );
	movzx( (type byte [esi]), eax );
	sub( '0', al );
	cmp( al, 9 );
	ja bad_number;
	add( eax, [edi] );
	adc( 0, (type dword [edi+4]) );
	jc dec_out_of_range;
	inc( esi );
	jmp get_dec_digit;
	
  dec_out_of_range:
	or( -1, ebp );
	inc( esi );
	jmp get_dec_digit;
	
  bad_number:
	pop( eax );
	
  invalid_number:
	mov( number_start, esi );
	dec( esi );
	
  not_number:
	dec( esi );
	stc;
	ret();

  get_bin_number:
	xor( bl, bl );
	
  get_bin_digit:
	cmp( esi, number_start );
	jb number_ok;
	movzx( (type byte [esi]), eax );
	sub( '0', al );
	cmp( al, 1 );
	ja bad_number;
	xor( edx, edx );
	mov( bl, cl );
	dec( esi );
	cmp( bl, 64 );
	je bin_out_of_range;
	inc( bl );
	cmp( cl, '2' );
	jae bin_digit_high;
	shl( cl, eax );
	or( eax, (type dword [edi]) );
	jmp get_bin_digit;
	
  bin_digit_high:
	sub( 32, cl );
	shl( cl, eax );
	or( eax, (type dword [edi+4]) );
	jmp get_bin_digit;
	
  bin_out_of_range:
	or( al, al );
	jz get_bin_digit;
	or( -1, ebp );
	jmp get_bin_digit;
	
  pascal_hex_number:
	cmp( cl, 1 );
	je bad_number;
	
  get_hex_number:
	xor( bl, bl );
	
  get_hex_digit:
	cmp( esi, number_start );
	jb number_ok;
	movzx( (type byte [esi]), eax );
	cmp( al, 'x' );
	je hex_number_ok;
	cmp( al, '$' );
	je pascal_hex_ok;
	sub( '0', al );
	cmp( al, 9 );
	jbe hex_digit_ok;
	sub( 7, al );
	cmp( al, 15 );
	jbe hex_letter_digit_ok;
	sub( $20, al );
	cmp( al, 15 );
	ja bad_number;
	
  hex_letter_digit_ok:
	cmp( al, 10 );
	jb bad_number;
	
  hex_digit_ok:
	xor( edx, edx );
	mov( bl, cl );
	dec( esi );
	cmp( bl, 64 );
	je hex_out_of_range;
	add( 4, bl );
	cmp( cl, 32 );
	jae hex_digit_high;
	shl( cl, eax );
	or( eax, (type dword [edi]) );
	jmp get_hex_digit;
	
  hex_digit_high:
	sub( 32, cl );
	shl( cl, eax );
	or( eax, (type dword [edi+4]) );
	jmp get_hex_digit;
	
  hex_out_of_range:
	or( al, al );
	jz get_hex_digit;
	or( -1, ebp );
	jmp get_hex_digit;
	
  get_oct_number:
	xor( bl, bl );
	
  get_oct_digit:
	cmp( esi, number_start );
	jb number_ok;
	movzx( (type byte [esi]), eax );
	sub( '0', al );
	cmp( al, 7 );
	ja bad_number;
	
  oct_digit_ok:
	xor( edx, edx );
	mov( bl, cl );
	dec( esi );
	cmp( bl, 64 );
	jae oct_out_of_range;
	add( 3, bl );
	cmp( cl, 30 );
	je oct_digit_wrap;
	ja oct_digit_high;
	shl( cl, eax );
	or( eax, (type dword [edi]) );
	jmp get_oct_digit;
	
  oct_digit_wrap:
	shl( cl, eax );
	adc( 0, (type dword [edi+4]) );
	or( eax, (type dword [edi]) );
	jmp get_oct_digit;
	
  oct_digit_high:
	sub( 32, cl );
	shl( cl, eax );
	or( eax, (type dword [edi+4]) );
	jmp get_oct_digit;
	
  oct_out_of_range:
	or( al, al );
	jz get_oct_digit;
	or( -1, ebp );
	jmp get_oct_digit;
	
  hex_number_ok:
	dec( esi );
	
  pascal_hex_ok:
	cmp( esi, number_start );
	jne bad_number;
	
  number_ok:
	pop( esi );
	
  number_done:
	clc;
	ret();

  get_text_number:
	lodsd;
	mov( eax, edx );
	xor( bl, bl );
	mov( 0, (type dword [edi]) );
	mov( 0, (type dword [edi+4]) );
	
  get_text_character:
	sub( 1, edx );
	jc number_done;
	movzx( (type byte [esi]), eax );
	inc( esi );
	mov( bl, cl );
	cmp( bl, 64 );
	je text_out_of_range;
	add( 8, bl );
	cmp( cl, 32 );
	jae text_character_high;
	shl( cl, eax );
	or( eax, (type dword [edi]) );
	jmp get_text_character;
	
  text_character_high:
	sub( 32, cl );
	shl( cl, eax );
	or( eax, (type dword [edi+4]) );
	jmp get_text_character;
	
  text_out_of_range:
	or( -1, ebp );
	jmp get_text_character;

end get_number;



proc( skip_foreign_symbol );

  sfs:
	lodsb;
	movzx( al, eax );
	add( eax, esi );
	
  skip_foreign_line:
	lodsb;
	cmp( al, lenStrTkn );
	je sfs;
	cmp( al, auxDataToken );
	je sfs;
	cmp( al, '"' );
	je skip_foreign_string;
	or( al, al );
	jnz skip_foreign_line;
	ret();

  skip_foreign_string:
	lodsd;
	add( eax, esi );
	jmp skip_foreign_line;
	
end skip_foreign_symbol;




proc( get_macro_symbol );

	push( ecx );
	call find_macro_symbol_leaf;
	jc macro_symbol_not_found;
	mov( [ebx], edx );
	mov( esi, ebx );
  try_macro_symbol:
	or( edx, edx );
	jz macro_symbol_not_found;
	mov( [esp], ecx );
	mov( [edx+4], edi );
	repe.cmpsb;
	je macro_symbol_found;
	mov( ebx, esi );
	mov( [edx], edx );
	jmp try_macro_symbol;
  macro_symbol_found:
	pop( ecx );
	clc;
	ret();

  macro_symbol_not_found:
	pop( ecx );
	stc;
	ret();

end get_macro_symbol;


proc( store_number_symbol );

	mov( lenStrTkn, ax );
	stosw;
	push( edi );
	mov( ecx, eax );
	mov( 1000000000, ecx );
	xor( edx, edx );
	xor( bl, bl );
	
  store_number_digits:
	div( ecx );
	push( edx );
	or( bl, bl );
	jnz store_number_digit;
	cmp( ecx, 1 );
	je store_number_digit;
	or( al, al );
	jz number_digit_ok;
	not( bl );
	
  store_number_digit:
	add( '0', al );
	stosb;
	
  number_digit_ok:
	mov( ecx, eax );
	xor( edx, edx );
	mov( 10, ecx );
	div( ecx );
	mov( eax, ecx );
	pop( eax );
	or( ecx, ecx );
	jnz store_number_digits;
	pop( ebx );
	mov( edi, eax );
	sub( ebx, eax );
	mov( al, [ebx-1] );
	ret();

end store_number_symbol;



proc( close_macro_block );

	cmp( counter, 0 );
	je block_closed;
	jl reverse_counter;
	mov( counter, eax );
	cmp( eax, counter_limit );
	je block_closed;
	inc( counter );
	jmp continue_block;
  reverse_counter:
	mov( counter, eax );
	dec( eax );
	cmp( eax, $80000000 );
	je block_closed;
	mov( eax, counter );
  continue_block:
	mov( macro_block, esi );
	mov( macro_block_line, eax );
	mov( eax, macro_line );
	mov( macro_block_line_number, ecx );
	stc;
	ret();

  block_closed:
	clc;
	ret();

end close_macro_block;



proc( skip_pattern );

  skipPattern:
	lodsb;
	or( al, al );
	jz invalid_macro_arguments;
	cmp( al, ',' );
	je pattern_skipped;
	cmp( al, '"' );
	je skip_quoted_string_in_pattern;
	cmp( al, lenStrTkn );
	je skip_symbol_in_pattern;
	cmp( al, '=' );
	jne skipPattern;
	mov( [esi], al );
	cmp( al, lenStrTkn );
	je skipPattern;
	cmp( al, '"' );
	je skipPattern;
	inc( esi );
	jmp skipPattern;
	
  skip_symbol_in_pattern:
	lodsb;
	movzx( al, eax );
	add( eax, esi );
	jmp skipPattern;
	
  skip_quoted_string_in_pattern:
	lodsd;
	add( eax, esi );
	jmp skipPattern;
	
  pattern_skipped:
	ret();
	
end skip_pattern;



proc( exact_match );

  exactMatch:
	cmp( esi, parameters_end );
	je exact_match_complete;
	mov( [esi], ah );
	mov( [ebx], al );
	cmp( al, ',' );
	je exact_match_complete;
	cmp( al, lenStrTkn );
	je exact_match_complete;
	cmp( al, '=' );
	je match_verbatim;
	call match_elements;
	je exactMatch;
	
  exact_match_complete:
	ret();

  match_verbatim:
	inc( ebx );
	call match_elements;
	je exactMatch;
	dec( ebx );
	ret();

  match_elements:
	mov( [ebx], al );
	cmp( al, lenStrTkn );
	je match_symbols;
	cmp( al, '"' );
	je match_quoted_strings;
	cmp( al, ah );
	je symbol_characters_matched;
	ret();

  symbol_characters_matched:
	lea( ebx, [ebx+1] );
	lea( esi, [esi+1] );
	ret();

  match_quoted_strings:
	mov( [ebx+1], ecx );
	add( 5, ecx );
	jmp compare_elements;
	
  match_symbols:
	movzx( (type byte [ebx+1]), ecx );
	add( 2, ecx );
	
  compare_elements:
	mov( esi, eax );
	mov( edi, ebp );
	mov( ebx, edi );
	repe.cmpsb;
	jne elements_mismatch;
	mov( edi, ebx );
	mov( ebp, edi );
	ret();

  elements_mismatch:
	mov( eax, esi );
	mov( ebp, edi );
	ret();
	
end exact_match;



proc( skip_match_element );

	cmp( esi, parameters_end );
	je cannot_match;
	mov( [esi], al );
	cmp( al, lenStrTkn );
	je skip_match_symbol;
	cmp( al, '"' );
	je skip_match_quoted_string;
	add( 1, esi );
	ret();

  skip_match_quoted_string:
	mov( [esi+1], eax );
	add( 5, esi );
	jmp skip_match_ok;
	
  skip_match_symbol:
	movzx( (type byte [esi+1]), eax );
	add( 2, esi );
	
  skip_match_ok:
	add( eax, esi );
	ret();

  cannot_match:
	stc;
	ret();
	
end skip_match_element;



proc( skip_parameters );

  skipParms:
	lodsb;
	or( al, al );
	jz parameters_skipped;
	cmp( al, '{' );
	je parameters_skipped;
	cmp( al, '"' );
	je skip_quoted_parameter;
	cmp( al, lenStrTkn );
	jne skipParms;
	lodsb;
	movzx( al, eax );
	add( eax, esi );
	jmp skipParms;
  skip_quoted_parameter:
	lodsd;
	add( eax, esi );
	jmp skipParms;
  parameters_skipped:
	ret();
	
end skip_parameters;





proc
( 
	process_macro;
	static
	  macro_directives:byte; @nostorage;
			symfunc_t( "common", common_block );
			symfunc_t( "forward", forward_block );
			symfunc_t( "local", local_symbols );
			symfunc_t( "reverse", reverse_block );
			byte 0;
);

	push( (type dword macro_status) );
	or( $10, macro_status );
	push( counter );
	push( macro_block );
	push( macro_block_line );
	push( macro_block_line_number );
	push( struc_label );
	push( struc_name );
	push( eax );
	push( current_line );
	lodsb;
	
	if( al <> '{' ) then
	
		or( al, al );
		jnz unexpected_characters;
		
		forever
		
			mov( esi, macro_line );
			add( 16+2, esi );
			lodsb;
			or( al, al );
			continueif( @z );
			breakif( al = '{' );
			
			cmp( al, auxDataToken );
			jne unexpected_characters;
			
			call skip_foreign_symbol;
			
		endfor;
		
	endif;
	
	mov( $80000000, ecx );
	mov( esi, macro_block );
	mov( macro_line, eax );
	mov( eax, macro_block_line );
	mov( ecx, macro_block_line_number );
	xor( eax, eax );
	mov( eax, counter );
	if( eax <> counter_limit ) then
	
		inc( counter );
		
	endif;
	
  process_macro_line:
	mov( edi, current_line );
	out_of_mem( ae, edi, memory_end );
	mov( [esp+4], eax );
	or( eax, eax );
	jz instant_macro_line_header;
	stosd;
	mov( ecx, eax );
	stosd;
	mov( [esp], eax );
	stosd;
	mov( macro_line, eax );
	stosd;
	jmp macro_line_header_ok;
	
  instant_macro_line_header:
	mov( macro_line, edx );
	mov( [edx], eax );
	stosd;
	mov( [edx+4], eax );
	stosd;
	mov( [edx+8], eax );
	stosd;
	mov( [edx+12], eax );
	stosd;
	
  macro_line_header_ok:
	or( $20, macro_status );
	push( ebx );
	push( ecx );
	test( $0F, macro_status );
	jz process_macro_line_element;
	mov( auxDataToken, ax );
	stosw;
	
  process_macro_line_element:
	lodsb;
	cmp( al, '}' );
	je macro_line_processed;
	or( al, al );
	jz macro_line_processed;
	cmp( al, lenStrTkn );
	je process_macro_symbol;
	cmp( al, auxDataToken );
	je macro_foreign_line;
	and( _byte( !$20 ), macro_status );
	stosb;
	cmp( al, '"' );
	jne process_macro_line_element;
	
  copy_macro_string:
	mov( [esi], ecx );
	add( 4, ecx );
	rep.movsb;
	jmp process_macro_line_element;
	
  process_macro_directive:
	mov( eax, edx );
	pop( edi );
	pop( eax );
	mov( 0, (type byte [edi]) );
	inc( edi );
	pop( ecx );
	pop( ebx );
	jmp( edx );
	
  process_macro_symbol:
	push( esi );
	push( edi );
	test( $20, macro_status );
	jz not_macro_directive;
	movzx( (type byte [esi]), ecx );
	inc( esi );
	search_rsrvd_word_table( &macro_directives );
	jnc process_macro_directive;
	dec( esi );
	
  not_macro_directive:
	and( _byte( !$20 ), macro_status );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	mov( counter, eax );
	call get_macro_symbol;
	jnc group_macro_symbol;
	xor( eax, eax );
	cmp( counter, eax );
	je multiple_macro_symbol_values;
	call get_macro_symbol;
	jc not_macro_symbol;
	
  replace_macro_symbol:
	pop( edi );
	pop( eax );
	mov( [edx+8], ecx );
	and( !$80000000, ecx );
	mov( [edx+12], edx );
	or( edx, edx );
	jz replace_macro_counter;
	xchg( edx, esi );
	rep.movsb;
	mov( edx, esi );
	jmp process_macro_line_element;
	
  group_macro_symbol:
	xor( eax, eax );
	cmp( counter, eax );
	je replace_macro_symbol;
	push( esi );
	push( edx );
	sub( ecx, esi );
	call get_macro_symbol;
	mov( edx, ebx );
	pop( edx );
	pop( esi );
	jc replace_macro_symbol;
	cmp( edx, ebx );
	ja replace_macro_symbol;
	mov( ebx, edx );
	jmp replace_macro_symbol;
	
  multiple_macro_symbol_values:
	inc( eax );
	push( eax );
	call get_macro_symbol;
	pop( eax );
	jc not_macro_symbol;
	pop( edi );
	push( ecx );
	mov( [edx+8], ecx );
	mov( [edx+12], edx );
	xchg( edx, esi );
	btr( 31, ecx );
	jc enclose_macro_symbol_value;
	rep.movsb;
	jmp macro_symbol_value_ok;
	
  enclose_macro_symbol_value:
	mov( '<', (type byte [edi]) );
	inc( edi );
	rep.movsb;
	mov( '>', (type byte [edi]) );
	inc( edi );
	
  macro_symbol_value_ok:
	cmp( eax, counter_limit );
	je multiple_macro_symbol_values_ok;
	mov( ',', (type byte [edi]) );
	inc( edi );
	mov( edx, esi );
	pop( ecx );
	push( edi );
	sub( ecx, esi );
	jmp multiple_macro_symbol_values;
	
  multiple_macro_symbol_values_ok:
	pop( ecx );
	pop( eax );
	mov( edx, esi );
	jmp process_macro_line_element;
	
  replace_macro_counter:
	mov( counter, eax );
	and( !$80000000, eax );
	jz group_macro_counter;
	add( eax, ecx );
	dec( ecx );
	call store_number_symbol;
	jmp process_macro_line_element;
	
  group_macro_counter:
	mov( ecx, edx );
	xor( ecx, ecx );
	
  multiple_macro_counter_values:
	push( ecx );
	push( edx );
	add( edx, ecx );
	call store_number_symbol;
	pop( edx );
	pop( ecx );
	inc( ecx );
	cmp( ecx, counter_limit );
	je process_macro_line_element;
	mov( ',', (type byte [edi]) );
	inc( edi );
	jmp multiple_macro_counter_values;
	
  not_macro_symbol:
	pop( edi );
	pop( esi );
	mov( lenStrTkn, al );
	stosb;
	mov( [esi], al );
	inc( esi );
	stosb;
	cmp( (type byte [esi]), '.' );
	jne copy_raw_symbol;
	mov( [esp+8+8], ebx );
	or( ebx, ebx );
	jz copy_raw_symbol;
	cmp( al, 1 );
	je copy_struc_name;
	xchg( ebx, esi );
	movzx( (type byte [esi-1]), ecx );
	add( cl, [edi-1] );
	jc name_too_long;
	rep.movsb;
	xchg( ebx, esi );
	
  copy_raw_symbol:
	movzx( al, ecx );
	rep.movsb;
	jmp process_macro_line_element;
	
  copy_struc_name:
	inc( esi );
	xchg( ebx, esi );
	movzx( (type byte [esi-1]), ecx );
	mov( cl, [edi-1] );
	rep.movsb;
	xchg( ebx, esi );
	mov( [esp+8+12], eax );
	cmp( (type byte [eax]), auxDataToken );
	je process_macro_line_element;
	cmp( (type byte [eax]), lenStrTkn );
	jne disable_replaced_struc_name;
	mov( auxDataToken, (type byte [eax]) );
	jmp process_macro_line_element;
	
  disable_replaced_struc_name:
	mov( [esp+8+8], ebx );
	push( esi );
	push( edi );
	lea( edi, [ebx-3] );
	lea( esi, [edi-2] );
	lea( ecx, [esi+1] );
	sub( eax, ecx );
	std;
	rep.movsb;
	cld;
	mov( auxDataToken, (type word [eax]) );
	pop( edi );
	pop( esi );
	jmp process_macro_line_element;
	
	
  macro_foreign_line:
	call skip_foreign_symbol;
	
  macro_line_processed:
	mov( 0, (type byte [edi]) );
	inc( edi );
	push( eax );
	call preprocess_line;
	pop( eax );
	pop( ecx );
	pop( ebx );
	cmp( al, '}' );
	je macro_block_processed;
	
  process_next_line:
	inc( ecx );
	mov( esi, macro_line );
	add( 16+2, esi );
	jmp process_macro_line;
	
  macro_block_processed:
	call close_macro_block;
	jc process_macro_line;
	pop( current_line );
	add( 12, esp );
	pop( macro_block_line_number );
	pop( macro_block_line );
	pop( macro_block );
	pop( counter );
	pop( eax );
	and( $0F0, al );
	and( $0F, macro_status );
	or( al, macro_status );
	ret();
	
	
// Handle the macro "local" directive here.

local_symbols:

	lodsb;
	cmp( al, lenStrTkn );
	jne invalid_argument;
	mov( auxDataToken, (type byte [edi-1]) );
	xor( al, al );
	stosb;
	
  make_local_symbol:
	push( ecx );
	lodsb;
	movzx( al, ecx );
	mov( counter, eax );
	call add_macro_symbol;
	mov( edi, [edx+12] );
	movzx( locals_counter, eax );
	add( ecx, eax );
	inc( eax );
	cmp( eax, $100 );
	jae name_too_long;
	lea( ebp, [edi+eax+2] );
	out_of_mem( ae, ebp, memory_end );
	mov( al, ah );
	mov( lenStrTkn, al );
	stosw;
	rep.movsb;
	mov( '?', al );
	stosb;
	push( esi );
	mov( &locals_counter[1], esi );
	movzx( locals_counter, ecx );
	rep.movsb;
	pop( esi );
	mov( edi, eax );
	sub( [edx+12], eax );
	mov( eax, [edx+8] );
	xor( al, al );
	stosb;
	mov( &locals_counter, eax );
	movzx( (type byte [eax]), ecx );
	
  counter_loop:
	inc( (type byte [eax+ecx]) );
	cmp( (type byte [eax+ecx]), ':' );
	jb counter_ok;
	jne letter_digit;
	mov( 'A', (type byte [eax+ecx]) );
	jmp counter_ok;
	
  letter_digit:
	cmp( (type byte [eax+ecx]), 'F' );
	jbe counter_ok;
	mov( '0', (type byte [eax+ecx]) );
	loop counter_loop;
	
  counter_ok:
	pop( ecx );
	lodsb;
	cmp( al, '}' );
	je macro_block_processed;
	or( al, al );
	jz process_next_line;
	cmp( al, ',' );
	jne extra_characters_on_line;
	dec( edi );
	lodsb;
	cmp( al, lenStrTkn );
	je make_local_symbol;
	jmp invalid_argument;
	
// Handle the macro "common" directive here.

common_block:
	call close_macro_block;
	jc process_macro_line;
	mov( 0, counter );
	jmp new_macro_block;

// Handle the macro "forward" directive here.
	
forward_block:
	cmp( counter_limit, 0 );
	je common_block;
	call close_macro_block;
	jc process_macro_line;
	mov( 1, counter );
	jmp new_macro_block;

// Handle the macro "reverse" directive here.
	
reverse_block:
	cmp( counter_limit, 0 );
	je common_block;
	call close_macro_block;
	jc process_macro_line;
	mov( counter_limit, eax );
	or( $80000000, eax );
	mov( eax, counter );
	
  new_macro_block:
	mov( esi, macro_block );
	mov( macro_line, eax );
	mov( eax, macro_block_line );
	mov( ecx, macro_block_line_number );
	jmp process_macro_line;
	
end process_macro;








proc( add_preprocessor_symbol );

	push( edi );
	push( esi );
	call calculate_hash;
	mov( eax, ebp );
	and( $3FF, ebp );
	shr( 10, eax );
	xor( eax, ebp );
	shl( 22, ecx );
	or( ecx, ebp );
	mov( &hash_tree, ebx );
	mov( 32, ecx );
  find_leave_for_symbol:
	mov( [ebx], edx );
	or( edx, edx );
	jz extend_hashes_tree;
	xor( eax, eax );
	rol( 1, ebp );
	adc( 0, eax );
	lea( ebx, [edx+eax*4] );
	dec( ecx );
	jnz find_leave_for_symbol;
	mov( [ebx], edx );
	or( edx, edx );
	jz add_symbol_entry;
	shr( 30, ebp );
	cmp( ebp, %11 );
	je reuse_symbol_entry;
	cmp( (type dword [edx+4]), 0 );
	jne add_symbol_entry;
  find_entry_to_reuse:
	mov( [edx], edi );
	or( edi, edi );
	jz reuse_symbol_entry;
	cmp( (type dword [edi+4]), 0 );
	jne reuse_symbol_entry;
	mov( edi, edx );
	jmp find_entry_to_reuse;
  add_symbol_entry:
	mov( edx, eax );
	mov( labels_list, edx );
	sub( 16, edx );
	out_of_mem( b, edx, free_additional_memory );
	mov( edx, labels_list );
	mov( eax, [edx] );
	mov( edx, [ebx] );
  reuse_symbol_entry:
	pop( esi );
	pop( edi );
	mov( esi, [edx+4] );
	ret();

  extend_hashes_tree:
	mov( labels_list, edx );
	sub( 8, edx );
	out_of_mem( b, edx, free_additional_memory );
	mov( edx, labels_list );
	xor( eax, eax );
	mov( eax, [edx] );
	mov( eax, [edx+4] );
	shl( 1, ebp );
	adc( 0, eax );
	mov( edx, [ebx] );
	lea( ebx, [edx+eax*4] );
	dec( ecx );
	jnz extend_hashes_tree;
	mov( labels_list, edx );
	sub( 16, edx );
	out_of_mem( b, edx, free_additional_memory );
	mov( edx, labels_list );
	mov( 0, (type dword [edx]) );
	mov( edx, [ebx] );
	pop( esi );
	pop( edi );
	mov( esi, [edx+4] );
	ret();
	
end add_preprocessor_symbol;




	









// Process a path name (e.g., after
// an "include" directive).
//
// Basically, this copies characters from the source file
// to the memory-based destination file, expanding any
// environment variables if they are encountered.
//
// ESI	- Points at a zero-terminated string that is
//			the source pathname.
//
// EDI	- Points to where the processed pathname is
//			to go.
//
// On exit-
//	The byte range between EDI's value on input and
//	EDI's value on output contains the pathname string.

proc( preprocess_path );

	forever
	
		repeat
		
			lodsb;
			
			// A portion of the path surrounded by
			// '%' characters is an environment variable.
			// Check for that and go and expand it if we
			// counter such an item.
			
			cmp( al, '%' );
			je environment_variable;
			
			stosb;
			
		until( al = 0 );
		
		out_of_mem( a, edi, memory_end );
		ret();

		// Expand any environment variables
		// found within the pathname:
		
	  environment_variable:
		mov( esi, ebx );
		
		// Search for the trailing '%' of the
		// environment variable name:
		
	  	repeat
		
			lodsb;
			or( al, al );
			jz not_environment_variable;
			
		until( al = '%' );
		
		// Okay, we've found the end of the environment variable
		// name, now go get the value of that environment variable
		// and insert the corresponding text into the output stream.
		
		mov( 0, (type byte [esi-1]) );
		get_environment_variable( ebx );
		mov( '%', (type byte [esi-1]) );
		continue;
		
		// If we reached the end of the string,
		// then assume the '%' is part of the
		// filename rather than an environment
		// variable marker.
		  
	  not_environment_variable:
		mov( '%', al );
		stosb;
		mov( ebx, esi );
		
	endfor;
	
end preprocess_path;
	
	




proc
( 
	preprocess_line;

	  // The following entries form a jump table to the
	  // preprocessor functions. These must be maintained
	  // in alphabetical order.

	static  
	  preprocessor_directives:byte; @nostorage;
			symfunc_t( "define", define_symbolic_constant );
			symfunc_t( "include", include_file );
			symfunc_t( "irp", irp_directive );
			symfunc_t( "irps", irps_directive );
			symfunc_t( "macro", define_macro );
			symfunc_t( "match", match_directive );
			symfunc_t( "purge", purge_macro );
			symfunc_t( "rept", rept_directive );
			symfunc_t( "restore", restore_equ_constant );
			symfunc_t( "restruc", purge_struc );
			symfunc_t( "struc", define_struc );
			byte 0;
);

	mov( esp, eax );
	sub( $100, eax );
	jc stack_overflow;
	
	cmp( eax, stack_limit );
	jb stack_overflow;
	
	push( ecx );
	push( esi );
  preprocess_current_line:
	mov( current_line, esi );
	add( 16, esi );
	cmp( (type word [esi]), auxDataToken );
	jne line_start_ok;
	
	add( 2, esi );			// Point ESI at start of actual line.
  line_start_ok:
	test( $0F0, macro_status );	// Are we expanding a macro?
	jnz macro_preprocessing;
	
	// lenStrTkn ($1a) marks a length-prefixed token:
	
	cmp( (type byte [esi]), lenStrTkn );
	jne not_fix_constant;
	
	movzx( (type byte [esi+1]), edx );	// Get the length byte
	lea( edx, [esi+edx+2] );			// Point EDX at end of token.

	// Peek ahead one token and see if this is the "FIX"
	// directive. We need to handle that specially if it's there.
	// For this to be the fix directive, the next token must
	// be a length-prefixed token whose length is three.
	
	cmp( (type word [edx]), lenStrTkn + (3 << 8) );
	jne not_fix_constant;
	
	// Okay, the next token is a 3-character string,
	// let's see if it's "fix". Grab those three
	// characters, convert them to lower case,
	// and compare them against "fix".
	
	mov( &characters, ebx );
	movzx( (type byte [edx+2]), eax );	// 1st char
	xlat;
	ror( 8, eax );
	mov( [edx+3], al );					// 2nd char
	xlat;
	ror( 8, eax );
	mov( [edx+4], al );					// 3rd char
	xlat;
	ror( 16, eax );
	cmp( eax, asDword( "fix" ) );
	je define_fix_constant;
	
  not_fix_constant:
	call process_fix_constants;
	jmp initial_preprocessing_ok;
	
  define_fix_constant:
	add( 5, edx );		// Point EDX past the "fix"
	add( 2, esi );
	push( edx );
	push( esi );
	mov( edx, esi );
	call skip_parameters;
	xchg( [esp], esi );
	mov( %11, ch );
	jmp define_preprocessor_constant;
	
  define_equ_constant:
	add( 3, esi );
	push( esi );
	call process_equ_constants;
	push( esi );
	mov( struc_name, esi );
	mov( %10, ch );
	
  define_preprocessor_constant:
	mov( auxDataToken, (type byte [esi-2]) );
	mov( [esi-1], cl );
	call add_preprocessor_symbol;
	pop( esi );
	pop( ebx );
	mov( edi, ecx );
	dec( ecx );
	sub( ebx, ecx );
	mov( ebx, [edx+8] );
	mov( ecx, [edx+12] );
	jmp line_preprocessed;
	
	
// Handle the "define" directive here:

define_symbolic_constant:
	lodsb;
	cmp( al, lenStrTkn );
	jne invalid_name;
	
	lodsb;
	mov( al, cl );
	mov( %10, ch );
	call add_preprocessor_symbol;
	movzx( (type byte [esi-1]), eax );
	add( eax, esi );
	push( esi );
	push( edx );
	call skip_parameters;
	pop( edx );
	pop( ebx );
	lea( ecx, [esi-1] );
	sub( ebx, ecx );
	mov( ebx, [edx+8] );
	mov( ecx, [edx+12] );
	jmp line_preprocessed;
	
	
  macro_preprocessing:
	call process_macro_operators;
	
  initial_preprocessing_ok:
	mov( current_line, esi );
	add( 16, esi );
	mov( macro_status, al );
	test( 2, al );
	jnz skip_macro_block;
	
	test( 1, al );
	jnz find_macro_block;
	
  preprocess_instruction::
	mov( esi, current_offset );
	lodsb;
	movzx( (type byte [esi]), ecx );
	inc( esi );
	cmp( al, lenStrTkn );
	jne not_preprocessor_symbol;
	
	cmp( cl, 3 );
	jb not_preprocessor_directive;
	
	push( edi );
	search_rsrvd_word_table( &preprocessor_directives );
	pop( edi );
	jc not_preprocessor_directive;
	
	mov( auxDataToken, (type byte [edx-2]) );
	jmp( eax );
	
  not_preprocessor_directive:
	xor( ch, ch );
	call get_preprocessor_symbol;
	jc not_macro;
	
	mov( auxDataToken, (type byte [ebx-2]) );
	mov( 0, struc_name );
	jmp use_macro;
	
  not_macro:
	mov( esi, struc_name );
	add( ecx, esi );
	lodsb;
	cmp( al, ':' );
	je preprocess_label;
	
	cmp( al, lenStrTkn );
	jne not_preprocessor_symbol;
	
	lodsb;
	cmp( al, 3 );
	jne not_symbolic_constant;
	
	mov( &characters, ebx );
	movzx( (type byte [esi]), eax );
	xlat;
	ror( 8, eax );
	mov( [esi+1], al );
	xlat;
	ror( 8, eax );
	mov( [esi+2], al );
	xlat;
	ror( 16, eax );
	cmp( eax, asDword( "equ" ) );
	je define_equ_constant;
	
	mov( 3, al );
  not_symbolic_constant:
	mov( 1, ch );
	mov( al, cl );
	call get_preprocessor_symbol;
	jc not_preprocessor_symbol;
	
	push( edx );
	push( esi );
	mov( struc_name, esi );
	mov( esi, struc_label );
	sub( 2, struc_label );
	mov( [esi-1], cl );
	mov( %10, ch );
	call get_preprocessor_symbol;
	jc struc_name_ok;
	
	mov( [edx+12], ecx );
	add( 3, ecx );
	lea( ebx, [edi+ecx] );
	mov( edi, ecx );
	sub( struc_label, ecx );
	lea( esi, [edi-1] );
	lea( edi, [ebx-1] );
	std;
	rep.movsb;
	cld;
	mov( struc_label, edi );
	mov( [edx+8], esi );
	mov( [edx+12], ecx );
	add( ecx, struc_name );
	add( 3, struc_name );
	call move_data;
	mov( $3A, al );
	stosb;
	mov( auxDataToken, ax );
	stosw;
	mov( ebx, edi );
	pop( esi );
	add( [edx+12], esi );
	add( 3, esi );
	pop( edx );
	jmp use_macro;
	
  struc_name_ok:
	mov( struc_name, edx );
	movzx( (type byte [edx-1]), eax );
	add( eax, edx );
	mov( $3A, al );
	mov( al, [edx] );
	inc( al );
	xchg( [edx+1], al );
	dec( al );
	mov( al, [edx+2] );
	pop( esi );
	pop( edx );
	jmp use_macro;
	
  preprocess_label:
	dec( esi );
	sub( ecx, esi );
	lea( ebp, [esi-2] );
	mov( %10, ch );
	call get_preprocessor_symbol;
	jnc symbolic_constant_in_label;
	
	lea( esi, [esi+ecx+1] );
	jmp preprocess_instruction;
	
  symbolic_constant_in_label:
	mov( [edx+8], ebx );
	mov( [edx+12], ecx );
	add( ebx, ecx );
	
  check_for_broken_label:
	cmp( ebx, ecx );
	je label_broken;
	
	cmp( (type byte [ebx]), lenStrTkn );
	jne label_broken;
	
	movzx( (type byte [ebx+1]), eax );
	lea( ebx, [ebx+eax+2] );
	cmp( ebx, ecx );
	je label_constant_ok;
	
	cmp( (type byte [ebx]), ':' );
	jne label_broken;
	
	inc( ebx );
	jmp check_for_broken_label;
	
  label_broken:
	pushd( &line_preprocessed );
	jmp replace_symbolic_constant;
	
  label_constant_ok:
	mov( edi, ecx );
	sub( esi, ecx );
	mov( [edx+12], edi );
	add( ebp, edi );
	push( edi );
	lea( eax, [edi+ecx] );
	push( eax );
	cmp( esi, edi );
	je replace_label;
	jb move_rest_of_line_up;
	
	rep.movsb;
	jmp replace_label;
	
  move_rest_of_line_up:
	lea( esi, [esi+ecx-1] );
	lea( edi, [edi+ecx-1] );
	std;
	rep.movsb;
	cld;
	
  replace_label:
	mov( [edx+12], ecx );
	mov( [esp+4], edi );
	sub( ecx, edi );
	mov( [edx+8], esi );
	rep.movsb;
	pop( edi );
	pop( esi );
	inc( esi );
	jmp preprocess_instruction;
	
  not_preprocessor_symbol:
	mov( current_offset, esi );
	call process_equ_constants;
	
  line_preprocessed:
	pop( esi );
	pop( ecx );
	ret();

  use_macro:
	push( free_additional_memory );
	push( macro_symbols );
	mov( 0, macro_symbols );
	push( counter_limit );
	push( (type dword [edx+4]) );
	mov( 1, (type dword [edx+4]) );
	push( edx );
	mov( esi, ebx );
	mov( [edx+8], esi );
	mov( [edx+12], eax );
	mov( eax, macro_line );
	mov( 0, counter_limit );
	
  process_macro_arguments:
	mov( [esi], al );
	or( al, al );
	jz arguments_end;
	
	cmp( al, '{' );
	je arguments_end;
	
	inc( esi );
	cmp( al, '[' );
	jne get_macro_arguments;
	
	mov( esi, ebp );
	inc( esi );
	inc( counter_limit );
	
  get_macro_arguments:
	call get_macro_argument;
	lodsb;
	cmp( al, ',' );
	je next_argument;
	
	cmp( al, ']' );
	je next_arguments_group;
	
	dec( esi );
	jmp arguments_end;
	
  next_argument:
	cmp( (type byte [ebx]), ',' );
	jne process_macro_arguments;
	inc( ebx );
	jmp process_macro_arguments;
	
  next_arguments_group:
	cmp( (type byte [ebx]), ',' );
	jne arguments_end;
	
	inc( ebx );
	inc( counter_limit );
	mov( ebp, esi );
	jmp process_macro_arguments;
	

  arguments_end:
	cmp( (type byte [ebx]), 0 );
	jne invalid_macro_arguments;
	
	mov( [esp+4], eax );
	dec( eax );
	call process_macro;
	pop( edx );
	pop( (type dword [edx+4]) );
	pop( counter_limit );
	pop( macro_symbols );
	pop( free_additional_memory );
	jmp line_preprocessed;
	

// Handle include files here:
//
//	ESI- Pointer into source file.
//	EDI- Pointer to preprocessed output.
	
	debugStr( "include_file" )
include_file:

	// Check to see if the operand is a string literal.
	// (Note that string literals are encoded as <">, <4-byte Len> <chars> <0>.)
	
	lodsb;
	cmp( al, '"' );
	jne invalid_argument;
	
	// A dword containing the length follows the quote:
	
	lodsd;
	
	// Consistency check - make sure the string is
	// zero-terminated.
	
	cmp( (type byte [esi+eax]), 0 );
	jne extra_characters_on_line;
	
	push( esi );				// Save ptr to start of char data
	push( edi );				// Save output ptr.
	mov( current_line, ebx );
	
  find_current_file_path:
	mov( [ebx], esi );
	
	// If bit 7 of byte 7 is set, then we have
	// an indirect line reference (i.e, a text replacement).
	// Bytes $8..$B contain a pointer to the actual line
	// of text.
	
	test( $80, (type byte [ebx+7]) );
	jz copy_current_file_path;
	
	mov( [ebx+8], ebx );
	jmp find_current_file_path;
	
	// When we get to the line that actually has the
	// text we want, copy all the characters up to the
	// zero terminating byte from the source line to the
	// destination output:
	
  copy_current_file_path:
	lodsb;
	stosb;
	or( al, al );
	jnz copy_current_file_path;
	
	// Search for the beginning of the file name
	// (that is, backwards to the beginning of the
	// string or to the last '/' or '\' in the path).
	
  cut_current_file_name:
	cmp( edi, [esp] );
	je current_file_path_ok;
	
	cmp( (type byte [edi-1]), '\' );
	je current_file_path_ok;
	cmp( (type byte [edi-1]), '/' );
	je current_file_path_ok;
	dec( edi );
	jmp cut_current_file_name;
	
  current_file_path_ok:
	mov( [esp+4], esi );	// Retrieve pointer to include char data.
	call preprocess_path;
	pop( edx );				// Retrieve ptr to start of output.
	mov( edx, esi );
	exists( esi );			// See if file exists.
	jnc include_path_ok;
	
	// If the file does not exist in the
	// specified path, try searching for
	// it in the directories specified by
	// the INCLUDE environment variable.
	
	mov( include_paths, ebp );
  try_include_directories:
	mov( esi, edi );
	mov( ebp, esi );
	cmp( (type byte [esi]), 0 );	// At end of include list?
	je try_in_current_directory;
	
	push( ebp );
	push( edi );
	repeat
	
		lodsb;
		cmp( al, ';' );				// Paths in include list
		je include_directory_ok;	// are separated by ';' chars.
		
		stosb;
		
	until( al = 0 );
	
	dec( esi );		// Back up before the zero byte.
	dec( edi );
	
	// Does the include path end with a path separator?
	
  include_directory_ok:
	cmp( (type byte [edi-1]), '/' );
	je path_separator_ok;
	
	cmp( (type byte [edi-1]), '\' );
	je path_separator_ok;
	
	// If it does not end with a path separator, add one.
	
	mov( '/', al );
	stosb;
	
	// Okay, go expand any environment variables
	// that may be in the INCLUDE paths.
	
  path_separator_ok:
	mov( esi, [esp+4] );
	mov( [esp+8], esi );
	call preprocess_path;
	pop( edx );
	
	exists( edx );
	pop( ebp );
	jnc include_path_ok;
	jmp try_include_directories;
	
	// If we've reached the end of the INCLUDE
	// list, try searching for the include file
	// in the current directory (design question:
	// if the original check isn't doing this,
	// shouldn't we search in the current directory
	// *first*?)
	
  try_in_current_directory:
	mov( [esp], esi );
	push( edi );
	call preprocess_path;
	pop( edx );
	exists( edx );
	jc file_not_found;
	
  include_path_ok:
	mov( [esp], edi );
	
	// Okay, at this point the file exists at the
	// specified path, so copy the path to the
	// output stream.
	
  	repeat
	
		lodsb;
		stosb;
		
	until( al = 0 );
	
	// Okay, let's go grab the include file
	// and insert it into our output stream
	// we're building.
	//
	// Note: EDX points at a zstring 
	// containing the pathname.
	
	pop( esi );				// Grab pointer to start of path
	lea( ecx, [edi-1] );	// Pointer to last char of path
	sub( esi, ecx );		// length of path
	mov( ecx, [esi-4] );	// Store away length in length slot.
	
	// Recursively call preprocess_file to insert the
	// include file into our output stream.
	
	push( (type dword macro_status) );
	and( $0F, macro_status );
	preprocess_file( edx, aerr.file_not_found );
	pop( eax );
	mov( al, macro_status );
	jmp line_preprocessed;
	

	
// Handle the irp directive here.
	
irp_directive:
	mov( 1, base_code );
	jmp define_instant_macro;


// Handle irps directive here.
	
irps_directive:
	mov( 2, base_code );
	jmp define_instant_macro;

// Handle the match directive here
	
match_directive:
	mov( $10, base_code );
	
  define_instant_macro:
	mov( macro_status, al );
	and( $0F0, al );
	or( 8+1, al );
	mov( al, macro_status );
	mov( current_line, eax );
	mov( eax, error_line );
	mov( esi, instant_macro_start );
	cmp( base_code, $10 );
	je prepare_match;
	call skip_parameters;
	
  instant_macro_parameters_skipped:
	dec( esi );
	mov( esi, parameters_end );
	lodsb;
	cmp( al, '{' );
	je found_macro_block;
	
	or( al, al );
	jnz invalid_macro_arguments;
	jmp line_preprocessed;
	
  prepare_match:
	call skip_pattern;
	mov( $80+%10, value_type );
	call process_symbolic_constants;
	jmp instant_macro_parameters_skipped;
	
  use_instant_macro:
	push( edi );
	push( current_line );
	push( esi );
	mov( error_line, eax );
	mov( eax, current_line );
	mov( eax, macro_line );
	mov( instant_macro_start, esi );
	cmp( base_code, $10 );
	jae do_match;
	
	cmp( base_code, 0 );
	jne do_irp;
	
	call get_number;
	jc invalid_value;
	
	or( ebp, ebp );
	jnz invalid_value;
	
	cmp( (type dword [edi+4]), 0 );
	jne value_out_of_range;
	
	mov( [edi], eax );
	or( eax, eax );
	jz instant_macro_done;
	
	cmp( eax, $80000000 );
	jae value_out_of_range;
	
	push( free_additional_memory );
	push( macro_symbols );
	mov( 0, macro_symbols );
	push( counter_limit );
	mov( 0, struc_name );
	mov( eax, counter_limit );
	lodsb;
	or( al, al );
	jz rept_counters_ok;
	
	cmp( al, '{' );
	je rept_counters_ok;
	
	cmp( al, lenStrTkn );
	jne invalid_macro_arguments;
	
  add_rept_counter:
	lodsb;
	movzx( al, ecx );
	xor( eax, eax );
	call add_macro_symbol;
	add( ecx, esi );
	xor( eax, eax );
	mov( eax, (type dword [edx+12]) );
	inc( eax );
	mov( eax, (type dword [edx+8]) );
	lodsb;
	cmp( al, ':' );
	jne rept_counter_added;
	
	push( edx );
	call get_number;
	jc invalid_value;
	
	or( ebp, ebp );
	jnz invalid_value;
	
	cmp( (type dword [edi+4]), 0 );
	jne value_out_of_range;
	
	mov( [edi], eax );
	mov( eax, edx );
	add( counter_limit, edx );
	jc value_out_of_range;
	
	pop( edx );
	mov( eax, (type dword [edx+8]) );
	lodsb;
	
  rept_counter_added:
	cmp( al, ',' );
	jne rept_counters_ok;
	
	lodsb;
	cmp( al, lenStrTkn );
	jne invalid_macro_arguments;
	jmp add_rept_counter;
	
  rept_counters_ok:
	dec( esi );
	
  instant_macro_parameters_ok:
	xor( eax, eax );
	call process_macro;
	pop( counter_limit );
	pop( macro_symbols );
	pop( free_additional_memory );
	
  instant_macro_done:
	pop( ebx );
	pop( esi );
	pop( edx );
	cmp( (type byte [ebx]), 0 );
	je line_preprocessed;
	
	mov( edi, current_line );
	mov( 4, ecx );
	rep.movsd;
	test( $0F, macro_status );
	jz instant_macro_attached_line;
	
	mov( auxDataToken, ax );
	stosw;
	
  instant_macro_attached_line:
	mov( ebx, esi );
	sub( ebx, edx );
	mov( edx, ecx );
	call move_data;
	jmp preprocess_current_line;
	
  do_irp:
	cmp( (type byte [esi]), lenStrTkn );
	jne invalid_macro_arguments;
	
	movzx( (type byte [esi+1]), eax );
	lea( esi, [esi+eax+2] );
	lodsb;
	cmp( base_code, 1 );
	ja irps_name_ok;
	
	cmp( al, '*' );
	jne irp_name_ok;
	
	lodsb;
  irp_name_ok:
	cmp( al, ',' );
	jne invalid_macro_arguments;
	jmp irp_parameters_start;
	
  irps_name_ok:
	cmp( al, ',' );
	jne invalid_macro_arguments;
	
	mov( [esi], al );
	or( al, al );
	jz instant_macro_done;
	
	cmp( al, '{' );
	je instant_macro_done;
	
  irp_parameters_start:
	xor( eax, eax );
	push( free_additional_memory );
	push( macro_symbols );
	mov( eax, macro_symbols );
	push( counter_limit );
	mov( eax, counter_limit );
	mov( eax, struc_name );
	mov( esi, ebx );
	cmp( base_code, 1 );
	ja get_irps_parameter;
	
	mov( parameters_end, edx );
	mov( [edx], al );
	push( eax );
	mov( 0, (type byte [edx]) );
	
  get_irp_parameter:
	inc( counter_limit );
	mov( instant_macro_start, esi );
	inc( esi );
	call get_macro_argument;
	cmp( (type byte [ebx]), ',' );
	jne irp_parameters_end;
	
	inc( ebx );
	jmp get_irp_parameter;
	
  irp_parameters_end:
	mov( ebx, esi );
	pop( eax );
	mov( al, [esi] );
	jmp instant_macro_parameters_ok;
	
  get_irps_parameter:
	mov( instant_macro_start, esi );
	inc( esi );
	lodsb;
	movzx( al, ecx );
	inc( counter_limit );
	mov( counter_limit, eax );
	call add_macro_symbol;
	mov( ebx, [edx+12] );
	cmp( (type byte [ebx]), lenStrTkn );
	je irps_symbol;
	
	cmp( (type byte [ebx]), '"' );
	je irps_quoted_string;
	
	mov( 1, eax );
	jmp irps_parameter_ok;
	
  irps_quoted_string:
	mov( [ebx+1], eax );
	add( 1+4, eax );
	jmp irps_parameter_ok;
	
  irps_symbol:
	movzx( (type byte [ebx+1]), eax );
	add( 1+1, eax );
	
  irps_parameter_ok:
	mov( eax, [edx+8] );
	add( eax, ebx );
	cmp( (type byte [ebx]), 0 );
	je irps_parameters_end;
	
	cmp( (type byte [ebx]), '{' );
	jne get_irps_parameter;
	
  irps_parameters_end:
	mov( ebx, esi );
	jmp instant_macro_parameters_ok;
	
  do_match:
	mov( esi, ebx );
	call skip_pattern;
	call exact_match;
	mov( edi, edx );
	mov( [ebx], al );
	cmp( al, lenStrTkn );
	je free_match;
	
	cmp( al, ',' );
	jne instant_macro_done;
	
	cmp( esi, parameters_end );
	je matched_pattern;
	jmp instant_macro_done;
	
  free_match:
	add( 12, edx );
	out_of_mem( a, edx, memory_end );
	
	mov( ebx, [edx-12] );
	mov( esi, [edx-8] );
	call skip_match_element;
	jc try_different_matching;
	
	mov( esi, [edx-4] );
	movzx( (type byte [ebx+1]), eax );
	lea( ebx, [ebx+eax+2] );
	cmp( (type byte [ebx]), lenStrTkn );
	je free_match;
	
  find_exact_match:
	call exact_match;
	cmp( esi, parameters_end );
	je end_matching;
	
	cmp( (type byte [ebx]), lenStrTkn );
	je free_match;
	
	mov( [edx-12], ebx );
	movzx( (type byte [ebx+1]), eax );
	lea( ebx, [ebx+eax+2] );
	mov( [edx-4], esi );
	jmp match_more_elements;
	
  try_different_matching:
	sub( 12, edx );
	cmp( edx, edi );
	je instant_macro_done;
	
	mov( [edx-12], ebx );
	movzx( (type byte [ebx+1]), eax );
	lea( ebx, [ebx+eax+2] );
	cmp( (type byte [ebx]), lenStrTkn );
	je try_different_matching;
	
	mov( [edx-4], esi );
  match_more_elements:
	call skip_match_element;
	jc try_different_matching;
	
	mov( esi, [edx-4] );
	jmp find_exact_match;
	


  end_matching:
	cmp( (type byte [ebx]), ',' );
	jne instant_macro_done;
	
  matched_pattern:
	xor( eax, eax );
	push( free_additional_memory );
	push( macro_symbols );
	mov( eax, macro_symbols );
	push( counter_limit );
	mov( eax, counter_limit );
	mov( eax, struc_name );
	push( esi );
	push( edi );
	push( edx );
	
  add_matched_symbol:
	cmp( edi, [esp] );
	je matched_symbols_ok;
	
	mov( [edi], esi );
	inc( esi );
	lodsb;
	movzx( al, ecx );
	xor( eax, eax );
	call add_macro_symbol;
	mov( [edi+4], eax );
	mov( eax, (type dword [edx+12]) );
	mov( [edi+8], ecx );
	sub( eax, ecx );
	mov( ecx, (type dword [edx+8]) );
	add( 12, edi );
	jmp add_matched_symbol;
	
  matched_symbols_ok:
	pop( edx );
	pop( edi );
	pop( esi );
	jmp instant_macro_parameters_ok;
	
	
// Handle the "struc" directive here:

define_struc:
	mov( 1, ch );
	jmp make_macro;


	
// Handle the "macro" directive here.

define_macro: 
	xor( ch, ch );
	
  make_macro:
	lodsb;
	cmp( al, lenStrTkn );
	jne invalid_name;
	
	lodsb;
	mov( al, cl );
	call add_preprocessor_symbol;
	mov( current_line, eax );
	mov( eax, [edx+12] );
	movzx( (type byte [esi-1]), eax );
	add( eax, esi );
	mov( esi, [edx+8] );
	mov( macro_status, al );
	and( $0F0, al );
	or( 1, al );
	mov( al, macro_status );
	mov( current_line, eax );
	mov( eax, error_line );
	xor( bl, bl );
	lodsb;
	or( al, al );
	jz line_preprocessed;
	
	cmp( al, '{' );
	je found_macro_block;
	
	dec( esi );	
  skip_macro_arguments:
	lodsb;
	cmp( al, lenStrTkn );
	je skip_macro_argument;
	
	cmp( al, '[' );
	jne invalid_macro_arguments;
	
	xor( -1, bl );
	jz invalid_macro_arguments;
	
	lodsb;
	cmp( al, lenStrTkn );
	jne invalid_macro_arguments;
	
  skip_macro_argument:
	movzx( (type byte [esi]), eax );
	inc( esi );
	add( eax, esi );
	lodsb;
	cmp( al, '*' );
	jne macro_argument_end;
	
	lodsb;
  macro_argument_end:
	cmp( al, ',' );
	je skip_macro_arguments;
	
	cmp( al, ']' );
	jne end_macro_arguments;
	
	lodsb;
	not( bl );
  end_macro_arguments:
	or( bl, bl );
	jnz invalid_macro_arguments;
	
	or( al, al );
	jz line_preprocessed;
	
	cmp( al, '{' );
	je found_macro_block;
	jmp invalid_macro_arguments;
	
	
  find_macro_block:
	add( 2, esi );
	lodsb;
	or( al, al );
	jz line_preprocessed;
	
	cmp( al, '{' );
	jne unexpected_characters;
	
  found_macro_block:
	or( 2, macro_status );
	
  skip_macro_block:
  	repeat
	
		lodsb;
		cmp( al, lenStrTkn );
		je skip_macro_symbol;
		
		cmp( al, auxDataToken );
		je skip_macro_symbol;
		
		cmp( al, '"' );
		je skip_macro_string;
		
		or( al, al );
		jz line_preprocessed;
	
	until( al = '}' );
		
	mov( macro_status, al );
	and( $0F0, macro_status );
	test( 8, al );
	jnz use_instant_macro;
	
	cmp( (type byte [esi]), 0 );
	je line_preprocessed;
	
	mov( edi, ecx );
	sub( esi, ecx );
	mov( esi, edx );
	lea( esi, [esi+ecx-1] );
	lea( edi, [edi+1+16] );
	mov( edi, ebx );
	dec( edi );
	std;
	rep.movsb;
	cld;
	mov( edx, edi );
	xor( al, al );
	stosb;
	mov( current_line, esi );
	mov( edi, current_line );
	mov( 4, ecx );
	rep.movsd;
	mov( ebx, edi );
	jmp preprocess_current_line;
	
  skip_macro_symbol:
	movzx( (type byte [esi]), eax );
	inc( esi );
	add( eax, esi );
	jmp skip_macro_block;
	
  skip_macro_string:
	lodsd;
	add( eax, esi );
	jmp skip_macro_block;

// Handle the rept directive here:
	
rept_directive:
	mov( 0, base_code );
	jmp define_instant_macro;
	
	
// Handle the "purge" directive here

purge_macro:
	xor( ch, ch );
	jmp restore_preprocessor_symbol;


// Handle the "restruc" directive here:

purge_struc:
	mov( 1, ch );
	jmp restore_preprocessor_symbol;
	
// Handle the "restore" directive here:

restore_equ_constant:
	mov( %10, ch );

  restore_preprocessor_symbol:
	push( ecx );
	lodsb;
	cmp( al, lenStrTkn );
	jne invalid_name;
	
	lodsb;
	mov( al, cl );
	call get_preprocessor_symbol;
	jc no_symbol_to_restore;
	
	mov( 0, (type dword [edx+4]) );
	jmp symbol_restored;
	
  no_symbol_to_restore:
	add( ecx, esi );
	
  symbol_restored:
	pop( ecx );
	lodsb;
	cmp( al, ',' );
	je restore_preprocessor_symbol;
	
	or( al, al );
	jnz extra_characters_on_line;
	ret();
	

end preprocess_line;




proc
( 
	preprocess_file
	(
		filename		:string in edx;
		fileException	:dword in eax
	); 
);

	readFileIntoMemory( edx, fileException );
	
	// At this point:
	//
	//	EDI must point to the start of the free memory block.
	//	ESI points at the start of the file in memory.
	//  ECX contains the length of the file in memory.
	//	EDX must point at the filename string.
	
	push( memory_end );
	xor( ecx, ecx );
	mov( esi, ebx );
	
  preprocess_source:
	inc( ecx );
	mov( edi, current_line );
	mov( edx, eax );
	stosd;				// Pointer to filename
	mov( ecx, eax );
	stosd;				// Line #
	mov( esi, eax );
	sub( ebx, eax );
	stosd;				// Length
	xor( eax, eax );
	stosd;
	push( ebx );
	push( edx );
	call convert_line;
	call preprocess_line;
	pop( edx );
	pop( ebx );
	
	cmp( (type byte [esi-1]), lenStrTkn );
	jne preprocess_source;
	
  file_end:
	pop( memory_end );
	ret();
	
end preprocess_file;





proc( preprocessor );

	getenv( "INCLUDE" );
	mov( eax, include_paths );
	
	mov( additional_memory, eax );
	mov( eax, free_additional_memory );
	mov( additional_memory_end, eax );
	mov( eax, labels_list );
	xor( eax, eax );
	mov( eax, display_buffer );
	mov( eax, hash_tree );
	mov( al, macro_status );
	mov( memory_start, edi );	
	preprocess_file( input_file, fatal.main_file_not_found );

	mov( error_line, eax );
	mov( eax, current_line );
	cmp( macro_status, 0 );
	jne incomplete_macro;
	mov( edi, source_start );
	ret();
	
end preprocessor;



/////////////////////////////////////////////////////////////////




proc( fp_mul );

	or( ecx, ecx );
	jz fp_zero;
	mov( [edi+12], eax );
	mul( ecx );
	mov( eax, [edi+12] );
	mov( edx, ebx );
	mov( [edi], eax );
	mul( ecx );
	add( ebx, eax );
	adc( 0, edx );
	mov( eax, [edi] );
	mov( edx, ebx );
	mov( [edi+4], eax );
	mul( ecx );
	add( ebx, eax );
	adc( 0, edx );
	mov( eax, [edi+4] );
  _loop_:
	or( edx, edx );
	jz _done_;
	mov( [edi], eax );
	shrd( 1, eax, [edi+12] );
	mov( [edi+4], eax );
	shrd( 1, eax, [edi] );
	shrd( 1, edx, eax );
	mov( eax, [edi+4] );
	shr( 1, edx );
	inc( (type dword [edi+8]) );
	cmp( (type dword [edi+8]), $8000 );
	jge value_out_of_range;
	jmp _loop_;
  _done_:
	ret();
	
  fp_zero:
	mov( $8000, (type dword [edi+8]) );
	ret();
	
end fp_mul;


proc( fp_div );

	mov( [edi+4], eax );
	xor( edx, edx );
	div( ecx );
	mov( eax, [edi+4] );
	mov( [edi], eax );
	div( ecx );
	mov( eax, [edi] );
	mov( [edi+12], eax );
	div( ecx );
	mov( eax, [edi+12] );
	mov( eax, ebx );
	or( [edi], ebx );
	or( [edi+4], ebx );
	jz fp_zero;
  _loop_:
	test( $80, (type byte [edi+7]) );
	jnz _exp_ok_;
	mov( [edi], eax );
	shld( 1, eax, [edi+4] );
	mov( [edi+12], eax );
	shld( 1, eax, [edi] );
	add( eax, eax );
	mov( eax, [edi+12] );
	dec( (type dword [edi+8]) );
	add( edx, edx );
	jmp _loop_;
  _exp_ok_:
	mov( edx, eax );
	xor( edx, edx );
	div( ecx );
	add( eax, [edi+12] );
	adc( 0, (type dword [edi]) );
	adc( 0, (type dword [edi+4]) );
	jnc _done_;
	mov( [edi+4], eax );
	mov( [edi], ebx );
	shrd( 1, eax, [edi] );
	shrd( 1, ebx, [edi+12] );
	shr( 1, eax );
	or( $80000000, eax );
	mov( eax, [edi+4] );
	inc( (type dword [edi+8]) );
  _done_:
	ret();

  fp_zero:
	mov( $8000, (type dword [edi+8]) );
	ret();
		
end fp_div;



proc( fp_add );

	cmp( (type dword [ebx+8]), $8000 );
	je _done_;
	cmp( (type dword [edi+8]), $8000 );
	je _copy_;
	mov( [ebx+8], eax );
	cmp( eax, [edi+8] );
	jge _exp_ok_;
	mov( [edi+8], eax );
  _exp_ok_:
	call _change_exp_;
	xchg( edi, ebx );
	call _change_exp_;
	xchg( edi, ebx );
	mov( [ebx+12], edx );
	mov( [ebx], eax );
	mov( [ebx+4], ebx );
	add( edx, [edi+12] );
	adc( eax, [edi] );
	adc( ebx, [edi+4] );
	jnc _done_;
	mov( [edi], eax );
	shrd( 1, eax, [edi+12] );
	mov( [edi+4], eax );
	shrd( 1, eax, [edi] );
	shr( 1, eax );
	or( $80000000, eax );
	mov( eax, [edi+4] );
	inc( (type dword [edi+8]) );
  _done_:
	ret();

  _copy_:
	mov( [ebx], eax );
	mov( eax, [edi] );
	mov( [ebx+4], eax );
	mov( eax, [edi+4] );
	mov( [ebx+8], eax );
	mov( eax, [edi+8] );
	mov( [ebx+12], eax );
	mov( eax, [edi+12] );
	ret();

  _change_exp_:
	push( ecx );
	mov( eax, ecx );
	sub( [ebx+8], ecx );
	mov( [ebx+4], edx );
	jecxz _exp_done_;
  _exp_loop:
	mov( [ebx], ebp );
	shrd( 1, ebp, [ebx+12] );
	shrd( 1, edx, [ebx] );
	shr( 1, edx );
	inc( (type dword [ebx+8]) );
	loop _exp_loop;
  _exp_done_:
	mov( edx, [ebx+4] );
	pop( ecx );
	ret();

end fp_add;


proc( fp_optimize );

	mov( [edi], eax );
	mov( [edi+4], ebp );
	or( [edi], ebp );
	or( [edi+12], ebp );
	jz fp_zero;
  _loop_:
	test( $80, (type byte [edi+7]) );
	jnz _done_;
	shld( 1, eax, [edi+4] );
	mov( [edi+12], ebp );
	shld( 1, ebp, eax );
	mov( eax, [edi] );
	shl( 1, (type dword [edi+12]) );
	dec( (type dword [edi+8]) );
	jmp _loop_;
  _done_:
	ret();

  fp_zero:
	mov( $8000, (type dword [edi+8]) );
	ret();
	
end fp_optimize;



proc( convert_number );

	lea( eax, [edi-$10] );
	out_of_mem( ae, eax, labels_list );
	cmp( (type byte [esi]), '(' );
	je expression_value;
	inc( edi );
	call get_number;
	jc symbol_value;
	or( ebp, ebp );
	jz valid_number;
	mov( $0F, (type byte [edi-1]) );
	ret();

  valid_number:
	cmp( (type dword [edi+4]), 0 );
	jne qword_number;
	cmp( (type word [edi+2]), 0 );
	jne dword_number;
	cmp( (type byte [edi+1]), 0 );
	jne word_number;
  byte_number:
	mov( 1, (type byte [edi-1]) );
	inc( edi );
	ret();

  qword_number:
	mov( 8, (type byte [edi-1]) );
	add( 8, edi );
	ret();

  dword_number:
	mov( 4, (type byte [edi-1]) );
	scasd;
	ret();

  word_number:
	mov( 2, (type byte [edi-1]) );
	scasw;
	ret();
	
  expression_value:
	mov( esp, eax );
	sub( $100, eax );
	jc stack_overflow;
	cmp( eax, stack_limit );
	jb stack_overflow;
	inc( esi );
	push( current_offset );
	call convert_expression;
	pop( current_offset );
	lodsb;
	cmp( al, ')' );
	jne invalid_expression;
	ret();

  symbol_value:
	lodsb;
	cmp( al, lenStrTkn );
	jne invalid_value;
	lodsb;
	movzx( al, ecx );
	push( ecx );
	push( esi );
	push( edi );
	//mov( &address_registers, edi );
	get_symbol( &address_registers );
	jnc register_value;
	mov( &directive_operators, edi );
	call get_symbol;
	pop( edi );
	pop( esi );
	pop( ecx );
	jnc broken_value;
	
	call get_label_id;
  store_label_value:
	mov( $11, (type byte [edi-1]) );
	stosd;
	ret();

  broken_value:
	sub( 2, esi );
	or( -1, eax );
	jmp store_label_value;
	
  register_value:
	pop( edi );
	add( 8, esp );
	mov( $10, (type byte [edi-1]) );
	mov( ah, al );
	stosb;
	ret();

	
	
end convert_number;



proc( get_fp_value );

	push( edi );
	push( esi );
	lodsb;
	cmp( al, lenStrTkn );
	je fp_value_start;
	cmp( al, '-' );
	je fp_sign_ok;
	cmp( al, '+' );
	jne not_fp_value;
	
  fp_sign_ok:
	lodsb;
	cmp( al, lenStrTkn );
	jne not_fp_value;
	
  fp_value_start:
	lodsb;
	movzx( al, ecx );
	cmp( cl, 1 );
	jbe not_fp_value;
	lea( edx, [esi+1] );
	xor( ah, ah );
	
  check_fp_value:
	lodsb;
	cmp( al, '.' );
	je fp_character_dot;
	cmp( al, 'E' );
	je fp_character_exp;
	cmp( al, 'e' );
	je fp_character_exp;
	cmp( al, 'F' );
	je fp_last_character;
	cmp( al, 'f' );
	je fp_last_character;
	
  digit_expected:
	cmp( al, '0' );
	jb not_fp_value;
	cmp( al, '9' );
	ja not_fp_value;
	jmp fp_character_ok;
	
  fp_character_dot:
	cmp( esi, edx );
	je not_fp_value;
	or( ah, ah );
	jnz not_fp_value;
	or( 1, ah );
	lodsb;
	loop digit_expected;
	
  not_fp_value:
	pop( esi );
	pop( edi );
	stc;
	ret();

  fp_last_character:
	cmp( cl, 1 );
	jne not_fp_value;
	or( 4, ah );
	jmp fp_character_ok;
	
  fp_character_exp:
	cmp( esi, edx );
	je not_fp_value;
	cmp( ah, 1 );
	ja not_fp_value;
	or( 2, ah );
	cmp( ecx, 1 );
	jne fp_character_ok;
	cmp( (type byte [esi]), '+' );
	je fp_exp_sign;
	cmp( (type byte [esi]), '-' );
	jne fp_character_ok;
	
  fp_exp_sign:
	inc( esi );
	cmp( (type byte [esi]), lenStrTkn );
	jne not_fp_value;
	inc( esi );
	lodsb;
	movzx( al, ecx );
	inc( ecx );
	
  fp_character_ok:
	dec( ecx );
	jnz check_fp_value;
	or( ah, ah );
	jz not_fp_value;
	pop( esi );
	lodsb;
	mov( 0, fp_sign );
	cmp( al, lenStrTkn );
	je fp_get;
	inc( esi );
	cmp( al, '+' );
	je fp_get;
	mov( 1, fp_sign );
	
  fp_get:
	lodsb;
	movzx( al, ecx );
	xor( edx, edx );
	mov( &fp_value, edi );
	mov( edx, [edi] );
	mov( edx, [edi+4] );
	mov( edx, [edi+12] );
	call fp_optimize;
	mov( 0, fp_format );
	mov( [esi], al );
	
  fp_before_dot:
	lodsb;
	cmp( al, '.' );
	je fp_dot;
	cmp( al, 'E' );
	je fp_exponent;
	cmp( al, 'e' );
	je fp_exponent;
	cmp( al, 'F' );
	je fp_done;
	cmp( al, 'f' );
	je fp_done;
	sub( '0', al );
	mov( &fp_value[16], edi );
	xor( edx, edx );
	mov( edx, (type dword [edi+12]) );
	mov( edx, (type dword [edi]) );
	mov( edx, (type dword [edi+4]) );
	mov( al, [edi+7] );
	mov( 7, dl );
	mov( edx, (type dword [edi+8]) );
	call fp_optimize;
	mov( &fp_value, edi );
	push( ecx );
	mov( 10, ecx );
	call fp_mul;
	pop( ecx );
	mov( &fp_value[16], ebx );
	call fp_add;
	dec( ecx );
	jnz fp_before_dot;
	
  fp_dot:
	mov( &fp_value[16], edi );
	xor( edx, edx );
	mov( edx, [edi] );
	mov( edx, [edi+4] );
	mov( $80, (type byte [edi+7]) );
	mov( edx, [edi+8] );
	mov( edx, (type dword [edi+12]) );
	dec( ecx );
	jz fp_done;
	
  fp_after_dot:
	lodsb;
	cmp( al, 'E' );
	je fp_exponent;
	cmp( al, 'e' );
	je fp_exponent;
	cmp( al, 'F' );
	je fp_done;
	cmp( al, 'f' );
	je fp_done;
	inc( fp_format );
	cmp( fp_format, $80 );
	jne fp_counter_ok;
	mov( $7F, fp_format );
	
  fp_counter_ok:
	dec( esi );
	mov( &fp_value[16], edi );
	push( ecx );
	mov( 10, ecx );
	call fp_div;
	push( (type dword [edi]) );
	push( (type dword [edi+4]) );
	push( (type dword [edi+8]) );
	push( (type dword [edi+12]) );
	lodsb;
	sub( '0', al );
	movzx( al, ecx );
	call fp_mul;
	mov( edi, ebx );
	mov( &fp_value, edi );
	call fp_add;
	mov( &fp_value[16], edi );
	pop( (type dword [edi+12]) );
	pop( (type dword [edi+8]) );
	pop( (type dword [edi+4]) );
	pop( (type dword [edi]) );
	pop( ecx );
	dec( ecx );
	jnz fp_after_dot;
	jmp fp_done;
	
  fp_exponent:
	or( $80, fp_format );
	xor( edx, edx );
	xor( ebp, ebp );
	dec( ecx );
	jnz get_exponent;
	cmp( (type byte [esi]), '+' );
	je fp_exponent_sign;
	cmp( (type byte [esi]), '-' );
	jne fp_done;
	not( ebp );
	
  fp_exponent_sign:
	add( 2, esi );
	lodsb;
	movzx( al, ecx );
	
  get_exponent:
	movzx( (type byte [esi]), eax );
	inc( esi );
	sub( '0', al );
	cmp( al, 10 );
	jae exponent_ok;
	intmul( 10, edx );
	cmp( edx, $8000 );
	jae value_out_of_range;
	add( eax, edx );
	loop get_exponent;
	
  exponent_ok:
	mov( &fp_value, edi );
	or( edx, edx );
	jz fp_done;
	mov( edx, ecx );
	or( ebp, ebp );
	jnz fp_negative_power;
	
  fp_power:
	push( ecx );
	mov( 10, ecx );
	call fp_mul;
	pop( ecx );
	loop fp_power;
	jmp fp_done;
	
  fp_negative_power:
	push( ecx );
	mov( 10, ecx );
	call fp_div;
	pop( ecx );
	loop fp_negative_power;
	
  fp_done:
	mov( &fp_value, edi );
	mov( fp_format, al );
	mov( al, [edi+10] );
	mov( fp_sign, al );
	mov( al, [edi+11] );
	test( $80, (type byte [edi+15]) );
	jz fp_ok;
	add( 1, (type dword [edi]) );
	adc( 0, (type dword [edi+4]) );
	jnc fp_ok;
	mov( [edi+4], eax );
	shrd( 1, eax, [edi] );
	shr( 1, eax );
	or( $80000000, eax );
	mov( eax, [edi+4] );
	inc( (type word [edi+8]) );
	
  fp_ok:
	pop( edi );
	clc;
	ret();

end get_fp_value;


proc( convert_expression );

	push( ebp );
	call get_fp_value;
	jnc fp_expression;
	mov( esp, current_offset );
	
  expression_loop:
	push( edi );
	mov( &single_operand_operators, edi );
	call get_operator;
	pop( edi );
	or( al, al );
	jz expression_element;
	push( eax );
	jmp expression_loop;
	
  expression_element:
	mov( [esi], al );
	cmp( al, lenStrTkn );
	je expression_number;
	cmp( al, '"' );
	je expression_number;
	cmp( al, '(' );
	je expression_number;
	mov( '!', al );
	stosb;
	jmp expression_operator;
	
  expression_number:
	call convert_number;
	
  expression_operator:
	push( edi );
	mov( &operators, edi );
	call get_operator;
	pop( edi );
	or( al, al );
	jz expression_end;
	
  operators_loop:
	cmp( esp, current_offset );
	je push_operator;
	mov( al, bl );
	and( $0F0, bl );
	mov( (type byte [esp]), bh );
	and( $0F0, bh );
	cmp( bl, bh );
	ja push_operator;
	pop( ebx );
	mov( bl, (type byte [edi]) );
	inc( edi );
	jmp operators_loop;
	
  push_operator:
	push( eax );
	jmp expression_loop;
	
  expression_end:
	cmp( esp, current_offset );
	je expression_converted;
	pop( eax );
	stosb;
	jmp expression_end;
	
  expression_converted:
	pop( ebp );
	ret();

  fp_expression:
	mov( '.', al );
	stosb;
	mov( fp_value, eax );
	stosd;
	mov( fp_value[4], eax );
	stosd;
	mov( fp_value[8], eax );
	stosd;
	pop( ebp );
	ret();

end convert_expression;




proc( calculation_loop );

  calculationLoop:
	lodsb;
	cmp( al, 1 );
	je get_byte_number;
	cmp( al, 2 );
	je get_word_number;
	cmp( al, 4 );
	je get_dword_number;
	cmp( al, 8 );
	je get_qword_number;
	cmp( al, $0F );
	je value_out_of_range;
	cmp( al, $10 );
	je get_register;
	cmp( al, $11 );
	je get_label;
	cmp( al, ')' );
	je expression_calculated;
	cmp( al, ']' );
	je expression_calculated;
	cmp( al, '!' );
	je invalid_expression;
	sub( $14, edi );
	mov( edi, ebx );
	sub( $14, ebx );
	cmp( al, $0E0 );
	je calculate_rva;
	cmp( al, $0D0 );
	je calculate_not;
	cmp( al, $083 );
	je calculate_neg;
	mov( [ebx+8], dx );
	or( [edi+8], dx );
	cmp( al, $80 );
	je calculate_add;
	cmp( al, $81 );
	je calculate_sub;
	mov( [ebx+12], ah );
	or( [edi+12], ah );
	jz absolute_values_calculation;
	cmp( error_line, 0 );
	jne absolute_values_calculation;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_use_of_symbol, error );
	
  absolute_values_calculation:
	cmp( al, $90 );
	je calculate_mul;
	cmp( al, $91 );
	je calculate_div;
	or( dx, dx );
	jnz invalid_expression;
	cmp( al, $0A0 );
	je calculate_mod;
	cmp( al, $0B0 );
	je calculate_and;
	cmp( al, $0B1 );
	je calculate_or;
	cmp( al, $0B2 );
	je calculate_xor;
	cmp( al, $0C0 );
	je calculate_shl;
	cmp( al, $0C1 );
	je calculate_shr;
	jmp invalid_expression;
	
  expression_calculated:
	sub( $14, edi );
	cmp( value_undefined, 0 );
	je expression_value_ok;
	xor( eax, eax );
	mov( eax, [edi] );
	mov( eax, [edi+4] );
	mov( al, [edi+12] );
	
  expression_value_ok:
	ret();

  get_byte_number:
	mov( 0, (type word [edi+8]) );
	mov( 0, (type byte [edi+12]) );
	xor( eax, eax );
	lodsb;
	stosd;
	xor( al, al );
	stosd;
	add( $0C, edi );
	jmp calculationLoop;
	
  get_word_number:
	mov( 0, (type word [edi+8]) );
	mov( 0, (type byte [edi+12]) );
	xor( eax, eax );
	lodsw;
	stosd;
	xor( ax, ax );
	stosd;
	add( $0C, edi );
	jmp calculationLoop;
	
  get_dword_number:
	mov( 0, (type word [edi+8]) );
	mov( 0, (type byte [edi+12]) );
	movsd;
	xor( eax, eax );
	stosd;
	add( $0C, edi );
	jmp calculationLoop;
	
  get_qword_number:
	mov( 0, (type word [edi+8]) );
	mov( 0, (type byte [edi+12]) );
	movsd;
	movsd;
	add( $0C, edi );
	jmp calculationLoop;
	
  get_register:
	mov( 0, (type byte [edi+9]) );
	mov( 0, (type byte [edi+12]) );
	lodsb;
	mov( al, [edi+8] );
	mov( 1, (type byte [edi+10]) );
	xor( eax, eax );
	stosd;
	stosd;
	add( $0C, edi );
	jmp calculationLoop;
	
  get_label:
	xor( eax, eax );
	mov( eax, [edi+8] );
	mov( al, [edi+12] );
	mov( eax, [edi+20] );
	lodsd;
	cmp( eax, $0F );
	jb predefined_label;
	je reserved_word_used_as_symbol;
	mov( eax, ebx );
	mov( current_pass, ax );
	mov( ax, [ebx+18] );
	or( 8, (type byte [ebx+8]) );
	test( 1, (type byte [ebx+8]) );
	jz label_undefined;
	cmp( ax, [ebx+16] );
	je label_defined;
	test( 4, (type byte [ebx+8]) );
	jnz label_undefined;
	test( 1, (type byte [ebx+9]) );
	jz label_defined;
	mov( [ebx], eax );
	sub( (type dword adjustment), eax );
	stosd;
	mov( [ebx+4], eax );
	sbb( (type dword adjustment[4]), eax );
	stosd;
	mov( (type dword adjustment), eax );
	or( (type dword adjustment[4]), eax );
	jz got_label;
	or( -1, next_pass_needed );
	jmp got_label;
	
  label_defined:
	mov( [ebx], eax );
	stosd;
	mov( [ebx+4], eax );
	stosd;
	
  got_label:
	mov( [ebx+11], al );
	mov( al, [edi-8+12] );
	mov( [ebx+12], eax );
	mov( eax, [edi-8+8] );
	mov( [ebx+20], eax );
	mov( eax, [edi-8+16] );
	add( $0C, edi );
	mov( [ebx+10], al );
	or( al, al );
	jz calculationLoop;
	cmp( size_override, -1 );
	je calculationLoop;
	cmp( size_override, 0 );
	je check_size;
	cmp( operand_size, 0 );
	jne calculationLoop;
	mov( al, operand_size );
	jmp calculationLoop;
	
  check_size:
	xchg( al, operand_size );
	or( al, al );
	jz calculationLoop;
	cmp( al, operand_size );
	jne operand_sizes_do_not_match;
	jmp calculationLoop;
	
  current_offset_label:
	mov( labels_type, al );
	mov( al, [edi+12] );
	mov( org_symbol, eax );
	mov( eax, [edi+16] );
	mov( current_offset, eax );
	xor( edx, edx );
	sub( (type dword org_origin), eax );
	sbb( (type dword org_origin[4]), edx );
	stosd;
	mov( edx, eax );
	stosd;
	mov( org_registers, eax );
	stosd;
	add( 8, edi );
	jmp calculationLoop;
	
  org_origin_label:
	mov( labels_type, al );
	mov( al, [edi+12] );
	mov( org_symbol, eax );
	mov( eax, [edi+16] );
	mov( org_start, eax );
	xor( edx, edx );
	sub( (type dword org_origin), eax );
	sbb( (type dword org_origin[4]), edx );
	stosd;
	mov( edx, eax );
	stosd;
	mov( org_registers, eax );
	stosd;
	add( 8, edi );
	jmp calculationLoop;
	
  counter_label:
	mov( counter, eax );
	
  make_dword_label_value:
	stosd;
	xor( eax, eax );
	stosd;
	add( $0C, edi );
	jmp calculationLoop;
	
  timestamp_label:
	call make_timestamp;
	jmp make_dword_label_value;
	
  predefined_label:
	or( eax, eax );
	jz current_offset_label;
	cmp( eax, 1 );
	je counter_label;
	cmp( eax, 2 );
	je timestamp_label;
	cmp( eax, 3 );
	je org_origin_label;
	
  label_undefined:
	cmp( current_pass, 1 );
	ja undefined_value;
	
  force_next_pass:
	or( -1, next_pass_needed );
	
  undefined_value:
	mov( 0, (type byte [edi+12]) );
	or( -1, value_undefined );
	xor( eax, eax );
	stosd;
	stosd;
	add( $0C, edi );
	cmp( error_line, 0 );
	jne calculationLoop;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &undefined_symbol, error );
	jmp calculationLoop;
	
  calculate_add:
	mov( [ebx+16], ecx );
	cmp( (type byte [edi+12]), 0 );
	je add_values;
	mov( [edi+16], ecx );
	cmp( (type byte [ebx+12]), 0 );
	je add_values;
	cmp( error_line, 0 );
	jne add_values;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_use_of_symbol, error );
	
  add_values:
	mov( [edi+12], al );
	or( al, [ebx+12] );
	mov( ecx, [ebx+16] );
	mov( [edi], eax );
	add( eax, [ebx] );
	mov( [edi+4], eax );
	adc( eax, [ebx+4] );
	or( dx, dx );
	jz calculationLoop;
	push( esi );
	mov( ebx, esi );
	lea( ebx, [edi+10] );
	mov( [edi+8], cl );
	call add_register;
	lea( ebx, [edi+11] );
	mov( [edi+9], cl );
	call add_register;
	pop( esi );
	jmp calculationLoop;
	
  add_register:
	or( cl, cl );
	jz add_register_done;
	
  add_register_start:
	cmp( [esi+8], cl );
	jne add_in_second_slot;
	mov( [ebx], al );
	add( al, [esi+10] );
	jnz add_register_done;
	mov( 0, (type byte [esi+8]) );
	ret();

  add_in_second_slot:
	cmp( [esi+9], cl );
	jne create_in_first_slot;
	mov( [ebx], al );
	add( al, [esi+11] );
	jnz add_register_done;
	mov( 0, (type byte [esi+9]) );
	ret();

  create_in_first_slot:
	cmp( (type byte [esi+8]), 0 );
	jne create_in_second_slot;
	mov( cl, [esi+8] );
	mov( [ebx], al );
	mov( al, [esi+10] );
	ret();

  create_in_second_slot:
	cmp( (type byte [esi+9]), 0 );
	jne invalid_expression;
	mov( cl, [esi+9] );
	mov( [ebx], al );
	mov( al, [esi+11] );
	
  add_register_done:
	ret();

  calculate_sub:
	xor( ah, ah );
	mov( [ebx+12], ah );
	mov( [edi+12], al );
	or( al, al );
	jz sub_values;
	cmp( al, ah );
	jne invalid_sub;
	xor( ah, ah );
	mov( [edi+16], ecx );
	cmp( ecx, [ebx+16] );
	je sub_values;
	cmp( ecx, org_symbol );
	jne invalid_sub;
	test( 1, (type byte [ebx+12]) );
	jnz invalid_sub;
	mov( 3, ah );
	
  sub_values:
	mov( ah, [ebx+12] );
	mov( [edi], eax );
	sub( eax, [ebx] );
	mov( [edi+4], eax );
	sbb( eax, [ebx+4] );
	or( dx, dx );
	jz calculationLoop;
	push( esi );
	mov( ebx, esi );
	lea( ebx, [edi+10] );
	mov( [edi+8], cl );
	call sub_register;
	lea( ebx, [edi+11] );
	mov( [edi+9], cl );
	call sub_register;
	pop( esi );
	jmp calculationLoop;
	
  invalid_sub:
	cmp( error_line, 0 );
	jne sub_values;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_use_of_symbol, error );
	jmp sub_values;
	
  sub_register:
	or( cl, cl );
	jz add_register_done;
	neg( (type byte [ebx]) );
	jmp add_register_start;
	
  calculate_mul:
	or( dx, dx );
	jz mul_start;
	cmp( (type word [ebx+8]), 0 );
	jne mul_start;
	mov( [ebx], eax );
	xchg( [edi], eax );
	mov( eax, [ebx] );
	mov( [ebx+4], eax );
	xchg( [edi+4], eax );
	mov( eax, [ebx+4] );
	mov( [ebx+8], eax );
	xchg( [edi+8], eax );
	mov( eax, [ebx+8] );
	mov( [ebx+12], eax );
	xchg( [edi+12], eax );
	mov( eax, [ebx+12] );
	
  mul_start:
	push( esi );
	push( edx );
	mov( ebx, esi );
	xor( bl, bl );
	bt( 31, (type dword [esi+4]) );
	jnc mul_first_sign_ok;
	not( (type dword [esi]) );
	not( (type dword [esi+4]) );
	add( 1, (type dword [esi]) );
	adc( 0, (type dword [esi+4]) );
	not( bl );
	
  mul_first_sign_ok:
	bt( 31, (type dword [edi+4]) );
	jnc mul_second_sign_ok;
	not( (type dword [edi]) );
	not( (type dword [edi+4]) );
	add( 1, (type dword [edi]) );
	adc( 0, (type dword [edi+4]) );
	not( bl );
	
  mul_second_sign_ok:
	cmp( (type dword [esi+4]), 0 );
	jz mul_numbers;
	cmp( (type dword [edi+4]), 0 );
	jnz value_out_of_range;
	
  mul_numbers:
	mov( [esi+4], eax );
	mul( (type dword [edi]) );
	or( edx, edx );
	jnz value_out_of_range;
	mov( eax, ecx );
	mov( [esi], eax );
	mul( (type dword [edi+4]) );
	or( edx, edx );
	jnz value_out_of_range;
	add( eax, ecx );
	jc value_out_of_range;
	mov( [esi], eax );
	mul( (type dword [edi]) );
	add( ecx, edx );
	jc value_out_of_range;
	test( 1 << 31, edx );
	jnz value_out_of_range;
	mov( eax, [esi] );
	mov( edx, [esi+4] );
	or( bl, bl );
	jz mul_ok;
	not( (type dword [esi]) );
	not( (type dword [esi+4]) );
	add( 1, (type dword [esi]) );
	adc( 0, (type dword [esi+4]) );
	
  mul_ok:
	pop( edx );
	or( dx, dx );
	jz mul_calculated;
	cmp( (type word [edi+8]), 0 );
	jne invalid_value;
	cmp( (type byte [esi+8]), 0 );
	je mul_first_register_ok;
	mov( [edi], al );
	cbw;
	cwde;
	cdq;
	cmp( edx, [edi+4] );
	jne value_out_of_range;
	cmp( eax, [edi] );
	jne value_out_of_range;
	imul( (type byte [esi+10]) );
	mov( ah, dl );
	cbw;
	cmp( ah, dl );
	jne value_out_of_range;
	mov( al, [esi+10] );
	
  mul_first_register_ok:
	cmp( (type byte [esi+9]), 0 );
	je mul_calculated;
	mov( [edi], al );
	cbw;
	cwde;
	cdq;
	cmp( edx, [edi+4] );
	jne value_out_of_range;
	cmp( eax, [edi] );
	jne value_out_of_range;
	imul( (type byte [esi+11]) );
	mov( ah, dl );
	cbw;
	cmp( ah, dl );
	jne value_out_of_range;
	mov( al, [esi+11] );
	
  mul_calculated:
	pop( esi );
	jmp calculationLoop;
	
  calculate_div:
	push( esi );
	push( edx );
	mov( ebx, esi );
	call div_64;
	pop( edx );
	or( dx, dx );
	jz div_calculated;
	cmp( (type byte [esi+8]), 0 );
	je div_first_register_ok;
	mov( [edi], al );
	cbw;
	cwde;
	cdq;
	cmp( edx, [edi+4] );
	jne value_out_of_range;
	cmp( eax, [edi] );
	jne value_out_of_range;
	or( al, al );
	jz value_out_of_range;
	mov( [esi+10], al );
	cbw;
	idiv( (type byte [edi]) );
	or( ah, ah );
	jnz invalid_use_of_symbol;
	mov( al, [esi+10] );
	
  div_first_register_ok:
	cmp( (type byte [esi+9]), 0 );
	je div_calculated;
	mov( [edi], al );
	cbw;
	cwde;
	cdq;
	cmp( edx, [edi+4] );
	jne value_out_of_range;
	cmp( eax, [edi] );
	jne value_out_of_range;
	or( al, al );
	jz value_out_of_range;
	mov( [esi+11], al );
	cbw;
	idiv( (type byte [edi]) );
	or( ah, ah );
	jnz invalid_use_of_symbol;
	mov( al, [esi+11] );
	
  div_calculated:
	pop( esi );
	jmp calculationLoop;
	
  calculate_mod:
	push( esi );
	mov( ebx, esi );
	call div_64;
	mov( eax, [esi] );
	mov( edx, [esi+4] );
	pop( esi );
	jmp calculationLoop;
	
  calculate_and:
	mov( [edi], eax );
	and( eax, [ebx] );
	mov( [edi+4], eax );
	and( eax, [ebx+4] );
	jmp calculationLoop;
	
  calculate_or:
	mov( [edi], eax );
	or( eax, [ebx] );
	mov( [edi+4], eax );
	or( eax, [ebx+4] );
	jmp calculationLoop;
	
  calculate_xor:
	mov( [edi], eax );
	xor( eax, [ebx] );
	mov( [edi+4], eax );
	xor( eax, [ebx+4] );
	jmp calculationLoop;
	
  shr_negative:
	not( (type dword [edi]) );
	not( (type dword [edi+4]) );
	add( 1, (type dword [edi]) );
	adc( 0, (type dword [edi+4]) );
	
  calculate_shl:
	mov( (type dword [edi+4]), eax );
	bt( 31, eax );
	jc shl_negative;
	or( eax, eax );
	jnz zero_value;
	mov( [edi], ecx );
	cmp( ecx, 64 );
	jae zero_value;
	cmp( ecx, 32 );
	jae shl_high;
	mov( [ebx+4], edx );
	mov( [ebx], eax );
	shld( cl, eax, edx );
	shl( cl, eax );
	mov( eax, [ebx] );
	mov( edx, [ebx+4] );
	jmp calculationLoop;
	
  shl_high:
	sub( 32, cl );
	mov( [ebx], eax );
	shl( cl, eax );
	mov( eax, [ebx+4] );
	mov( 0, (type dword [ebx]) );
	jmp calculationLoop;
	
  shl_negative:
	not( (type dword [edi]) );
	not( (type dword [edi+4]) );
	add( 1, (type dword [edi]) );
	adc( 0, (type dword [edi+4]) );
	
  calculate_shr:
	mov( (type dword [edi+4]), eax );
	bt( 31, eax );
	jc shr_negative;
	or( eax, eax );
	jnz zero_value;
	mov( [edi], ecx );
	cmp( ecx, 64 );
	jae zero_value;
	cmp( ecx, 32 );
	jae shr_high;
	mov( [ebx+4], edx );
	mov( [ebx], eax );
	shrd( cl, edx, eax );
	shr( cl, edx );
	mov( eax, [ebx] );
	mov( edx, [ebx+4] );
	jmp calculationLoop;
	
  shr_high:
	sub( 32, cl );
	mov( [ebx+4], eax );
	shr( cl, eax );
	mov( eax, [ebx] );
	mov( 0, (type dword [ebx+4]) );
	jmp calculationLoop;
	
  zero_value:
	mov( 0, (type dword [ebx]) );
	mov( 0, (type dword [ebx+4]) );
	jmp calculationLoop;
	
  calculate_not:
	cmp( (type word [edi+8]), 0 );
	jne invalid_expression;
	cmp( (type byte [edi+12]), 0 );
	je not_ok;
	cmp( error_line, 0 );
	jne not_ok;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_use_of_symbol, error );
	
  not_ok:
	cmp( value_size, 1 );
	je not_byte;
	cmp( value_size, 2 );
	je not_word;
	cmp( value_size, 4 );
	je not_dword;
	cmp( value_size, 6 );
	je not_pword;
	
  not_qword:
	not( (type dword [edi]) );
	not( (type dword [edi+4]) );
	add( $14, edi );
	jmp calculationLoop;
	
  not_byte:
	cmp( (type dword [edi+4]), 0 );
	jne not_qword;
	cmp( (type word [edi+2]), 0 );
	jne not_qword;
	cmp( (type byte [edi+1]), 0 );
	jne not_qword;
	not( (type byte [edi]) );
	add( $14, edi );
	jmp calculationLoop;
	
  not_word:
	cmp( (type dword [edi+4]), 0 );
	jne not_qword;
	cmp( (type word [edi+2]), 0 );
	jne not_qword;
	not( (type word [edi]) );
	add( $14, edi );
	jmp calculationLoop;
	
  not_dword:
	cmp( (type dword [edi+4]), 0 );
	jne not_qword;
	not( (type dword [edi]) );
	add( $14, edi );
	jmp calculationLoop;
	
  not_pword:
	cmp( (type word [edi+6]), 0 );
	jne not_qword;
	not( (type dword [edi]) );
	not( (type word [edi+4]) );
	add( $14, edi );
	jmp calculationLoop;
	
  calculate_neg:
	cmp( (type word [edi+8]), 0 );
	jne invalid_expression;
	cmp( (type byte [edi+12]), 0 );
	je neg_ok;
	cmp( error_line, 0 );
	jne neg_ok;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_use_of_symbol, error );
	
  neg_ok:
	mov( [edi], eax );
	mov( [edi+4], edx );
	mov( 0, (type dword [edi]) );
	mov( 0, (type dword [edi+4]) );
	sub( eax, [edi] );
	sbb( edx, [edi+4] );
	add( $14, edi );
	jmp calculationLoop;
	
  calculate_rva:
	cmp( (type word [edi+8]), 0 );
	jne invalid_expression;
	cmp( output_format, 5 );
	je calculate_gotoff;
	cmp( output_format, 3 );
	jne invalid_expression;
	test( 8, format_flags );
	jnz pe64_rva;
	cmp( (type byte [edi+12]), 2 );
	je rva_ok;
	cmp( error_line, 0 );
	jne rva_ok;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_use_of_symbol, error );
	
  rva_ok:
	mov( 0, (type byte [edi+12]) );
	mov( code_start, eax );
	mov( [eax+$34], eax );
	cdq;
	sub( eax, [edi] );
	sbb( edx, [edi+4] );
	add( $14, edi );
	jmp calculationLoop;
	
  pe64_rva:
	cmp( (type byte [edi+12]), 4 );
	je pe64_rva_ok;
	cmp( error_line, 0 );
	jne pe64_rva_ok;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_use_of_symbol, error );
	
  pe64_rva_ok:
	mov( 0, (type byte [edi+12]) );
	mov( code_start, eax );
	mov( [eax+$34], edx );
	mov( [eax+$30], eax );
	sub( eax, [edi] );
	sbb( edx, [edi+4] );
	add( $14, edi );
	jmp calculationLoop;
	
  calculate_gotoff:
	test( 8+1, format_flags );
	jnz invalid_expression;
	cmp( (type byte [edi+12]), 2 );
	je gotoff_ok;
	cmp( error_line, 0 );
	jne pe64_rva_ok;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_use_of_symbol, error );
	
  gotoff_ok:
	mov( 5, (type byte [edi+12]) );
	add( $14, edi );
	jmp calculationLoop;
	
  div_64:
	xor( ebx, ebx );
	cmp( (type dword [edi]), 0 );
	jne divider_ok;
	cmp( (type dword [edi+4]), 0 );
	jne divider_ok;
	cmp( next_pass_needed, 0 );
	je value_out_of_range;
	jmp div_done;
	
  divider_ok:
	bt( 31, (type dword [esi+4]) );
	jnc div_first_sign_ok;
	not( (type dword [esi]) );
	not( (type dword [esi+4]) );
	add( 1, (type dword [esi]) );
	adc( 0, (type dword [esi+4]) );
	not( bx );
	
  div_first_sign_ok:
	bt( 31, (type dword [edi+4]) );
	jnc div_second_sign_ok;
	not( (type dword [edi]) );
	not( (type dword [edi+4]) );
	add( 1, (type dword [edi]) );
	adc( 0, (type dword [edi+4]) );
	not( bl );
	
  div_second_sign_ok:
	cmp( (type dword [edi+4]), 0 );
	jne div_high;
	mov( [edi], ecx );
	mov( [esi+4], eax );
	xor( edx, edx );
	div( ecx );
	mov( eax, [esi+4] );
	mov( [esi], eax );
	div( ecx );
	mov( eax, [esi] );
	mov( edx, eax );
	xor( edx, edx );
	jmp div_done;
	
  div_high:
	mov( [esi+4], eax );
	xor( edx, edx );
	div( (type dword [edi+4]) );
	mov( [esi], ebx );
	mov( eax, [esi] );
	mov( 0, (type dword [esi+4]) );
	mov( edx, ecx );
	mul( (type dword [edi]) );
	
  div_high_loop:
	cmp( ecx, edx );
	ja div_high_done;
	jb div_high_large_correction;
	cmp( ebx, eax );
	jae div_high_done;
	
  div_high_correction:
	dec( (type dword [esi]) );
	sub( [edi], eax );
	sbb( [edi+4], edx );
	jnc div_high_loop;
	
  div_high_done:
	sub( eax, ebx );
	sbb( edx, ecx );
	mov( ecx, edx );
	mov( ebx, eax );
	ret();

  div_high_large_correction:  
	push( eax );
	push( edx );
	mov( edx, eax );
	sub( ecx, eax );
	xor( edx, edx );
	div( (type dword [edi+4]) );
	shr( 1, eax );
	jz div_high_small_correction;
	sub( eax, [esi] );
	push( eax );
	mul( (type dword [edi+4]) );
	sub( eax, (type dword [esp+4]) );
	pop( eax );
	mul( (type dword [edi]) );
	sub( eax, (type dword [esp+4]) );
	sbb( edx, (type dword [esp]) );
	pop( edx );
	pop( eax );
	jmp div_high_loop;
	
  div_high_small_correction:
	pop( edx );
	pop( eax );
	jmp div_high_correction;
	
  div_done:
	or( bh, bh );
	jz remainder_ok;
	not( eax );
	not( edx );
	add( 1, eax );
	adc( 0, edx );
	
  remainder_ok:
	or( bl, bl );
	jz div_ok;
	not( (type dword [esi]) );
	not( (type dword [esi+4]) );
	add( 1, (type dword [esi]) );
	adc( 0, (type dword [esi+4]) );
	
  div_ok:
	ret();


end calculation_loop;



proc( calculate_expression );

	mov( edi, current_offset );
	mov( 0, value_undefined );
	cmp( (type byte [esi]), 0 );
	je get_string_value;
	cmp( (type byte [esi]), '.' );
	je convert_fp;
	jmp calculation_loop;

  convert_fp:
	inc( esi );
	mov( 0, (type word [edi+8]) );
	mov( 0, (type byte [edi+12]) );
	mov( value_size, al );
	cmp( al, 4 );
	je convert_fp_dword;
	cmp( al, 8 );
	je convert_fp_qword;
	jmp invalid_value;
	
  convert_fp_dword:
	xor( eax, eax );
	cmp( (type word [esi+8]), $8000 );
	je fp_dword_store;
	mov( [esi+8], bx );
	mov( [esi+4], eax );
	shl( 1, eax );
	shr( 9, eax );
	jnc fp_dword_ok;
	inc( eax );
	bt( 23, eax );
	jnc fp_dword_ok;
	and( 1 << 23 - 1, eax );
	inc( bx );
	shr( 1, eax );
	
  fp_dword_ok:
	add( $7F, bx );
	cmp( bx, $100 );
	jae value_out_of_range;
	shl( 23, ebx );
	or( ebx, eax );
	
  fp_dword_store:
	mov( [esi+11], bl );
	shl( 31, ebx );
	or( ebx, eax );
	mov( eax, [edi] );
	xor( eax, eax );
	mov( eax, [edi+4] );
	add( 13, esi );
	ret();

  convert_fp_qword:
	xor( eax, eax );
	xor( edx, edx );
	cmp( (type word [esi+8]), $8000 );
	je fp_qword_store;
	mov( [esi+8], bx );
	mov( [esi], eax );
	mov( [esi+4], edx );
	add( eax, eax );
	adc( edx, edx );
	mov( edx, ecx );
	shr( 12, edx );
	shrd( 12, ecx, eax );
	jnc fp_qword_ok;
	add( 1, eax );
	adc( 0, edx );
	bt( 20, edx );
	jnc fp_qword_ok;
	and( 1 << 20 - 1, edx );
	inc( bx );
	shr( 1, edx );
	rcr( 1, eax );
	
  fp_qword_ok:
	add( $3FF, bx );
	cmp( bx, $800 );
	jae value_out_of_range;
	shl( 20, ebx );
	or( ebx, edx );
	
  fp_qword_store:
	mov( [esi+11], bl );
	shl( 31, ebx );
	or( ebx, edx );
	mov( eax, [edi] );
	mov( edx, [edi+4] );
	add( 13, esi );
	ret();

  get_string_value:
	inc( esi );
	lodsd;
	mov( eax, ecx );
	cmp( ecx, 8 );
	ja value_out_of_range;
	mov( edi, edx );
	xor( eax, eax );
	stosd;
	stosd;
	mov( edx, edi );
	rep.movsb;
	mov( edx, edi );
	inc( esi );
	mov( 0, (type word [edi+8]) );
	mov( 0, (type byte [edi+12]) );
	ret();
	
	
end calculate_expression;



proc( get_byte_value );

	mov( 1, value_size );
	mov( -1, size_override );
	call calculate_expression;
	mov( [edi+16], eax );
	mov( eax, symbol_identifier );
	mov( 0, value_type );
	cmp( (type word [edi+8]), 0 );
	jne invalid_value;
	
	cmp( (type byte [edi+12]), 0 );
	je check_byte_value;
	
	cmp( error_line, 0 );
	jne check_byte_value;
	
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_use_of_symbol, error );
  check_byte_value:
	mov( [edi], eax );
	mov( [edi+4], edx );
	or( edx, edx );
	jz byte_positive;
	
	cmp( edx, -1 );
	jne range_exceeded;
	
	cmp( eax, -$80 );
	jb range_exceeded;
	ret();

  byte_positive:
	cmp( eax, $100 );
	jae range_exceeded;
	
  return_byte_value:
	ret();

  range_exceeded:
	xor( eax, eax );
	xor( edx, edx );
	cmp( error_line, 0 );
	jne return_byte_value;
	
	mov( current_line, ecx );
	mov( ecx, error_line );
	mov( &value_out_of_range, error );
	ret();
	
end get_byte_value;



proc( get_word_value );

	mov( 2, value_size );
	mov( -1, size_override );
	call calculate_expression;
	mov( [edi+16], eax );
	mov( eax, symbol_identifier );
	cmp( (type word [edi+8]), 0 );
	jne invalid_value;
	
	mov( [edi+12], al );
	mov( al, value_type );
	cmp( al, 2 );
	jb check_word_value;
	
	cmp( error_line, 0 );
	jne check_word_value;
	
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_use_of_symbol, error );
  check_word_value:
	mov( [edi], eax );
	mov( [edi+4], edx );
	or( edx, edx );
	jz word_positive;
	
	cmp( edx, -1 );
	jne range_exceeded;
	
	cmp( eax, -$8000 );
	jb range_exceeded;
	ret();

  word_positive:
	cmp( eax, $10000 );
	jae range_exceeded;
	ret();
	
  range_exceeded:
	xor( eax, eax );
	xor( edx, edx );
	cmp( error_line, 0 );
	jne done;
	
	mov( current_line, ecx );
	mov( ecx, error_line );
	mov( &value_out_of_range, error );
	
  done:
	ret();

end get_word_value;



proc( get_dword_value );

	mov( 4, value_size );
	mov( -1, size_override );
	call calculate_expression;
	mov( [edi+16], eax );
	mov( eax, symbol_identifier );
	cmp( (type word [edi+8]), 0 );
	jne invalid_value;
	
	mov( [edi+12], al );
	mov( al, value_type );
	cmp( al, 4 );
	jne check_dword_value;
	
	cmp( error_line, 0 );
	jne check_dword_value;
	
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_use_of_symbol, error );
  check_dword_value:
	mov( [edi], eax );
	mov( [edi+4], edx );
	or( edx, edx );
	jz dword_positive;
	
	cmp( edx, -1 );
	jne range_exceeded;
	
	bt( 31, eax );
	jnc range_exceeded;
	
  dword_positive:
	ret();
	
  range_exceeded:
	xor( eax, eax );
	xor( edx, edx );
	cmp( error_line, 0 );
	jne done;
	
	mov( current_line, ecx );
	mov( ecx, error_line );
	mov( &value_out_of_range, error );
	
  done:
	ret();
	
end get_dword_value;



proc( get_pword_value );

	mov( 6, value_size );
	mov( -1, size_override );
	call calculate_expression;
	mov( [edi+16], eax );
	mov( eax, symbol_identifier );
	cmp( (type word [edi+8]), 0 );
	jne invalid_value;
	
	mov( [edi+12], al );
	mov( al, value_type );
	cmp( al, 4 );
	jne check_pword_value;
	
	cmp( error_line, 0 );
	jne check_pword_value;
	
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_use_of_symbol, error );
  check_pword_value:
	mov( [edi], eax );
	mov( [edi+4], edx );
	cmp( edx, $10000 );
	jge range_exceeded;
	
	cmp( edx, -$8000 );
	jl range_exceeded;
	ret();
	
  range_exceeded:
	xor( eax, eax );
	xor( edx, edx );
	cmp( error_line, 0 );
	jne done;
	
	mov( current_line, ecx );
	mov( ecx, error_line );
	mov( &value_out_of_range, error );
	
  done:
	ret();
	
end get_pword_value;




proc( get_qword_value );

	mov( 8, value_size );
	mov( -1, size_override );
	call calculate_expression;
	mov( [edi+16], eax );
	mov( eax, symbol_identifier );
	cmp( (type word [edi+8]), 0 );
	jne invalid_value;
	
	mov( [edi+12], al );
	mov( al, value_type );
  check_qword_value:
	mov( [edi], eax );
	mov( [edi+4], edx );
	ret();

end get_qword_value;



proc( get_address_register );

	or( al, al );
	jz address_register_ok;
	
	cmp( dl, 1 );
	jne scaled_register;
	
	or( bh, bh );
	jnz scaled_register;
	
	mov( al, bh );
  address_register_ok:
	ret();

  scaled_register:
	or( bl, bl );
	jnz invalid_address;
	
	mov( al, bl );
	mov( dl, cl );
	jmp address_register_ok;

  range_exceeded:
	xor( eax, eax );
	xor( edx, edx );
	cmp( error_line, 0 );
	jne done;
	
	mov( current_line, ecx );
	mov( ecx, error_line );
	mov( &value_out_of_range, error );
	
  done:
	ret();
	
	
end get_address_register;


proc( get_size_operator );

	xor( ah, ah );
	cmp( al, $11 );
	jne no_size_operator;
	mov( 1, size_declared );
	lodsw;
	xchg( ah, al );
	mov( 1, size_override );
	cmp( ah, operand_size );
	je size_operator_ok;
	cmp( operand_size, 0 );
	jne operand_sizes_do_not_match;
	mov( ah, operand_size );
  size_operator_ok:
	ret();

  no_size_operator:
	mov( 0, size_declared );
	cmp( al, '[' );
	jne size_operator_ok;
	mov( 0, size_override );
	ret();
	
end get_size_operator;




proc( get_value );

	mov( 0, operand_size );
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	jne invalid_value;
	mov( operand_size, al );
	cmp( al, 1 );
	je value_byte;
	
	cmp( al, 2 );
	je value_word;
	
	cmp( al, 4 );
	je value_dword;
	
	cmp( al, 6 );
	je value_pword;
	
	cmp( al, 8 );
	je value_qword;
	
	or( al, al );
	jnz invalid_value;
	
  value_qword:
	call get_qword_value;
	ret();

  value_pword:
	call get_pword_value;
	movzx( dx, edx );
	ret();

  value_dword:
	call get_dword_value;
	xor( edx, edx );
	ret();

  value_word:
	call get_word_value;
	xor( edx, edx );
	movzx( ax, eax );
	ret();

  value_byte:
	call get_byte_value;
	xor( edx, edx );
	movzx( al, eax );
	ret();

end get_value;
	
proc( get_address_value );

	mov( 0, address_size );
	mov( 8, value_size );
	
	// Falls through to calculate_address
	
end get_address_value;
	
	
procedure calculate_address;
begin calculate_address;

	cmp( (type byte [esi]), '.' );
	je invalid_address;
	
	call calculate_expression;
	mov( [edi+16], eax );
	mov( eax, address_symbol );
	mov( [edi+12], al );
	mov( al, value_type );
	cmp( al, 5 );
	je gotoff_address;
	
	test( 1, al );
	jnz invalid_use_of_symbol;
	
	or( al, al );
	jz address_size_ok;
	
	shl( 5, al );
	jmp address_symbol_ok;
	
  gotoff_address:
	mov( $40, al );
	
  address_symbol_ok:
	mov( address_size, ah );
	or( al, address_size );
	shr( 4, al );
	or( ah, ah );
	jz address_size_ok;
	
	cmp( al, ah );
	jne address_sizes_do_not_agree;
	
  address_size_ok:
	xor( bx, bx );
	xor( cl, cl );
	mov( address_size, ch );
	cmp( (type word [edi+8]), 0 );
	je check_immediate_address;
	
	mov( [edi+8], al );
	mov( [edi+10], dl );
	call get_address_register;
	mov( [edi+9], al );
	mov( [edi+11], dl );
	call get_address_register;
	mov( bx, ax );
	shr( 4, ah );
	shr( 4, al );
	or( bh, bh );
	jz check_address_registers;
	
	or( bl, bl );
	jz check_address_registers;
	
	cmp( al, ah );
	jne invalid_address;
	
  check_address_registers:
	or( ah, al );
	cmp( al, 4 );
	je sib_allowed;
	
	cmp( al, 8 );
	je sib_allowed;
	
	or( cl, cl );
	jz check_word_value;
	
	cmp( cl, 1 );
	je check_word_value;
	jmp invalid_address;
	
  check_word_value:
	mov( [edi], eax );
	mov( [edi+4], edx );
	or( edx, edx );
	jz word_positive;
	
	cmp( edx, -1 );
	jne range_exceeded;
	
	cmp( eax, -$8000 );
	jb range_exceeded;
	ret();

  word_positive:
	cmp( eax, $10000 );
	jae range_exceeded;
	ret();

  sib_allowed:
	or( bh, bh );
	jnz check_index_scale;
	
	cmp( cl, 2 );
	je special_index_scale;
	
	cmp( cl, 3 );
	je special_index_scale;
	
	cmp( cl, 5 );
	je special_index_scale;
	
	cmp( cl, 9 );
	je special_index_scale;
	
  check_index_scale:
	or( cl, cl );
	jz address_registers_ok;
	
	cmp( cl, 1 );
	je address_registers_ok;
	
	cmp( cl, 2 );
	je address_registers_ok;
	
	cmp( cl, 4 );
	je address_registers_ok;
	
	cmp( cl, 8 );
	je address_registers_ok;
	jmp invalid_address;
	
  special_index_scale:
	mov( bl, bh );
	dec( cl );
	
  address_registers_ok:
	mov( [edi], eax );
	mov( [edi+4], edx );
	or( edx, edx );
	jz dword_positive;
	
	cmp( edx, -1 );
	jne range_exceeded;
	
	bt( 31, eax );
	jnc range_exceeded;
	
  dword_positive:
	ret();
	
	
  check_immediate_address:
	cmp( code_type, 64 );
	jne address_registers_ok;
	
	cmp( address_size, 4 );
	je address_registers_ok;
  check_qword_value:
	mov( [edi], eax );
	mov( [edi+4], edx );
	ret();
	
	
  range_exceeded:
	xor( eax, eax );
	xor( edx, edx );
	cmp( error_line, 0 );
	jne done;
	
	mov( current_line, ecx );
	mov( ecx, error_line );
	mov( &value_out_of_range, error );
	
  done:
	ret();
	
end calculate_address;
	


proc( get_relative_offset );

	mov( 4, value_size );
	mov( -1, size_override );
	call calculate_expression;
	
	// Falls through to calculate_relative_offset
	
end get_relative_offset;

	
procedure calculate_relative_offset;
begin calculate_relative_offset;

	push( esi );
	add( $14, edi );
	mov( display_buffer, esi );
	sub( 7, esi );
	lea( eax, [esi-$14] );
	out_of_mem( b, eax, edi );
	
	mov( $11, (type byte [esi]) );
	xor( eax, eax );
	mov( eax, (type dword [esi+1]) );
	mov( ')', (type word [esi+5]) );
	call calculation_loop;
	pop( esi );
	cmp( (type word [edi+8]), 0 );
	jne invalid_value;
	
	mov( [edi+12], al );
	mov( al, value_type );
	mov( [edi+16], eax );
	mov( eax, symbol_identifier );
	mov( [edi], eax );
	mov( [edi+4], edx );
	or( edx, edx );
	jz offset_positive;
	
	cmp( edx, -1 );
	jne range_exceeded;
	
	bt( 31, eax );
	jnc range_exceeded;
	ret();

  offset_positive:
	bt( 31, eax );
	jc range_exceeded;
	ret();
	
	
	
  range_exceeded:
	xor( eax, eax );
	xor( edx, edx );
	cmp( error_line, 0 );
	jne done;
	
	mov( current_line, ecx );
	mov( ecx, error_line );
	mov( &value_out_of_range, error );
	
  done:
	ret();
	
end calculate_relative_offset;


proc( skip_symbol );

	lodsb;
	or( al, al );
	jz nothing_to_skip;
	cmp( al, $0F );
	je nothing_to_skip;
	cmp( al, 1 );
	je skip_instruction;
	cmp( al, 2 );
	je skip_label;
	cmp( al, 3 );
	je skip_label;
	cmp( al, ' ' );
	jb skip_assembler_symbol;
	cmp( al, '(' );
	je skip_expression;
	cmp( al, '[' );
	je skip_address;
  skip_done:
	clc;
	ret();

  skip_label:
	add( 2, esi );
  skip_instruction:
	add( 2, esi );
  skip_assembler_symbol:
	inc( esi );
	jmp skip_done;
  skip_address:
	mov( [esi], al );
	and( %11110000, al );
	cmp( al, $60 );
	jb skip_expression;
	cmp( al, $70 );
	ja skip_expression;
	inc( esi );
	jmp skip_address;
	
  nothing_to_skip:
	dec( esi );
	stc;
	ret();

	
skip_expression:
	// Falls through to skip_expression
	
end skip_symbol;
	
	
procedure skip_expression;
begin skip_expression;

  skipExpression:
	lodsb;
	or( al, al );
	jz skip_string;
	cmp( al, '.' );
	je skip_fp_value;
	cmp( al, ')' );
	je skip_done;
	cmp( al, ']' );
	je skip_done;
	cmp( al, '!' );
	je skipExpression;
	cmp( al, $0F );
	je skipExpression;
	cmp( al, $10 );
	je skip_register;
	cmp( al, $11 );
	je skip_label_value;
	cmp( al, $80 );
	jae skipExpression;
	movzx( al, eax );
	add( eax, esi );
	jmp skipExpression;
  skip_label_value:
	add( 3, esi );
  skip_register:
	inc( esi );
	jmp skipExpression;
	
  skip_fp_value:
	add( 12, esi );
	jmp skip_done;
	
  skip_string:
	lodsd;
	add( eax, esi );
	inc( esi );
  skip_done:
  	clc;
	ret();

end skip_expression;


proc( preevaluate_logical_value );

	mov( edi, ebp );
	
  preevaluate_negation:
	cmp( (type byte [esi]), '~' );
	jne preevaluate_negation_ok;
	
	movsb;
	jmp preevaluate_negation;
	
  preevaluate_negation_ok:
	mov( esi, ebx );
	xor( edx, edx );
	cmp( (type byte [esi]), '{' );
	jne find_logical_value_boundaries;
	
	movsb;
	push( ebp );
	call preevaluate_logical_expression;
	pop( ebp );
	cmp( al, $0FF );
	je invalid_logical_value;
	
	cmp( (type byte [esi]), '}' );
	jne invalid_logical_value;
	
	or( al, al );
	jnz preevaluated_expression_value;
	
	movsb;
	ret();

  preevaluated_expression_value:
	inc( esi );
	lea( edx, [edi-1] );
	sub( ebp, edx );
	test( 1, edx );
	jz expression_negation_ok;
	
	xor( 1, al );
  expression_negation_ok:
	mov( ebp, edi );
	ret();

  invalid_logical_value:
	mov( ebp, edi );
	mov( $0FF, al );
	ret();

  find_logical_value_boundaries:
	mov( [esi], al );
	or( al, al );
	jz logical_value_boundaries_found;
	
	cmp( al, '}' );
	je logical_value_boundaries_found;
	
	cmp( al, '|' );
	je logical_value_boundaries_found;
	
	cmp( al, '&' );
	je logical_value_boundaries_found;
	
	or( edx, edx );
	jnz next_symbol_in_logical_value;
	
	cmp( al, $0F0 );
	je preevaluable_logical_operator;
	
	cmp( al, $0F7 );
	je preevaluable_logical_operator;
	
	cmp( al, $0F6 );
	jne next_symbol_in_logical_value;
	
  preevaluable_logical_operator:
	mov( esi, edx );
	
  next_symbol_in_logical_value:
	call skip_symbol;
	jmp find_logical_value_boundaries;
	
  logical_value_boundaries_found:
	or( edx, edx );
	jz non_preevaluable_logical_value;
	
	mov( [edx], al );
	cmp( al, $0F0 );
	je compare_symbols;
	
	cmp( al, $0F7 );
	je compare_symbol_types;
	
	cmp( al, $0F6 );
	je scan_symbols_list;
	
  non_preevaluable_logical_value:
	mov( esi, ecx );
	mov( ebx, esi );
	sub( esi, ecx );
	jz invalid_logical_value;
	
	cmp( esi, edi );
	je leave_logical_value_intact;
	
	rep.movsb;
	xor( al, al );
	ret();

  leave_logical_value_intact:
	add( ecx, edi );
	add( ecx, esi );
	xor( al, al );
	ret();
	
  scan_symbols_list:
	push( edi );
	push( esi );
	lea( esi, [edx+1] );
	sub( ebx, edx );
	lodsb;
	cmp( al, '<' );
	jne invalid_symbols_list;
	
  get_next_from_list:
	mov( esi, edi );
	
  get_from_list:
	cmp( (type byte [esi]), ',' );
	je compare_in_list;
	
	cmp( (type byte [esi]), '>' );
	je compare_in_list;
	
	cmp( esi, [esp] );
	jae invalid_symbols_list;
	
	call skip_symbol;
	jmp get_from_list;
	
  compare_in_list:
	mov( esi, ecx );
	sub( edi, ecx );
	cmp( ecx, edx );
	jne not_equal_length_in_list;
	
	mov( ebx, esi );
	repe.cmpsb;
	mov( edi, esi );
	jne not_equal_in_list;
	
  skip_rest_of_list:
	cmp( (type byte [esi]), '>' );
	je check_list_end;
	
	cmp( esi, [esp] );
	jae invalid_symbols_list;
	
	call skip_symbol;
	jmp skip_rest_of_list;
	
  check_list_end:
	inc( esi );
	cmp( esi, [esp] );
	jne invalid_symbols_list;
	
	pop( esi );
	pop( edi );
	jmp preevaluated_true;
	
  not_equal_in_list:
	add( ecx, esi );
	
  not_equal_length_in_list:
	lodsb;
	cmp( al, ',' );
	je get_next_from_list;
	
	cmp( esi, [esp] );
	jne invalid_symbols_list;
	
	pop( esi );
	pop( edi );
	jmp preevaluated_false;
	
  invalid_symbols_list:
	pop( esi );
	pop( edi );
	jmp invalid_logical_value;
	
  compare_symbols:
	lea( ecx, [esi-1] );
	sub( edx, ecx );
	mov( edx, eax );
	sub( ebx, eax );
	cmp( ecx, eax );
	jne preevaluated_false;
	
	push( esi );
	push( edi );
	mov( ebx, esi );
	lea( edi, [edx+1] );
	repe.cmpsb;
	pop( edi );
	pop( esi );
	je preevaluated_true;
	
  preevaluated_false:
	mov( edi, eax );
	sub( ebp, eax );
	test( 1, eax );
	jnz store_true;
	
  store_false:
	mov( ebp, edi );
	mov( '0', al );
	ret();

  preevaluated_true:
	mov( edi, eax );
	sub( ebp, eax );
	test( 1, eax );
	jnz store_false;
	
  store_true:
	mov( ebp, edi );
	mov( '1', al );
	ret();

  compare_symbol_types:
	push( esi );
	lea( esi, [edx+1] );
	
  type_comparison:
	cmp( esi, [esp] );
	je types_compared;
	
	mov( [esi], al );
	cmp( al, [ebx] );
	jne different_type;
	
	cmp( al, '(' );
	jne equal_type;
	
	mov( [esi+1], al );
	mov( [ebx+1], ah );
	cmp( al, ah );
	je equal_type;
	
	or( al, al );
	jz different_type;
	
	or( ah, ah );
	jz different_type;
	
	cmp( al, '.' );
	je different_type;
	
	cmp( ah, '.' );
	je different_type;
	
  equal_type:
	call skip_symbol;
	xchg( ebx, esi );
	call skip_symbol;
	xchg( ebx, esi );
	jmp type_comparison;
	
  types_compared:
	pop( esi );
	cmp( (type byte [ebx]), $0F7 );
	jne preevaluated_false;
	jmp preevaluated_true;
	
  different_type:
	pop( esi );
	jmp preevaluated_false;
	
end preevaluate_logical_value;



proc( skip_logical_value );

	cmp( (type byte [esi]), '~' );
	jne negation_skipped;
	inc( esi );
	jmp skip_logical_value;
	
  negation_skipped:
	cmp( (type byte [esi]), '{' );
	jne skip_simple_logical_value;
	
	inc( esi );
  skip_logical_expression:
	call skip_logical_value;
	lodsb;
	or( al, al );
	jz wrongly_structured_logical_expression;
	
	cmp( al, $0F );
	je wrongly_structured_logical_expression;
	
	cmp( al, '|' );
	je skip_logical_expression;
	
	cmp( al, '&' );
	je skip_logical_expression;
	
	cmp( al, '}' );
	je logical_value_skipped;
	
  wrongly_structured_logical_expression:
	stc;
	ret();

  skip_simple_logical_value:
	mov( [esi], al );
	or( al, al );
	jz logical_value_skipped;
	
	cmp( al, $0F );
	je logical_value_skipped;
	
	cmp( al, '}' );
	je logical_value_skipped;
	
	cmp( al, '|' );
	je logical_value_skipped;
	
	cmp( al, '&' );
	je logical_value_skipped;
	
	call skip_symbol;
	jmp skip_simple_logical_value;
	
  logical_value_skipped:
	clc;
	ret();

end skip_logical_value;



proc( preevaluate_logical_expression );

	push( edi );
	call preevaluate_logical_value;
	
  preevaluation_loop:
	cmp( al, $0FF );
	je invalid_logical_expression;
	
	mov( [esi], dl );
	inc( esi );
	cmp( dl, '|' );
	je preevaluate_or;
	
	cmp( dl, '&' );
	je preevaluate_and;
	
	cmp( dl, '}' );
	je preevaluation_done;
	
	or( dl, dl );
	jnz invalid_logical_expression;
	
  preevaluation_done:
	pop( edx );
	dec( esi );
	ret();

  preevaluate_or:
	cmp( al, '1' );
	je quick_true;
	
	cmp( al, '0' );
	je leave_only_following;
	
	push( edi );
	mov( dl, al );
	stosb;
	call preevaluate_logical_value;
	pop( ebx );
	cmp( al, '0' );
	je leave_only_preceding;
	
	cmp( al, '1' );
	jne preevaluation_loop;
	stosb;
	xor( al, al );
	jmp preevaluation_loop;
	
  preevaluate_and:
	cmp( al, '0' );
	je quick_false;
	
	cmp( al, '1' );
	je leave_only_following;
	
	push( edi );
	mov( dl, al );
	stosb;
	call preevaluate_logical_value;
	pop( ebx );
	cmp( al, '1' );
	je leave_only_preceding;
	
	cmp( al, '0' );
	jne preevaluation_loop;
	
	stosb;
	xor( al, al );
	jmp preevaluation_loop;
	
  leave_only_following:
	mov( [esp], edi );
	call preevaluate_logical_value;
	jmp preevaluation_loop;
	
  leave_only_preceding:
	mov( ebx, edi );
	xor( al, al );
	jmp preevaluation_loop;
	
  quick_true:
	call skip_logical_value;
	jc invalid_logical_expression;
	
	mov( [esp], edi );
	mov( '1', al );
	jmp preevaluation_loop;
	
  quick_false:
	call skip_logical_value;
	jc invalid_logical_expression;
	
	mov( [esp], edi );
	mov( '0', al );
	jmp preevaluation_loop;
	
  invalid_logical_expression:
	pop( edi );
	mov( edi, esi );
	mov( $0FF, al );
	stosb;
	ret();

	
end preevaluate_logical_expression;





proc( calculate_logical_expression );

	call get_logical_value;
	
  logical_loop:
	cmp( (type byte [esi]), '|' );
	je logical_or;
	
	cmp( (type byte [esi]), '&' );
	je logical_and;
	ret();

  logical_or:
	inc( esi );
	or( al, al );
	jnz logical_value_already_determined;
	
	push( eax );
	call get_logical_value;
	pop( ebx );
	or( bl, al );
	jmp logical_loop;
	
  logical_and:
	inc( esi );
	or( al, al );
	jz logical_value_already_determined;
	
	push( eax );
	call get_logical_value;
	pop( ebx );
	and( bl, al );
	jmp logical_loop;
	
  logical_value_already_determined:
	push( eax );
	call skip_logical_value;
	jc invalid_expression;
	pop( eax );
	jmp logical_loop;
	
end calculate_logical_expression;

	
proc( get_logical_value );

	xor( al, al );
	
  check_for_negation:
	cmp( (type byte [esi]), '~' );
	jne negation_ok;
	
	inc( esi );
	xor( -1, al );
	jmp check_for_negation;
	
  negation_ok:
	push( eax );
	mov( [esi], al );
	cmp( al, '{' );
	je logical_expression;
	
	cmp( al, $0FF );
	je invalid_expression;
	
	cmp( al, $88 );
	je check_for_defined;
	
	cmp( al, $89 );
	je check_for_used;
	
	cmp( al, '0' );
	je given_false;
	
	cmp( al, '1' );
	je given_true;
	
	call get_value;
	mov( value_type, bl );
	push( eax );
	push( edx );
	push( ebx );
	mov( [esi], al );
	or( al, al );
	jz logical_number;
	
	cmp( al, $0F );
	je logical_number;
	
	cmp( al, '}' );
	je logical_number;
	
	cmp( al, '&' );
	je logical_number;
	
	cmp( al, '|' );
	je logical_number;
	
	inc( esi );
	mov( al, compare_type );
	call get_value;
	pop( ebx );
	cmp( next_pass_needed, 0 );
	jne values_ok;
	
	cmp( bl, value_type );
	jne invalid_use_of_symbol;
	
  values_ok:
	pop( ecx );
	pop( ebx );
	cmp( compare_type, '=' );
	je check_equal;
	
	cmp( compare_type, '>' );
	je check_greater;
	
	cmp( compare_type, '<' );
	je check_less;
	
	cmp( compare_type, $0F1 );
	je check_not_equal;
	
	cmp( compare_type, $0F2 );
	je check_not_less;
	
	cmp( compare_type, $0F3 );
	je check_not_greater;
	jmp invalid_expression;
	
  check_equal:
	cmp( eax, ebx );
	jne return_false;
	
	cmp( edx, ecx );
	jne return_false;
	jmp return_true;
	
  check_greater:
	cmp( edx, ecx );
	jl return_true;
	jg return_false;
	
	cmp( eax, ebx );
	jb return_true;
	jae return_false;
	
  check_less:
	cmp( edx, ecx );
	jl return_false;
	jg return_true;
	
	cmp( eax, ebx );
	jbe return_false;
	ja return_true;
	
  check_not_less:
	cmp( edx, ecx );
	jl return_true;
	jg return_false;
	
	cmp( eax, ebx );
	jbe return_true;
	ja return_false;
	
  check_not_greater:
	cmp( edx, ecx );
	jl return_false;
	jg return_true;
	
	cmp( eax, ebx );
	jb return_false;
	jae return_true;
	
  check_not_equal:
	cmp( eax, ebx );
	jne return_true;
	
	cmp( edx, ecx );
	jne return_true;
	jmp return_false;
	
  logical_number:
	pop( ebx );
	pop( edx );
	pop( eax );
	or( bl, bl );
	jnz invalid_expression;
	
	or( edx, eax );
	jnz return_true;
	jmp return_false;
	
  check_for_defined:
	or( -1, bl );
	lodsw;
	cmp( ah, '(' );
	jne invalid_expression;
	
  check_expression:
	lodsb;
	or( al, al );
	jz defined_string;
	
	cmp( al, '.' );
	je defined_fp_value;
	
	cmp( al, ')' );
	je expression_checked;
	
	cmp( al, $0F );
	je check_expression;
	
	cmp( al, $10 );
	je defined_register;
	
	cmp( al, $11 );
	je check_if_symbol_defined;
	
	cmp( al, $80 );
	jae check_expression;
	
	movzx( al, eax );
	add( eax, esi );
	jmp check_expression;
	
  defined_register:
	inc( esi );
	jmp check_expression;
	
  defined_fp_value:
	add( 12, esi );
	jmp expression_checked;
	
  defined_string:
	lodsd;
	add( eax, esi );
	inc( esi );
	jmp expression_checked;
	
  check_if_symbol_defined:
	lodsd;
	cmp( eax, -1 );
	je invalid_expression;
	
	cmp( eax, $0F );
	jb check_expression;
	je reserved_word_used_as_symbol;
	
	test( 4, (type byte [eax+8]) );
	jnz no_prediction;
	
	test( 1, (type byte [eax+8]) );
	jz symbol_predicted_undefined;
	
	mov( current_pass, cx );
	sub( [eax+16], cx );
	jz check_expression;
	
	cmp( cx, 1 );
	ja symbol_predicted_undefined;
	
	or( $40+$80, (type byte [eax+8]) );
	jmp check_expression;
	
  no_prediction:
	test( 1, (type byte [eax+8]) );
	jz symbol_undefined;
	
	mov( current_pass, cx );
	sub( [eax+16], cx );
	jz check_expression;
	jmp symbol_undefined;
	
  symbol_predicted_undefined:
	or( $40, (type byte [eax+8]) );
	and( _byte( !$80 ), (type byte [eax+8]) );
	
  symbol_undefined:
	xor( bl, bl );
	jmp check_expression;
	
  expression_checked:
	mov( bl, al );
	jmp logical_value_ok;
	
  check_for_used:
	lodsw;
	cmp( ah, 2 );
	jne invalid_expression;
	
	lodsd;
	cmp( eax, $0F );
	jb invalid_use_of_symbol;
	je reserved_word_used_as_symbol;
	
	inc( esi );
	test( 8, (type byte [eax+8]) );
	jz not_used;
	
	mov( current_pass, cx );
	sub( [eax+18], cx );
	jz return_true;
	
	cmp( cx, 1 );
	ja not_used;
	
	or( $10+$20, (type byte [eax+8]) );
	jmp return_true;
	
  not_used:
	or( $10, (type byte [eax+8]) );
	and( _byte( !$20 ), (type byte [eax+8]) );
	jmp return_false;
	
  given_false:
	inc( esi );
	
  return_false:
	xor( al, al );
	jmp logical_value_ok;
	
  given_true:
	inc( esi );
	
  return_true:
	or( -1, al );
	jmp logical_value_ok;
	
  logical_expression:
	inc( esi );
	call calculate_logical_expression;
	push( eax );
	lodsb;
	cmp( al, '}' );
	jne invalid_expression;
	
	pop( eax );
  logical_value_ok:
	pop( ebx );
	xor( bl, al );
	ret();
	
end get_logical_value;


proc( identify_label );

	cmp( (type byte [esi]), '.' );
	je local_label_name;
	
	call get_label_id;
	cmp( eax, $10 );
	jb label_identified;
	
	or( ebx, ebx );
	jz anonymous_label_name;
	
	dec( ebx );
	mov( ebx, current_locals_prefix );
  label_identified:
	ret();

  anonymous_label_name:
	cmp( (type byte [esi-1]), '@' );
	je anonymous_label_name_ok;
	
	mov( $0F, eax );
  anonymous_label_name_ok:
	ret();

  local_label_name:
	call get_label_id;
	ret();

end identify_label;




	
proc( parse_address );

	mov( '[', al );
	stosb;
	cmp( (type word [esi]), $021A );
	jne convert_address;
	
	push( esi );
	add( 4, esi );
	lea( ebx, [esi+1] );
	cmp( (type byte [esi]), ':' );
	pop( esi );
	jne convert_address;
	
	add( 2, esi );
	mov( 2, ecx );
	push( ebx );
	push( edi );
	mov( &symbols, edi );
	call get_symbol;
	pop( edi );
	pop( esi );
	jc unknown_segment_prefix;
	
	cmp( al, $10 );
	jne unknown_segment_prefix;
	
	mov( ah, al );
	and( %11110000, ah );
	cmp( ah, $60 );
	jne unknown_segment_prefix;
	
	stosb;
	jmp convert_address;
	
  unknown_segment_prefix:
	sub( 5, esi );
	
  convert_address:
	cmp( (type byte [esi]), lenStrTkn );
	jne jmp_convert_expression;
	
	push( esi );
	lodsw;
	movzx( ah, ecx );
	push( edi );
	mov( &address_sizes, edi );
	call get_symbol;
	pop( edi );
	jc no_size_prefix;
	
	mov( ah, al );
	add( $70, al );
	stosb;
	add( 4, esp );
	
  jmp_convert_expression:
	jmp convert_expression;
	
  no_size_prefix:
	pop( esi );
	jmp convert_expression;
	

end parse_address;




proc( parse_line_contents );

	mov( 0, parenthesis_stack );
	
	// Falls through to parse_instruction_arguments
	
end parse_line_contents;

	
procedure parse_instruction_arguments;
begin parse_instruction_arguments;

	test( ebx, ebx );
	jz parseArgument;
	
	cmp( bx, prefix_instruction_assembler );
	je allow_embedded_instruction;
	
	cmp( bx, times_directive_assembler );
	je parse_times_directive;
	
	cmp( bx, end_directive_assembler );
	je allow_embedded_instruction;
	
	cmp( bx, label_directive_assembler );
	je parse_label_directive;
	
	cmp( bx, segment_directive_assembler );
	je parse_label_directive;
	
	cmp( bx, load_directive_assembler );
	je parse_load_directive;
	
	cmp( bx, extrn_directive_assembler );
	je parse_extrn_directive;
	
	cmp( bx, public_directive_assembler );
	je parse_public_directive;
	

  parseArgument:
	lea( eax, [edi+$100] );
	out_of_mem( ae, eax, labels_list );
	
	lodsb;
	cmp( al, ':' );
	je instruction_separator;
	
	cmp( al, ',' );
	je separator;
	
	cmp( al, '=' );
	je separator;
	
	cmp( al, '|' );
	je separator;
	
	cmp( al, '&' );
	je separator;
	
	cmp( al, '~' );
	je separator;
	
	cmp( al, '>' );
	je greater;
	
	cmp( al, '<' );
	je less;
	
	cmp( al, ')' );
	je close_parenthesis;
	
	or( al, al );
	jz contents_parsed;
	
	cmp( al, '[' );
	je address_argument;
	
	cmp( al, ']' );
	je separator;
	
	cmp( al, '{' );
	je unallowed_character;
	
	cmp( al, '}' );
	je unallowed_character;
	
	cmp( al, '#' );
	je unallowed_character;
	
	cmp( al, '`' );
	je unallowed_character;
	
	dec( esi );
	cmp( al, lenStrTkn );
	jne expression_argument;
	
	push( edi );
	mov( &directive_operators, edi );
	call get_operator;
	or( al, al );
	jnz operator_argument;
	
	inc( esi );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	mov( &symbols, edi );
	call get_symbol;
	jnc symbol_argument;
	
	mov( &formatter_symbols, edi );
	call get_symbol;
	jnc symbol_argument;
	
	cmp( ecx, 1 );
	jne check_argument;
	
	cmp( (type byte [esi]), '?' );
	jne check_argument;
	
	pop( edi );
	movsb;
	jmp argument_parsed;
	
  instruction_separator:
	stosb;
	jmp allow_embedded_instruction;

	
  symbol_argument:
	pop( edi );
	stosw;
	jmp argument_parsed;
	
  operator_argument:
	pop( edi );
	cmp( al, $85 );
	je ptr_argument;
	
	stosb;
	cmp( al, $80 );
	je forced_expression;
	
	cmp( al, $81 );
	je forced_parenthesis;
	
	cmp( al, $82 );
	je parse_from_operator;
	
	cmp( al, $89 );
	je parse_label_operator;
	jmp argument_parsed;
	
  allow_embedded_instruction:
	cmp( (type byte [esi]), lenStrTkn );
	jne parseArgument;
	
	push( edi );
	inc( esi );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	call get_instruction;
	jnc embedded_instruction;
	
	mov( &data_directives, edi );
	call get_symbol;
	jnc embedded_data_instruction;
	
	pop( edi );
	sub( 2, esi );
	jmp parseArgument;
	
  embedded_data_instruction:
	movzx( ah, ebx );
	mov( data_handlers[ebx*4], ebx );
//fasmassembler:	sub( &fasmAssembler, ebx );
	
  embedded_instruction:
	pop( edi );
	mov( al, dl );
	mov( 1, al );
	stosb;
	mov( bx, ax );
	stosw;
	mov( dl, al );
	stosb;
	jmp parse_instruction_arguments;
	
  parse_times_directive:
	mov( '(', al );
	stosb;
	call convert_expression;
	mov( ')', al );
	stosb;
	cmp( (type byte [esi]), ':' );
	jne allow_embedded_instruction;
	
	movsb;
	jmp allow_embedded_instruction;
	
  parse_label_directive:
	cmp( (type byte [esi]), lenStrTkn );
	jne argument_parsed;
	
	push( esi );
	inc( esi );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	call identify_label;
	pop( ebx );
	cmp( eax, $0F );
	je non_label_identified;
	
	mov( 2, (type byte [edi]) );
	inc( edi );
	stosd;
	xor( al, al );
	stosb;
	jmp argument_parsed;
	
  non_label_identified:
	mov( ebx, esi );
	jmp argument_parsed;
	
  parse_load_directive:
	cmp( (type byte [esi]), lenStrTkn );
	jne argument_parsed;
	
	push( esi );
	inc( esi );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	call get_label_id;
	pop( ebx );
	cmp( eax, $0F );
	je non_label_identified;
	
	mov( 2, (type byte [edi]) );
	inc( edi );
	stosd;
	xor( al, al );
	stosb;
	jmp argument_parsed;
	
  parse_public_directive::
	cmp( (type byte [esi]), lenStrTkn );
	jne parseArgument;
	
	inc( esi );
	push( esi );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	mov( 2, al );
	stosb;
	call get_label_id;
	stosd;
	mov( $8600, ax );
	stosw;
	pop( ebx );
	push( ebx );
	push( esi );
	push( edi );
	mov( &directive_operators, edi );
	call get_operator;
	pop( edi );
	pop( edx );
	pop( ebx );
	cmp( al, $86 );
	je argument_parsed;
	
	mov( edx, esi );
	xchg( ebx, esi );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	mov( '(', ax );
	stosw;
	mov( ecx, eax );
	stosd;
	rep.movsb;
	xor( al, al );
	stosb;
	xchg( ebx, esi );
	jmp argument_parsed;
	
  parse_extrn_directive::
	cmp( (type byte [esi]), '"' );
	je parse_quoted_extrn;
	
	cmp( (type byte [esi]), lenStrTkn );
	jne parseArgument;
	
	push( esi );
	movzx( (type byte [esi+1]), ecx );
	add( 2, esi );
	mov( '(', ax );
	stosw;
	mov( ecx, eax );
	stosd;
	rep.movsb;
	mov( $8600, ax );
	stosw;
	pop( esi );
	
  parse_label_operator:
	cmp( (type byte [esi]), lenStrTkn );
	jne argument_parsed;
	inc( esi );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	mov( 2, al );
	stosb;
	call get_label_id;
	stosd;
	xor( al, al );
	stosb;
	jmp argument_parsed;
	
  parse_from_operator:
	cmp( (type byte [esi]), '"' );
	jne forced_expression;
	jmp argument_parsed;
	
  parse_quoted_extrn:
	inc( esi );
	mov( '(', ax );
	stosw;
	lodsd;
	mov( eax, ecx );
	stosd;
	rep.movsb;
	xor( al, al );
	stosb;
	push( esi );
	push( edi );
	mov( &directive_operators, edi );
	call get_operator;
	mov( esi, edx );
	pop( edi );
	pop( esi );
	cmp( al, $86 );
	jne argument_parsed;
	stosb;
	mov( edx, esi );
	jmp parse_label_operator;
	
  ptr_argument:
	call parse_address;
	jmp address_parsed;
	
  check_argument:
	push( esi );
	push( ecx );
	sub( 2, esi );
	mov( &single_operand_operators, edi );
	call get_operator;
	pop( ecx );
	pop( esi );
	or( al, al );
	jnz not_instruction;
	
	call get_instruction;
	jnc embedded_instruction;
	
	mov( &data_directives, edi );
	call get_symbol;
	jnc embedded_data_instruction;
	
  not_instruction:
	pop( edi );
	sub( 2, esi );
	
  expression_argument:
	cmp( (type byte [esi]), '"' );
	jne not_string;
	
	mov( [esi+1], eax );
	lea( ebx, [esi+eax+5] );
	push( ebx );
	push( ecx );
	push( esi );
	push( edi );
	mov( '(', al );
	stosb;
	call convert_expression;
	mov( ')', al );
	stosb;
	pop( eax );
	pop( edx );
	pop( ecx );
	pop( ebx );
	cmp( esi, ebx );
	jne expression_parsed;
	
	mov( eax, edi );
	mov( edx, esi );
  string_argument:
	inc( esi );
	mov( '(', ax );
	stosw;
	lodsd;
	mov( eax, ecx );
	stosd;
	shr( 1, ecx );
	jnc string_movsb_ok;
	
	movsb;
  string_movsb_ok:
	shr( 1, ecx );
	jnc string_movsw_ok;
	
	movsw;
  string_movsw_ok:
	rep.movsd;
	xor( al, al );
	stosb;
	jmp expression_parsed;
	
  not_string:
	cmp( (type byte [esi]), '(' );
	jne expression;
	
	mov( esp, eax );
	sub( $100, eax );
	jc stack_overflow;
	
	cmp( eax, stack_limit );
	jb stack_overflow;
	
	push( esi );
	push( edi );
	inc( esi );
	mov( '{', al );
	stosb;
	inc( parenthesis_stack );
	jmp parseArgument;
	
  expression:
	mov( '(', al );
	stosb;
	call convert_expression;
	mov( ')', al );
	stosb;
	jmp expression_parsed;
	
  forced_expression:
	mov( '(', al );
	stosb;
	call convert_expression;
	mov( ')', al );
	stosb;
	jmp argument_parsed;
	
  address_argument:
	call parse_address;
	lodsb;
	cmp( al, ']' );
	je address_parsed;
	
	dec( esi );
	mov( ')', al );
	stosb;
	jmp argument_parsed;
	
  address_parsed:
	mov( ']', al );
	stosb;
	jmp argument_parsed;
	
	
  forced_parenthesis:
	cmp( (type byte [esi]), '(' );
	jne argument_parsed;
	
	inc( esi );
	mov( '{', al );
	jmp separator;
	
  unallowed_character:
	mov( $0FF, al );
	jmp separator;
	
  close_parenthesis:
	mov( '}', al );
	
  separator:
	stosb;
	jmp argument_parsed;
	
	
  greater:
	cmp( (type byte [esi]), '=' );
	jne separator;
	inc( esi );
	mov( $0F2, al );
	jmp separator;
	
  less:
	cmp( (type byte [edi-1]), $0F6 );
	je separator;
	
	cmp( (type byte [esi]), '>' );
	je not_equal;
	
	cmp( (type byte [esi]), '=' );
	jne separator;
	
	inc( esi );
	mov( $0F3, al );
	jmp separator;
	
  not_equal:
	inc( esi );
	mov( $0F1, al );
	jmp separator;
	
  argument_parsed:
	cmp( parenthesis_stack, 0 );
	je parseArgument;
	
	dec( parenthesis_stack );
	add( 8, esp );
	jmp argument_parsed;
	
  expression_parsed:
	cmp( parenthesis_stack, 0 );
	je parseArgument;
	
	cmp( (type byte [esi]), ')' );
	jne argument_parsed;
	
	dec( parenthesis_stack );
	pop( edi );
	pop( esi );
	jmp expression;
	
  contents_parsed:
	cmp( parenthesis_stack, 0 );
	jne invalid_expression;
	ret();

end parse_instruction_arguments;



proc( parser );

	mov( memory_end, eax );
	mov( eax, labels_list );
	mov( additional_memory, eax );
	mov( eax, free_additional_memory );
	xor( eax, eax );
	mov( eax, current_locals_prefix );
	mov( eax, anonymous_reverse );
	mov( eax, anonymous_forward );
	mov( eax, hash_tree );
	mov( eax, blocks_stack );
	mov( memory_start, esi );
	mov( source_start, edi );
	
  parser_loop:
	mov( esi, current_line );
	lea( eax, [edi+$100] );
	out_of_mem( ae, eax, labels_list );
	
	cmp( (type byte [esi+16]), 0 );
	je empty_line;
	
	mov( $0F, al );
	stosb;
	mov( esi, eax );
	stosd;
	add( 16, esi );
	
  parse_line:
	cmp( (type byte [esi]), lenStrTkn );
	jne empty_instruction;
	
	push( edi );
	add( 2, esi );
	movzx( (type byte [esi-1]), ecx );
	cmp( (type byte [esi+ecx]), ':' );
	je simple_label;
	
	cmp( (type byte [esi+ecx]), '=' );
	je constant_label;
	
	call get_instruction;
	jnc main_instruction_identified;
	
	cmp( (type byte [esi+ecx]), lenStrTkn );
	jne no_data_label;
	
	push( esi );
	push( ecx );
	lea( esi, [esi+ecx+2] );
	movzx( (type byte [esi-1]), ecx );
	mov( &data_directives, edi );
	call get_symbol;
	jnc data_label;
	
	pop( ecx );
	pop( esi );
  no_data_label:
	mov( &data_directives, edi );
	call get_symbol;
	jnc data_instruction;
	
	pop( edi );
	sub( 2, esi );
	xor( bx, bx );
	call parse_line_contents;
	jmp parse_next_line;
	
  simple_label:
	pop( edi );
	call identify_label;
	mov( 2, (type byte [edi]) );
	inc( edi );
	stosd;
	inc( esi );
	xor( al, al );
	stosb;
	jmp parse_line;
	
  constant_label:
	pop( edi );
	call get_label_id;
	mov( 3, (type byte [edi]) );
	inc( edi );
	stosd;
	xor( al, al );
	stosb;
	inc( esi );
	xor( bx, bx );
	call parse_line_contents;
	jmp parse_next_line;
	
  data_label:
	pop( ecx );
	pop( ebx );
	pop( edi );
	push( eax );
	push( esi );
	mov( ebx, esi );
	movzx( (type byte [esi-1]), ecx );
	call identify_label;
	mov( 2, (type byte [edi]) );
	inc( edi );
	stosd;
	pop( esi );
	pop( eax );
	stosb;
	push( edi );
	
	
	jmp data_instruction;
	debugStr( "data_instruction" );
	
  data_instruction::
	movzx( ah, ebx );
	mov( data_handlers[ebx*4], ebx );
//fasmassembler:	sub( &fasmAssembler, ebx );
	
  main_instruction_identified:
	pop( edi );
	mov( al, dl );
	mov( 1, al );
	stosb;
	mov( bx, ax );
	stosw;
	mov( dl, al );
	stosb;
	cmp( bx, if_directive_assembler );
	je parse_block;
	
	cmp( bx, repeat_directive_assembler );
	je parse_block;
	
	cmp( bx, while_directive_assembler );
	je parse_block;
	
	cmp( bx, end_directive_assembler );
	je parse_end_directive;
	
	cmp( bx, else_directive_assembler );
	je parse_else;
	
  common_parse:
	call parse_line_contents;
	jmp parse_next_line;
	
  empty_instruction:
	lodsb;
	or( al, al );
	jz parse_next_line;
	
	cmp( al, ':' );
	je invalid_name;
	
	cmp( al, auxDataToken );
	je skip_preprocessed_symbol;
	
	dec( esi );
	xor( ebx, ebx );
	call parse_instruction_arguments;
	jmp parse_next_line;
	
  skip_preprocessed_symbol:
	lodsb;
	movzx( al, eax );
	add( eax, esi );
	
  skip_next:
	lodsb;
	or( al, al );
	jz parse_next_line;
	
	cmp( al, lenStrTkn );
	je skip_preprocessed_symbol;
	
	cmp( al, auxDataToken );
	je skip_preprocessed_symbol;
	
	cmp( al, '"' );
	je skip_preprocessed_string;
	jmp skip_next;
	
  skip_preprocessed_string:
	lodsd;
	add( eax, esi );
	jmp skip_next;
	
  empty_line:
	add( 17, esi );
	
  parse_next_line:
	cmp( esi, source_start );
	jb parser_loop;
	
  source_parsed:
	cmp( blocks_stack, 0 );
	je blocks_stack_ok;
	
	pop( eax );
	pop( current_line );
	jmp missing_end_directive;
	
  blocks_stack_ok:
	xor( al, al );
	stosb;
	mov( error_line, eax );
	mov( eax, current_line );
	cmp( anonymous_forward, 0 );
	jne invalid_value;
	
	add( $0F, edi );
	and( !$0F, edi );
	mov( edi, code_start );
	ret();

  parse_block:
	mov( esp, eax );
	sub( $100, eax );
	jc stack_overflow;
	
	cmp( eax, stack_limit );
	jb stack_overflow;
	
	push( current_line );
	mov( bx, ax );
	shl( 16, eax );
	push( eax );
	inc( blocks_stack );
	cmp( bx, if_directive_assembler );
	je parse_if;
	
	cmp( bx, while_directive_assembler );
	je parse_while;
	
	call parse_line_contents;
	jmp parse_next_line;
	
  parse_end_directive::
	cmp( (type byte [esi]), lenStrTkn );
	jne common_parse;
	
	push( edi );
	inc( esi );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	call get_instruction;
	pop( edi );
	jnc parse_end_block;
	sub( 2, esi );
	jmp common_parse;
	
  parse_end_block:
	mov( al, dl );
	mov( 1, al );
	stosb;
	mov( bx, ax );
	stosw;
	mov( dl, al );
	stosb;
	lodsb;
	or( al, al );
	jnz extra_characters_on_line;
	
	cmp( bx, if_directive_assembler );
	je close_parsing_block;
	
	cmp( bx, repeat_directive_assembler );
	je close_parsing_block;
	
	cmp( bx, while_directive_assembler );
	je close_parsing_block;
	jmp parse_next_line;
	
  close_parsing_block:
	cmp( blocks_stack, 0 );
	je unexpected_instruction;
	
	cmp( bx, [esp+2] );
	jne unexpected_instruction;
	
	dec( blocks_stack );
	pop( eax );
	pop( edx );
	cmp( bx, if_directive_assembler );
	jne parse_next_line;
	
	test( %1100, al );
	jz parse_next_line;
	
	test( %10000, al );
	jnz parse_next_line;
	
	sub( 8, edi );
	jmp parse_next_line;
	
  parse_if:
	push( edi );
	call parse_line_contents;
	xor( al, al );
	stosb;
	xchg( [esp], esi );
	mov( esi, edi );
	call preevaluate_logical_expression;
	pop( esi );
	cmp( al, '0' );
	je parse_false_condition_block;
	
	cmp( al, '1' );
	je parse_true_condition_block;
	
	or( %10000, (type byte [esp]) );
	jmp parse_next_line;
	
  parse_while:
	push( edi );
	call parse_line_contents;
	xor( al, al );
	stosb;
	xchg( [esp], esi );
	mov( esi, edi );
	call preevaluate_logical_expression;
	pop( esi );
	cmp( al, '0' );
	je parse_false_condition_block;
	
	cmp( al, '1' );
	jne parse_next_line;
	
	stosb;
	jmp parse_next_line;
	
  parse_false_condition_block:
	or( 1, (type byte [esp]) );
	sub( 4, edi );
	jmp skip_parsing;
	
  parse_true_condition_block:
	or( %100, (type byte [esp]) );
	sub( 4, edi );
	jmp parse_next_line;
	
  parse_else:
	cmp( blocks_stack, 0 );
	je unexpected_instruction;
	
	mov( [esp+2], ax );
	cmp( ax, if_directive_assembler );
	jne unexpected_instruction;
	
	lodsb;
	or( al, al );
	jz parse_pure_else;
	
	cmp( al, lenStrTkn );
	jne extra_characters_on_line;
	
	push( edi );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	call get_instruction;
	jc extra_characters_on_line;
	
	pop( edi );
	cmp( bx, if_directive_assembler );
	jne extra_characters_on_line;
	test( %100, (type byte [esp]) );
	jnz skip_true_condition_else;
	
	mov( al, dl );
	mov( 1, al );
	stosb;
	mov( bx, ax );
	stosw;
	mov( dl, al );
	stosb;
	jmp parse_if;
	
  skip_true_condition_else:
	sub( 4, edi );
	or( 1, (type byte [esp]) );
	jmp skip_parsing_contents;
	
  parse_pure_else:
	bts( 1, (type dword [esp]) );
	jc unexpected_instruction;
	
	test( %100, (type byte [esp]) );
	jz parse_next_line;
	
	sub( 4, edi );
	or( 1, (type byte [esp]) );
	jmp skip_parsing;
	
  skip_parsing:
	cmp( esi, source_start );
	jae source_parsed;
	
	mov( esi, current_line );
	add( 16, esi );
  skip_parsing_line:
	cmp( (type byte [esi]), lenStrTkn );
	jne skip_parsing_contents;
	
	inc( esi );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	cmp( (type byte [esi+ecx]), ':' );
	je skip_parsing_label;
	
	push( edi );
	call get_instruction;
	pop( edi );
	jnc skip_parsing_instruction;
	add( ecx, esi );
	jmp skip_parsing_contents;
	
  skip_parsing_label:
	lea( esi, [esi+ecx+1] );
	jmp skip_parsing_line;
	
  skip_parsing_instruction:
	cmp( bx, if_directive_assembler );
	je skip_parsing_block;
	
	cmp( bx, repeat_directive_assembler );
	je skip_parsing_block;
	
	cmp( bx, while_directive_assembler );
	je skip_parsing_block;
	
	cmp( bx, end_directive_assembler );
	je skip_parsing_end_directive;
	cmp( bx, else_directive_assembler );
	je skip_parsing_else;
	
  skip_parsing_contents:
	lodsb;
	or( al, al );
	jz skip_parsing;
	
	cmp( al, lenStrTkn );
	je skip_parsing_symbol;
	
	cmp( al, auxDataToken );
	je skip_parsing_symbol;
	
	cmp( al, '"' );
	je skip_parsing_string;
	jmp skip_parsing_contents;
	
  skip_parsing_symbol:
	lodsb;
	movzx( al, eax );
	add( eax, esi );
	jmp skip_parsing_contents;
	
  skip_parsing_string:
	lodsd;
	add( eax, esi );
	jmp skip_parsing_contents;
	
  skip_parsing_block:
	mov( esp, eax );
	sub( $100, eax );
	jc stack_overflow;
	
	cmp( eax, stack_limit );
	jb stack_overflow;
	
	push( current_line );
	mov( bx, ax );
	shl( 16, eax );
	push( eax );
	inc( blocks_stack );
	jmp skip_parsing_contents;
	
  skip_parsing_end_directive:
	cmp( (type byte [esi]), lenStrTkn );
	jne skip_parsing_contents;
	
	push( edi );
	inc( esi );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	call get_instruction;
	pop( edi );
	jnc skip_parsing_end_block;
	
	add( ecx, esi );
	jmp skip_parsing_contents;
	
  skip_parsing_end_block:
	lodsb;
	or( al, al );
	jnz extra_characters_on_line;
	
	cmp( bx, if_directive_assembler );
	je close_skip_parsing_block;
	
	cmp( bx, repeat_directive_assembler );
	je close_skip_parsing_block;
	
	cmp( bx, while_directive_assembler );
	je close_skip_parsing_block;
	jmp skip_parsing;
	
  close_skip_parsing_block:
	cmp( blocks_stack, 0 );
	je unexpected_instruction;
	
	cmp( bx, [esp+2] );
	jne unexpected_instruction;
	
	dec( blocks_stack );
	pop( eax );
	pop( edx );
	test( 1, al );
	jz skip_parsing;
	
	cmp( bx, if_directive_assembler );
	jne parse_next_line;
	
	test( %10000, al );
	jz parse_next_line;
	
	mov( $0F, al );
	stosb;
	mov( current_line, eax );
	stosd;
	
	//mov( 1 + (end_directive_assembler) << 8, eax );
	movzx( end_directive_assembler, eax );
	shl( 8, eax );
	inc( eax );
	stosd;

	//mov( 1 + (if_directive_assembler) << 8, eax );
	movzx( if_directive_assembler, eax );
	shl( 8, eax );
	inc( eax );
	
	stosd;
	jmp parse_next_line;
	
  skip_parsing_else:
	cmp( blocks_stack, 0 );
	je unexpected_instruction;
	
	mov( [esp+2], ax );
	cmp( ax, if_directive_assembler );
	jne unexpected_instruction;
	
	lodsb;
	or( al, al );
	jz skip_parsing_pure_else;
	
	cmp( al, lenStrTkn );
	jne extra_characters_on_line;
	
	push( edi );
	movzx( (type byte [esi]), ecx );
	inc( esi );
	call get_instruction;
	jc extra_characters_on_line;
	
	pop( edi );
	cmp( bx, if_directive_assembler );
	jne extra_characters_on_line;
	
	mov( [esp], al );
	test( 1, al );
	jz skip_parsing_contents;
	
	test( %100, al );
	jnz skip_parsing_contents;
	
	test( %10000, al );
	jnz parse_else_if;
	
	xor( al, al );
	mov( al, [esp] );
	mov( $0F, al );
	stosb;
	mov( current_line, eax );
	stosd;
	
  parse_else_if:
	//mov( 1 + (if_directive_assembler) << 8, eax );
	movzx( if_directive_assembler, eax );
	shl( 8, eax );
	inc( eax );
	stosd;
	jmp parse_if;
	
  skip_parsing_pure_else:
	bts( 1, (type dword [esp]) );
	jc unexpected_instruction;
	
	mov( [esp], al );
	test( 1, al );
	jz skip_parsing;
	
	test( %100, al );
	jnz skip_parsing;
	and( _byte( !1 ), al );
	or( %1000, al );
	mov( al, [esp] );
	jmp parse_next_line;

	

end parser;




//////////////////////////////////////////////////////////////////////////

proc( mark_relocation );

	cmp( value_type, 0 );
	je relocation_ok;
	cmp( virtual_data, 0 );
	jne relocation_ok;
	cmp( output_format, 2 );
	je mark_mz_relocation;
	cmp( output_format, 3 );
	je mark_pe_relocation;
	cmp( output_format, 4 );
	je mark_coff_relocation;
	cmp( output_format, 5 );
	je mark_elf_relocation;
  relocation_ok:
	ret();
	
  mark_mz_relocation:
	push( eax );
	push( ebx );
	inc( number_of_relocations );
	mov( free_additional_memory, ebx );
	mov( edi, eax );
	sub( code_start, eax );
	mov( ax, [ebx] );
	shr( 16, eax );
	shl( 12, ax );
	mov( ax, [ebx+2] );
	cmp( (type word [ebx]), $0FFFF );
	jne mz_relocation_ok;
	inc( (type word [ebx+2]) );
	sub( $10, (type word [ebx]) );
  mz_relocation_ok:
	add( 4, ebx );
	out_of_mem( ae, ebx, structures_buffer );
	mov( ebx, free_additional_memory );
	pop( ebx );
	pop( eax );
	ret();
	
	
  mark_coff_relocation:
	cmp( value_type, 3 );
	je coff_relocation_relative;
	
	push( ebx );
	push( eax );
	test( 8, format_flags );
	jnz coff_64bit_relocation;
	
	mov( 6, al );
	jmp coff_relocation;
	
  coff_64bit_relocation:
	mov( 1, al );
	jmp coff_relocation;
	
  coff_relocation_relative:
	push( ebx );
	bt( 0, format_flags );
	jnc relative_ok;
	mov( current_section, ebx );
	mov( [ebx+8], ebx );
	sub( edi, ebx );
	sub( ebx, eax );
	add( 4, eax );
	
  relative_ok:
	push( eax );
	mov( 20, al );
	test( 8, format_flags );
	jnz relative_coff_64bit_relocation;
	cmp( labels_type, 2 );
	jne invalid_use_of_symbol;
	jmp coff_relocation;
	
  relative_coff_64bit_relocation:
	mov( 4, al );
	cmp( labels_type, 4 );
	jne invalid_use_of_symbol;
	
  coff_relocation:
	mov( free_additional_memory, ebx );
	add( $0C, ebx );
	out_of_mem( ae, ebx, structures_buffer );
	
	mov( ebx, free_additional_memory );
	mov( al, (type byte [ebx-$0C]) );
	mov( current_section, eax );
	mov( [eax+8], eax );
	neg( eax );
	add( edi, eax );
	mov( eax, [ebx-$0C+4] );
	mov( symbol_identifier, eax );
	mov( eax, [ebx-$0C+8] );
	pop( eax );
	pop( ebx );
	ret();
	
	
  mark_elf_relocation:
	cmp( value_type, 3 );
	je elf_relocation_relative;
	push( ebx );
	push( eax );
	cmp( value_type, 3 );
	je elf_gotoff_relocation;
	mov( 1, al );
	jmp coff_relocation;
  elf_gotoff_relocation:
	mov( 9, al );
	jmp coff_relocation;
  elf_relocation_relative:
	cmp( labels_type, 0 );
	je invalid_use_of_symbol;
	push( ebx );
	mov( current_section, ebx );
	mov( [ebx+8], ebx );
	sub( edi, ebx );
	sub( ebx, eax );
	push( eax );
	mov( 2, al );
	jmp coff_relocation;
	
  mark_pe_relocation:
	push( eax );
	push( ebx );
	mov( current_section, ebx );
	mov( edi, eax );
	sub( [ebx+$14], eax );
	add( [ebx+$0C], eax );
	mov( free_additional_memory, ebx );
	inc( number_of_relocations );
	jz invalid_use_of_symbol;
	
	mov( eax, [ebx] );
	add( 4, ebx );
	out_of_mem( ae, ebx, structures_buffer );
	
	mov( ebx, free_additional_memory );
	pop( ebx );
	pop( eax );
	ret();
	
	
end mark_relocation;


proc( close_pe_section );

	mov( current_section, ebx );
	mov( code_start, edx );
	mov( edi, eax );
	sub( [ebx+$14], eax );
	jnz finish_section;
	
	bt( 5, format_flags );
	jc finish_section;
	mov( [ebx+$0C], eax );
	ret();

  finish_section:
	mov( eax, [ebx+8] );
	cmp( edi, undefined_data_end );
	jne align_section;
	cmp( (type dword [edx+$38]), $1000 );
	jb align_section;
	mov( undefined_data_start, edi );
	
  align_section:
	mov( 0, undefined_data_end );
	mov( edi, ebp );
	sub( [ebx+$14], ebp );
	mov( [edx+$3C], ecx );
	dec( ecx );
	lea( eax, [ebp+ecx] );
	not( ecx );
	and( ecx, eax );
	mov( eax, [ebx+$10] );
	sub( ebp, eax );
	mov( eax, ecx );
	xor( al, al );
	rep.stosb;
	mov( code_start, eax );
	sub( stub_size, eax );
	sub( eax, [ebx+$14] );
	mov( [ebx+8], eax );
	or( eax, eax );
	jz udata_ok;
	
	// See if any data was emitted for this section:
	
	cmp( (type dword [ebx+$10]), 0 );
	jne udata_ok;
	

	// Set the uninitialized data flag if there was
	// not data emitted.
	
	or( $80, (type byte [ebx+$24]) );
	
  udata_ok:
	mov( [edx+$38], ecx );
	dec( ecx );
	add( ecx, eax );
	not( ecx );
	and( ecx, eax );
	add( [ebx+$0C], eax );
	add( $28, ebx );
	mov( ebx, current_section );
	inc( (type word number_of_sections) );
	jz format_limitations_exceeded;
	ret();
	
end close_pe_section;


proc( close_elf_segment );

	cmp( number_of_sections, 0 );
	jne finish_elf_segment;
	cmp( edi, symbols_stream );
	jne first_elf_segment_ok;
	push( edi );
	mov( code_start, edi );
	add( $34, edi );
	mov( $20 >> 2, ecx );
	xor( eax, eax );
	rep.stosd;
	pop( edi );
	mov( image_base, eax );
	ret();

  first_elf_segment_ok:
	inc( number_of_sections );
  finish_elf_segment:
	mov( number_of_sections, ebx );
	dec( ebx );
	shl( 5, ebx );
	add( code_start, ebx );
	add( $34, ebx );
	mov( edi, eax );
	sub( code_start, eax );
	sub( [ebx+4], eax );
	mov( edi, edx );
	cmp( edi, undefined_data_end );
	jne elf_segment_size_ok;
	mov( undefined_data_start, edi );
  elf_segment_size_ok:
	mov( eax, [ebx+$14] );
	add( edi, eax );
	sub( edx, eax );
	mov( eax, [ebx+$10] );
	mov( [ebx+8], eax );
	add( [ebx+$14], eax );
	add( $0FFF, eax );
	and( !$0FFF, eax );
	ret();
	
end close_elf_segment;


proc( close_elf64_segment );

	cmp( number_of_sections, 0 );
	jne finish_elf64_segment;
	cmp( edi, symbols_stream );
	jne first_elf64_segment_ok;
	push( edi );
	mov( code_start, edi );
	add( $40, edi );
	mov( $38 >> 2, ecx );
	xor( eax, eax );
	rep.stosd;
	pop( edi );
	mov( image_base, eax );
	mov( image_base_high, edx );
	ret();

  first_elf64_segment_ok:
	inc( number_of_sections );
  finish_elf64_segment:
	mov( number_of_sections, ebx );
	dec( ebx );
	intmul( $38, ebx );
	add( code_start, ebx );
	add( $40, ebx );
	mov( edi, eax );
	sub( code_start, eax );
	sub( [ebx+8], eax );
	mov( edi, edx );
	cmp( edi, undefined_data_end );
	jne elf64_segment_size_ok;
	mov( undefined_data_start, edi );
  elf64_segment_size_ok:
	mov( eax, [ebx+$28] );
	add( edi, eax );
	sub( edx, eax );
	mov( eax, [ebx+$20] );
	mov( [ebx+$10], eax );
	mov( [ebx+$10+4], edx );
	add( [ebx+$28], eax );
	adc( 0, edx );
	sub( 1, eax );
	sbb( 0, edx );
	shrd( 12, edx, eax );
	shr( 12, edx );
	add( 1, eax );
	adc( 0, edx );
	shld( 12, eax, edx );
	shl( 12, eax );
	ret();
	
end close_elf64_segment;


proc( close_coff_section );

	mov( current_section, ebx );
	mov( edi, eax );							// End of section data
	mov( fSectionEBX.StartOfSection, edx );		// [ebx+8]
	sub( edx, eax );							// Compute size of uninit data
	mov( eax, fSectionEBX.SectionSize );		// [ebx+$0C]

	// Here we determine if there was a run of uninitialized data at the
	// end of the section.
	
	xor( eax, eax );
	xchg( eax, undefined_data_end );
	cmp( eax, edi );
	jne coff_section_ok;
	
	cmp( edx, undefined_data_start );
	jne coff_section_ok;
	
	// Okay, there was a run of uninitialized data values at the end of the
	// section.
	
	mov( edx, edi );
	or( $80, (type byte fSectionEBX.Characteristics));	//[ebx+$14]
	and( %1011_1111, (type byte fSectionEBX.Characteristics) );
	
  coff_section_ok:
	ret();
	
end close_coff_section;




proc( close_pass );

	mov( output_format, al );
	cmp( al, 3 );
	je close_pe;
	cmp( al, 4 );
	je close_coff;
	cmp( al, 5 );
	je close_elf;
	ret();
	
  close_coff:
	call close_coff_section;
	cmp( next_pass_needed, 0 );
	je coff_closed;
	mov( symbols_stream, eax );
	mov( eax, free_additional_memory );
  coff_closed:
	ret();
	
  close_elf:
	bt( 0, format_flags );
	jc close_elf_exe;
	call close_coff_section;
	cmp( next_pass_needed, 0 );
	je elf_closed;
	mov( symbols_stream, eax );
	mov( eax, free_additional_memory );
  elf_closed:
	ret();
	
  close_elf_exe:
	test( 8, format_flags );
	jnz close_elf64_exe;
	call close_elf_segment;
	mov( code_start, edx );
	mov( number_of_sections, eax );
	mov( $34, (type byte [edx+$1C]) );
	mov( ax, [edx+$2C] );
	shl( 5, eax );
	add( edx, eax );
	add( $34, eax );
	cmp( eax, symbols_stream );
	je elf_exe_ok;
	or( -1, next_pass_needed );
  elf_exe_ok:
	ret();
	
  close_elf64_exe:
	call close_elf64_segment;
	mov( code_start, edx );
	mov( number_of_sections, eax );
	mov( $40, (type byte [edx+$20]) );
	mov( ax, [edx+$38] );
	intmul( $38, eax );
	add( edx, eax );
	add( $40, eax );
	cmp( eax, symbols_stream );
	je elf64_exe_ok;
	or( -1, next_pass_needed );
  elf64_exe_ok:
	ret();
	
	
	
  close_pe:
	call close_pe_section;
	mov( code_start, edx );
	mov( eax, [edx+$50] );
	call make_timestamp;
	mov( code_start, edx );
	mov( eax, [edx+8] );
	mov( number_of_relocations, eax );
	cmp( eax, 0 );
	jle pe_flags_ok;
	or( 1, (type word [edx+$16]) );
	shl( 2, eax );
	sub( eax, free_additional_memory );
  pe_flags_ok:
	mov( number_of_sections, eax );
	mov( ax, [edx+6] );
	intmul( $28, eax );
	movzx( (type word [edx+$14]), ecx );
	lea( eax, [eax+ecx+$18] );
	add( stub_size, eax );
	mov( [edx+$3C], ecx );
	dec( ecx );
	add( ecx, eax );
	not( ecx );
	and( ecx, eax );
	cmp( eax, [edx+$54] );
	je pe_sections_ok;
	or( -1, next_pass_needed );
  pe_sections_ok:
	xor( ecx, ecx );
	add( $78, edx );
	test( 8, format_flags );
	jz process_directories;
	add( $10, edx );
  process_directories:
	mov( [edx+ecx*8], eax );
	or( eax, eax );
	jz directory_ok;
	cmp( (type dword [edx+ecx*8+4]), -1 );
	jne directory_ok;
  section_data:
	mov( [edx+ecx*8], ebx );
	mov( [ebx+$0C], eax );
	mov( eax, [edx+ecx*8] );
	mov( [ebx+8], eax );
	mov( eax, [edx+ecx*8+4] );
  directory_ok:
	inc( cl );
	cmp( cl, $10 );
	jb process_directories;
	mov( code_start, ebx );
	sub( stub_size, ebx );
	mov( edi, ecx );
	sub( ebx, ecx );
	mov( ecx, ebp );
	shr( 1, ecx );
	xor( eax, eax );
	cdq;
  calculate_checksum:
	mov( [ebx], dx );
	add( edx, eax );
	mov( ax, dx );
	shr( 16, eax );
	add( edx, eax );
	add( 2, ebx );
	loop calculate_checksum;
	add( ebp, eax );
	mov( code_start, ebx );
	mov( eax, [ebx+$58] );
	ret();

end close_pass;



proc( allocate_structure_data );

	mov( structures_buffer, ebx );
	sub( $20, ebx );
	out_of_mem( b, ebx, free_additional_memory );
	mov( ebx, structures_buffer );
	ret();
	
end allocate_structure_data;


proc( open_binary_file );

	push( esi );
	push( edi );
	mov( current_line, esi );
	mov( [esi], esi );
  get_current_path:
	lodsb;
	stosb;
	or( al, al );
	jnz get_current_path;
  cut_current_path:
	cmp( edi, [esp] );
	je current_path_ok;
	cmp( (type byte [edi-1]), '\' );
	je current_path_ok;
	cmp( (type byte [edi-1]), '/' );
	je current_path_ok;
	dec( edi );
	jmp cut_current_path;
  current_path_ok:
	mov( [esp+4], esi );
	call preprocess_path;
	pop( edx );
	mov( edx, esi );
	call open;
	jnc file_opened;
	mov( esi, edi );
	mov( [esp], esi );
	push( edi );
	call preprocess_path;
	pop( edx );
	mov( edx, esi );
	call open;
	jc file_not_found;
  file_opened:
	mov( esi, edi );
	pop( esi );
	ret();
	
end open_binary_file;


// undefined_data-
//
// Tracks the *last* block of undefined data values in a section.
// If the block of declarations at the end of a section (or the 
// whole section) contains only uninitialized objects, then we
// can set the "SizeOfUninitializedData" field in the (COFF) section
// header.
//
// On entry:
//
//	EAX-
//		Points at the beginning of the current uninitialized block
//
//	EDI-
//		Points at the end of the current uninitialized block.

proc( undefined_data( newStart:dword in eax; newEnd:dword in edi ));

	// Ignore this operation if it's virtual declaration:
	
	if( virtual_data == 0 ) then
	
		// If the new start matches the old end,
		// then we're simply extending the current
		// block of uninitialized data.
		
		if( eax <> undefined_data_end ) then
		
			// If we're not extending the old block, then we've
			// got to set the new start of uninitialized data:
			
			mov( eax, undefined_data_start );
			
		endif;
		
		// Mark the end of the block:
		
		mov( edi, undefined_data_end );
		
	endif;
	ret();
	
end undefined_data;


proc( generate_pe_data );

	cmp( al, 2 );
	je make_pe_resource;
	cmp( al, 5 );
	je make_pe_fixups;
	ret();

  make_pe_resource:
	cmp( (type byte [esi]), $82 );
	jne resource_done;
	inc( esi );
	lodsw;
	cmp( ax, '(' );
	jne invalid_argument;
	lodsd;
	mov( esi, edx );
	lea( esi, [esi+eax+1] );
	cmp( next_pass_needed, 0 );
	je resource_from_file;
	cmp( current_pass, 0 );
	jne reserve_space_for_resource;
	mov( 0, resource_size );
  reserve_space_for_resource:
	add( resource_size, edi );
	out_of_mem( a, edi, display_buffer );
	jmp resource_done;
  resource_from_file:
	push( esi );
	mov( edx, esi );
	call open_binary_file;
	push( ebx );
	mov( free_additional_memory, esi );
	lea( eax, [esi+$20] );
	out_of_mem( a, eax, structures_buffer );
	mov( esi, edx );
	mov( $20, ecx );
	read( ebx, edx, ecx );
	jc invalid_file_format;
	xor( eax, eax );
	cmp( [esi], eax );
	jne invalid_file_format;
	mov( $0FFFF, ax );
	cmp( [esi+8], eax );
	jne invalid_file_format;
	cmp( [esi+12], eax );
	jne invalid_file_format;
	mov( $20, eax );
	cmp( [esi+4], eax );
	jne invalid_file_format;
  read_resource_headers:
	test( %11, eax );
	jz resource_file_alignment_ok;
	mov( 4, edx );
	and( %11, eax );
	sub( eax, edx );
	mseek( ebx, edx );
  resource_file_alignment_ok:
	mov( eax, [esi] );
	lea( edx, [esi+12] );
	mov( 8, ecx );
	read( ebx, edx, ecx );
	jc resource_headers_ok;
	mov( [esi+16], ecx );
	add( ecx, [esi] );
	lea( edx, [esi+20] );
	sub( 8, ecx );
	mov( ecx, [esi+16] );
	lea( eax, [edx+ecx] );
	out_of_mem( a, eax, structures_buffer );
	read( ebx, edx, ecx );
	jc invalid_file_format;
	mov( [esi], edx );
	add( [esi+12], edx );
	mov( [esi+16], eax );
	lea( ecx, [esi+20] );
	lea( esi, [ecx+eax] );
	add( 2, ecx );
	cmp( (type word [ecx-2]), $0FFFF );
	je resource_header_type_ok;
  check_resource_header_type:
	cmp( ecx, esi );
	jae invalid_file_format;
	cmp( (type word [ecx]), 0 );
	je resource_header_type_ok;
	add( 2, ecx );
	jmp check_resource_header_type;
  resource_header_type_ok:
	add( 2, ecx );
	cmp( (type word [ecx]), $0FFFF );
	je resource_header_name_ok;
  check_resource_header_name:
	cmp( ecx, esi );
	jae invalid_file_format;
	cmp( (type word [ecx]), 0 );
	je resource_header_name_ok;
	add( 2, ecx );
	jmp check_resource_header_name;
  resource_header_name_ok:
	seek( ebx, edx );
	jmp read_resource_headers;
  resource_headers_ok:
	xor( eax, eax );
	mov( eax, [esi] );
	mov( edi, resource_data );
	lea( eax, [edi+16] );
	out_of_mem( ae, eax, display_buffer );
	xor( eax, eax );
	stosd;
	call make_timestamp;
	stosd;
	xor( eax, eax );
	stosd;
	stosd;
	xor( ebx, ebx );
  make_type_name_directory:
	mov( free_additional_memory, esi );
	xor( edx, edx );
  find_type_name:
	cmp( (type dword [esi]), 0 );
	je type_name_ok;
	add( 20, esi );
	cmp( (type word [esi]), $0FFFF );
	je check_next_type_name;
	or( ebx, ebx );
	jz check_this_type_name;
	xor( ecx, ecx );
  compare_with_previous_type_name:
	mov( [esi+ecx], ax );
	cmp( ax, [ebx+ecx] );
	ja check_this_type_name;
	jb check_next_type_name;
	add( 2, ecx );
	mov( [esi+ecx], ax );
	or( [ebx+ecx], ax );
	jnz compare_with_previous_type_name;
	jmp check_next_type_name;
  check_this_type_name:
	or( edx, edx );
	jz type_name_found;
	xor( ecx, ecx );
  compare_with_current_type_name:
	mov( [esi+ecx], ax );
	cmp( ax, [edx+ecx] );
	ja check_next_type_name;
	jb type_name_found;
	add( 2, ecx );
	mov( [esi+ecx], ax );
	or( [edx+ecx], ax );
	jnz compare_with_current_type_name;
	jmp same_type_name;
  type_name_found:
	mov( esi, edx );
  same_type_name:
	mov( edi, [esi-16] );
  check_next_type_name:
	mov( [esi-4], eax );
	add( eax, esi );
	jmp find_type_name;
  type_name_ok:
	or( edx, edx );
	jz type_name_directory_done;
	mov( edx, ebx );
  make_type_name_entry:
	mov( resource_data, eax );
	inc( (type word [eax+12]) );
	lea( eax, [edi+8] );
	out_of_mem( ae, eax, display_buffer );
	mov( ebx, eax );
	stosd;
	xor( eax, eax );
	stosd;
	jmp make_type_name_directory;
  type_name_directory_done:
	mov( -1, ebx );
  make_type_id_directory:
	mov( free_additional_memory, esi );
	mov( $10000, edx );
  find_type_id:
	cmp( (type dword [esi]), 0 );
	je type_id_ok;
	add( 20, esi );
	cmp( (type word [esi]), $0FFFF );
	jne check_next_type_id;
	movzx( (type word [esi+2]), eax );
	cmp( eax, ebx );
	jle check_next_type_id;
	cmp( eax, edx );
	jg check_next_type_id;
	mov( eax, edx );
	mov( edi, [esi-16] );
  check_next_type_id:
	mov( [esi-4], eax );
	add( eax, esi );
	jmp find_type_id;
  type_id_ok:
	cmp( edx, $10000 );
	je type_id_directory_done;
	mov( edx, ebx );
  make_type_id_entry:
	mov( resource_data, eax );
	inc( (type word [eax+14]) );
	lea( eax, [edi+8] );
	out_of_mem( ae, eax, display_buffer );
	mov( ebx, eax );
	stosd;
	xor( eax, eax );
	stosd;
	jmp make_type_id_directory;
  type_id_directory_done:
	mov( resource_data, esi );
	add( $10, esi );
	mov( [esi-4], ecx );
	or( cx, cx );
	jz resource_directories_ok;
  make_resource_directories:
	push( ecx );
	push( edi );
	mov( edi, edx );
	sub( resource_data, edx );
	bts( 31, edx );
	mov( edx, [esi+4] );
	lea( eax, [edi+16] );
	out_of_mem( ae, eax, display_buffer );
	xor( eax, eax );
	stosd;
	call make_timestamp;
	stosd;
	xor( eax, eax );
	stosd;
	stosd;
	mov( esi, ebp );
	xor( ebx, ebx );
  make_resource_name_directory:
	mov( free_additional_memory, esi );
	xor( edx, edx );
  find_resource_name:
	cmp( (type dword [esi]), 0 );
	je resource_name_ok;
	push( esi );
	cmp( [esi+4], ebp );
	jne check_next_resource_name;
	add( 20, esi );
	call skip_resource_name;
	cmp( (type word [esi]), $0FFFF );
	je check_next_resource_name;
	or( ebx, ebx );
	jz check_this_resource_name;
	xor( ecx, ecx );
  compare_with_previous_resource_name:
	mov( [esi+ecx], ax );
	cmp( ax, [ebx+ecx] );
	ja check_this_resource_name;
	jb check_next_resource_name;
	add( 2, ecx );
	mov( [esi+ecx], ax );
	or( [ebx+ecx], ax );
	jnz compare_with_previous_resource_name;
	jmp check_next_resource_name;
  skip_resource_name:
	cmp( (type word [esi]), $0FFFF );
	jne skip_unicode_string;
	add( 4, esi );
	ret();

  skip_unicode_string:
	add( 2, esi );
	cmp( (type word [esi-2]), 0 );
	jne skip_unicode_string;
	ret();

  check_this_resource_name:
	or( edx, edx );
	jz resource_name_found;
	xor( ecx, ecx );
  compare_with_current_resource_name:
	mov( [esi+ecx], ax );
	cmp( ax, [edx+ecx] );
	ja check_next_resource_name;
	jb resource_name_found;
	add( 2, ecx );
	mov( [esi+ecx], ax );
	or( [edx+ecx], ax );
	jnz compare_with_current_resource_name;
	jmp same_resource_name;
  resource_name_found:
	mov( esi, edx );
  same_resource_name:
	mov( [esp], eax );
	mov( edi, [eax+8] );
  check_next_resource_name:
	pop( esi );
	mov( [esi+16], eax );
	lea( esi, [esi+eax+20] );
	jmp find_resource_name;
  resource_name_ok:
	or( edx, edx );
	jz resource_name_directory_done;
	mov( edx, ebx );
  make_resource_name_entry:
	mov( [esp], eax );
	inc( (type word [eax+12]) );
	lea( eax, [edi+8] );
	out_of_mem( ae, eax, display_buffer );
	mov( ebx, eax );
	stosd;
	xor( eax, eax );
	stosd;
	jmp make_resource_name_directory;
  resource_name_directory_done:
	mov( -1, ebx );
  make_resource_id_directory:
	mov( free_additional_memory, esi );
	mov( $10000, edx );
  find_resource_id:
	cmp( (type dword [esi]), 0 );
	je resource_id_ok;
	push( esi );
	cmp( [esi+4], ebp );
	jne check_next_resource_id;
	add( 20, esi );
	call skip_resource_name;
	cmp( (type word [esi]), $0FFFF );
	jne check_next_resource_id;
	movzx( (type word [esi+2]), eax );
	cmp( eax, ebx );
	jle check_next_resource_id;
	cmp( eax, edx );
	jg check_next_resource_id;
	mov( eax, edx );
	mov( [esp], eax );
	mov( edi, [eax+8] );
  check_next_resource_id:
	pop( esi );
	mov( [esi+16], eax );
	lea( esi, [esi+eax+20] );
	jmp find_resource_id;
  resource_id_ok:
	cmp( edx, $10000 );
	je resource_id_directory_done;
	mov( edx, ebx );
  make_resource_id_entry:
	mov( [esp], eax );
	inc( (type word [eax+14]) );
	lea( eax, [edi+8] );
	out_of_mem( ae, eax, display_buffer );
	mov( ebx, eax );
	stosd;
	xor( eax, eax );
	stosd;
	jmp make_resource_id_directory;
  resource_id_directory_done:
	pop( eax );
	mov( ebp, esi );
	pop( ecx );
	add( 8, esi );
	dec( cx );
	jnz make_resource_directories;
  resource_directories_ok:
	shr( 16, ecx );
	jnz make_resource_directories;
	mov( resource_data, esi );
	add( $10, esi );
	movzx( (type word [esi-4]), eax );
	movzx( (type word [esi-2]), edx );
	add( edx, eax );
	lea( esi, [esi+eax*8] );
	push( edi );
  update_resource_directories:
	cmp( esi, [esp] );
	je resource_directories_updated;
	add( $10, esi );
	mov( [esi-4], ecx );
	or( cx, cx );
	jz language_directories_ok;
  make_language_directories:
	push( ecx );
	push( edi );
	mov( edi, edx );
	sub( resource_data, edx );
	bts( 31, edx );
	mov( edx, [esi+4] );
	lea( eax, [edi+16] );
	out_of_mem( ae, eax, display_buffer );
	xor( eax, eax );
	stosd;
	call make_timestamp;
	stosd;
	xor( eax, eax );
	stosd;
	stosd;
	mov( esi, ebp );
	mov( -1, ebx );
  make_language_id_directory:
	mov( free_additional_memory, esi );
	mov( $10000, edx );
  find_language_id:
	cmp( (type dword [esi]), 0 );
	je language_id_ok;
	push( esi );
	cmp( [esi+8], ebp );
	jne check_next_language_id;
	add( 20, esi );
	mov( esi, eax );
	call skip_resource_name;
	call skip_resource_name;
	neg( eax );
	add( esi, eax );
	and( %11, eax );
	add( eax, esi );
  get_language_id:
	movzx( (type word [esi+6]), eax );
	cmp( eax, ebx );
	jle check_next_language_id;
	cmp( eax, edx );
	jge check_next_language_id;
	mov( eax, edx );
	mov( [esp], eax );
	mov( eax, current_offset );
  check_next_language_id:
	pop( esi );
	mov( [esi+16], eax );
	lea( esi, [esi+eax+20] );
	jmp find_language_id;
  language_id_ok:
	cmp( edx, $10000 );
	je language_id_directory_done;
	mov( edx, ebx );
  make_language_id_entry:
	mov( [esp], eax );
	inc( (type word [eax+14]) );
	lea( eax, [edi+8] );
	out_of_mem( ae, eax, display_buffer );
	mov( ebx, eax );
	stosd;
	mov( current_offset, eax );
	stosd;
	jmp make_language_id_directory;
  language_id_directory_done:
	pop( eax );
	mov( ebp, esi );
	pop( ecx );
	add( 8, esi );
	dec( cx );
	jnz make_language_directories;
  language_directories_ok:
	shr( 16, ecx );
	jnz make_language_directories;
	jmp update_resource_directories;
  resource_directories_updated:
	mov( resource_data, esi );
	push( edi );
  make_name_strings:
	add( $10, esi );
	movzx( (type word [esi-2]), eax );
	movzx( (type word [esi-4]), ecx );
	add( ecx, eax );
	lea( eax, [esi+eax*8] );
	push( eax );
	or( ecx, ecx );
	jz string_entries_processed;
  process_string_entries:
	push( ecx );
	mov( edi, edx );
	sub( resource_data, edx );
	bts( 31, edx );
	xchg( edx, [esi] );
	mov( edi, ebx );
	xor( ax, ax );
	stosw;
  copy_string_data:
	lea( eax, [edi+2] );
	out_of_mem( ae, eax, display_buffer );
	mov( [edx], ax );
	or( ax, ax );
	jz string_data_copied;
	stosw;
	inc( (type word [ebx]) );
	add( 2, edx );
	jmp copy_string_data;
  string_data_copied:
	add( 8, esi );
	pop( ecx );
	dec( ecx );
	jnz process_string_entries;
  string_entries_processed:
	pop( esi );
	cmp( esi, [esp] );
	jb make_name_strings;
	mov( edi, eax );
	sub( resource_data, eax );
	test( %11, al );
	jz resource_strings_alignment_ok;
	xor( ax, ax );
	stosw;
  resource_strings_alignment_ok:
	pop( edx );
	pop( ebx );
	mov( edi, ebp );
  update_language_directories:
	add( $10, ebx );
	movzx( (type word [ebx-2]), eax );
	movzx( (type word [ebx-4]), ecx );
	add( eax, ecx );
  make_data_records:
	push( ecx );
	mov( edi, esi );
	sub( resource_data, esi );
	xchg( [ebx+4], esi );
	lea( eax, [edi+16] );
	out_of_mem( ae, eax, display_buffer );
	mov( esi, eax );
	stosd;
	mov( [esi+12], eax );
	stosd;
	xor( eax, eax );
	stosd;
	stosd;
	pop( ecx );
	add( 8, ebx );
	loop make_data_records;
	cmp( ebx, edx );
	jb update_language_directories;
	pop( ebx );
	mov( ebp, esi );
	mov( edi, ebp );
  update_data_records:
	push( ebp );
	mov( edi, ecx );
	mov( current_section, eax );
	sub( [eax+$14], ecx );
	add( [eax+$0C], ecx );
	xchg( [esi], ecx );
	mov( [ecx], edx );
	seek( ebx, edx );
	mov( edi, edx );
	mov( [esi+4], ecx );
	add( ecx, edi );
	out_of_mem( a, edi, display_buffer );
	read( ebx, edx, ecx );
	mov( edi, eax );
	sub( resource_data, eax );
	and( %11, eax );
	jz resource_data_alignment_ok;
	mov( 4, ecx );
	sub( eax, ecx );
	xor( al, al );
	rep.stosb;
  resource_data_alignment_ok:
	pop( ebp );
	add( 16, esi );
	cmp( esi, ebp );
	jb update_data_records;
	pop( esi );
	close( ebx );
	mov( edi, eax );
	sub( resource_data, eax );
	mov( eax, resource_size );
  resource_done:
	ret();

  make_pe_fixups:
	push( esi );
	mov( number_of_relocations, ecx );
	mov( free_additional_memory, esi );
	mov( ecx, eax );
	shl( 2, eax );
	sub( eax, esi );
	mov( esi, free_additional_memory );
	or( -1, number_of_relocations );
	xor( edx, edx );
	mov( edi, ebp );
  make_fixups:
	cmp( [esi], edx );
	jb store_fixup;
	mov( edi, eax );
	sub( ebp, eax );
	test( %11, eax );
	jz fixups_block;
	xor( ax, ax );
	stosw;
	add( 2, (type dword [ebx]) );
  fixups_block:
	mov( edx, eax );
	add( $1000, edx );
	cmp( [esi], edx );
	jae fixups_block;
	stosd;
	mov( edi, ebx );
	mov( 8, eax );
	stosd;
  store_fixup:
	jecxz fixups_done;
	add( 2, (type dword [ebx]) );
	mov( [esi], eax );
	and( $0FFF, ax );
	test( 8, format_flags );
	jnz fixup_64bit;
	or( $3000, ax );
	jmp fixup_ok;
  fixup_64bit:
	or( $0A000, ax );
  fixup_ok:
	stosw;
	add( 4, esi );
	dec( ecx );
	jnz make_fixups;
  fixups_done:
	pop( esi );
	ret();
	
end generate_pe_data;



proc( write_mz_header );

	mov( additional_memory, edx );
	bt( 4, format_flags );
	jc mz_stack_ok;
	mov( real_code_size, eax );
	dec( eax );
	shr( 4, eax );
	inc( eax );
	mov( ax, [edx+$0E] );
	shl( 4, eax );
	movzx( (type word [edx+$10]), ecx );
	add( ecx, eax );
	mov( eax, real_code_size );
  mz_stack_ok:
	mov( free_additional_memory, edi );
	mov( number_of_relocations, eax );
	shl( 2, eax );
	add( $1C, eax );
	sub( eax, edi );
	xchg( free_additional_memory, edi );
	mov( $0F, ecx );
	add( $0F, eax );
	and( %1111, eax );
	sub( eax, ecx );
	xor( al, al );
	rep.stosb;
	sub( free_additional_memory, edi );
	mov( edi, ecx );
	shr( 4, edi );
	mov( asWord( "MZ" ), (type word [edx]) );
	mov( di, [edx+8] );
	mov( number_of_relocations, eax );
	mov( ax, [edx+6] );
	mov( code_size, eax );
	add( ecx, eax );
	mov( eax, esi );
	shr( 9, esi );
	and( $1FF, eax );
	inc( si );
	or( ax, ax );
	jnz mz_size_ok;
	mov( $200, ax );
	dec( si );
  mz_size_ok:
	mov( ax, [edx+2] );
	mov( si, [edx+4] );
	mov( real_code_size, eax );
	dec( eax );
	shr( 4, eax );
	inc( eax );
	mov( code_size, esi );
	dec( esi );
	shr( 4, esi );
	inc( esi );
	sub( esi, eax );
	mov( ax, [edx+$0A] );
	add( ax, [edx+$0C] );
	//salc;
	if( @c ) then
	
		mov( $ff, al );
		
	else
	
		mov( 0, al );
		
	endif;
	mov( al, ah );
	or( ax, [edx+$0C] );
	mov( $1C, (type word [edx+$18]) );
	add( ecx, written_size );
	write( ebx, edx, ecx );
	ret();
	
end write_mz_header;


proc( find_structure_data );

	mov( structures_buffer, ebx );
  scan_structures:
	cmp( ebx, additional_memory_end );
	je no_such_structure;
	cmp( ax, [ebx] );
	je structure_data_found;
	add( $20, ebx );
	jmp scan_structures;
  structure_data_found:
	ret();

  no_such_structure:
	stc;
	ret();
	
end find_structure_data;



proc( remove_structure_data );

	push( esi );
	push( edi );
	mov( structures_buffer, esi );
	mov( ebx, ecx );
	sub( esi, ecx );
	lea( edi, [esi+$20] );
	mov( edi, structures_buffer );
	shr( 2, ecx );
	rep.movsd;
	pop( edi );
	pop( esi );
	ret();
	
end remove_structure_data;



proc( find_end_repeat );

	call find_structure_end;
	cmp( ax, repeat_directive_assembler );
	jne unexpected_instruction;
	ret();
	
end find_end_repeat;


proc( find_end_while );

	call find_structure_end;
	cmp( ax, while_directive_assembler );
	jne unexpected_instruction;
	ret();
	
end find_end_while;


proc( find_else );

	call find_structure_end;
	cmp( ax, else_directive_assembler );
	je else_found;
	cmp( ax, if_directive_assembler );
	jne unexpected_instruction;
	stc;
	ret();

  else_found:
	clc;
	ret();
	
end find_else;


proc( find_end_if );

	call find_structure_end;
	cmp( ax, if_directive_assembler );
	jne unexpected_instruction;
	ret();
	
end find_end_if;



proc( skip_line );

  skipLine:
	call skip_symbol;
	jnc skipLine;
	ret();
	
end skip_line;


proc( skip_if_block );

	call find_else;
	jc if_block_skipped;
	cmp( (type byte [esi]), 1 );
	jne skip_after_else;
	mov( (type word [esi+1]), ax );
	cmp( ax, if_directive_assembler );
	jne skip_after_else;
	add( 4, esi );
	jmp skip_if_block;
  skip_after_else:
	call find_end_if;
  if_block_skipped:
	ret();
	
end skip_if_block;


proc( find_structure_end );

	push( error_line );
	mov( current_line, eax );
	mov( eax, error_line );
  find_end_directive:
	call skip_line;
	lodsb;
	cmp( al, $0F );
	jne no_end_directive;
	lodsd;
	mov( eax, current_line );
  skip_labels:
	cmp( (type byte [esi]), 2 );
	jne labels_ok;
	add( 6, esi );
	jmp skip_labels;
  labels_ok:
	cmp( (type byte [esi]), 1 );
	jne find_end_directive;
	mov( [esi+1], ax );
	cmp( ax, prefix_instruction_assembler );
	je find_end_directive;
	add( 4, esi );
	cmp( ax, repeat_directive_assembler );
	je skip_repeat;
	cmp( ax, while_directive_assembler );
	je skip_while;
	cmp( ax, if_directive_assembler );
	je skip_if;
	cmp( ax, else_directive_assembler );
	je structure_end;
	cmp( ax, end_directive_assembler );
	jne find_end_directive;
	cmp( (type byte [esi]), 1 );
	jne find_end_directive;
	mov( [esi+1], ax );
	add( 4, esi );
	cmp( ax, repeat_directive_assembler );
	je structure_end;
	cmp( ax, while_directive_assembler );
	je structure_end;
	cmp( ax, if_directive_assembler );
	jne find_end_directive;
  structure_end:
	pop( error_line );
	ret();

  no_end_directive:
	mov( error_line, eax );
	mov( eax, current_line );
	jmp missing_end_directive;
  skip_repeat:
	call find_end_repeat;
	jmp find_end_directive;
  skip_while:
	call find_end_while;
	jmp find_end_directive;
  skip_if:
	call skip_if_block;
	jmp find_end_directive;
	
end find_structure_end;



// Note the @frame option!

iterator define_data;
	@frame;
	
begin define_data;

  defineData:
	out_of_mem( ae, edi, display_buffer );
	
	cmp( (type byte [esi]), '(' );
	jne simple_data_value;
	
	mov( esi, ebx );
	inc( esi );
	call skip_expression;
	xchg( ebx, esi );
	cmp( (type byte [ebx]), $81 );
	jne simple_data_value;
	
	inc( esi );
	call get_dword_value;
	cmp( next_pass_needed, 0 );
	jne dup_value_ok;
	
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
  dup_value_ok:
	inc( esi );
	cmp( eax, 0 );
	jg dup_positive;
	
	cmp( error_line, 0 );
	jne dup_invalid;
	
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_value, error );
	
  dup_invalid:
	mov( 1, eax );
	
  dup_positive:
	cmp( (type byte [esi]), '{' );
	jne duplicate_single_data_value;
	
	inc( esi );
  duplicate_data:
	push( eax );
	push( esi );
	
  duplicated_values:
	out_of_mem( ae, edi, display_buffer );
	
	yield();			//call( (type dword [esp+8]) );
	lodsb;
	cmp( al, ',' );
	je duplicated_values;
	
	cmp( al, '}' );
	jne invalid_argument;
	
	pop( ebx );
	pop( eax );
	dec( eax );
	jz data_defined;
	
	mov( ebx, esi );
	jmp duplicate_data;
	
  duplicate_single_data_value:
	out_of_mem( ae, edi, display_buffer );
	
	push( eax );
	push( esi );
	yield();			//call( (type dword [esp+8]) );
	pop( ebx );
	pop( eax );
	dec( eax );
	jz data_defined;
	
	mov( ebx, esi );
	jmp duplicate_single_data_value;
	
  simple_data_value:
	out_of_mem( ae, edi, display_buffer );
	
	yield();			//call( (type dword [esp]) );
	
  data_defined:
	lodsb;
	cmp( al, ',' );
	je defineData;
	
	dec( esi );
	
	// Falls through to get_bytes	
	
end define_data;	
	


procedure get_data_bytes; 
begin get_data_bytes;

	foreach define_data() do
	
		lodsb;
		if( al <> '(' ) then
			
			cmp( al, '?' );
			jne invalid_argument;
			
			mov( edi, eax );
			mov( 0, (type byte [edi]) );
			inc( edi );
			undefined_data( eax, edi );
			
		elseif( (type byte [esi]) <> 0 ) then
			
			call get_byte_value;
			stosb;

		else

			inc( esi );
			lodsd;
			mov( eax, ecx );
			lea( eax, [edi+ecx] );
			out_of_mem( a, eax, display_buffer );
		
			rep.movsb;
			inc( esi );
			
		endif;
		
	endfor;
	ret();
	
end get_data_bytes;



proc( get_data_words );

	foreach define_data() do
	
		lodsb;
		if( al <> '(' ) then
		
			cmp( al, '?' );
			jne invalid_argument;
			
			mov( edi, eax );
			mov( 0, (type word [edi]) );
			add( 2, edi );
			undefined_data( eax, edi );
			
		elseif( base_code = 0 || (type byte [esi]) <> 0 ) then
		
			call get_word_value;
			call mark_relocation;
			stosw;
				
		 else

			inc( esi );
			lodsd;
			mov( eax, ecx );
			jecxz word_string_ok;
			
				lea( eax, [edi+ecx*2] );
				out_of_mem( a, eax, display_buffer );
				
				xor( ah, ah );
				copy_word_string:
					lodsb;
					stosw;
				loop copy_word_string;
			
		  word_string_ok:
			inc( esi );
			
		endif;
		
	endfor;
	ret();
	
end get_data_words;



proc( get_data_dwords );

	foreach define_data() do
	
		lodsb;
		if( al <> '(' ) then
		
			cmp( al, '?' );
			jne invalid_argument;
			mov( edi, eax );
			mov( 0, (type dword [edi]) );
			add( 4, edi );
			undefined_data( eax, edi );
		
		else
		
			push( esi );
			call get_dword_value;
			pop( ebx );
			if( (type byte [esi]) <> ':' ) then
			
				call mark_relocation;
				stosd;
				
			else

				mov( ebx, esi );
				cmp( (type byte [esi]), '.' );
				je invalid_value;
				
				call get_word_value;
				push( eax );
				inc( esi );
				lodsb;
				cmp( al, '(' );
				jne invalid_operand;
				
				mov( value_type, al );
				push( eax );
				cmp( (type byte [esi]), '.' );
				je invalid_value;
				
				call get_word_value;
				call mark_relocation;
				stosw;
				pop( eax );
				mov( al, value_type );
				pop( eax );
				call mark_relocation;
				stosw;
				
			endif;
			
		endif;
		
	endfor;
	ret();

end get_data_dwords;



proc( get_data_pwords );

	foreach define_data() do
	
		lodsb;
		if( al <> '(' ) then
		
			cmp( al, '?' );
			jne invalid_argument;
			mov( edi, eax );
			mov( 0, (type dword [edi]) );
			mov( 0, (type word [edi+4]) );
			add( 6, edi );
			undefined_data( eax, edi );
			
		else
		
			push( esi );
			call get_pword_value;
			pop( ebx );
			if( (type byte [esi]) <> ':' ) then
			
				call mark_relocation;
				stosd;
				mov( dx, ax );
				stosw;
				
			else
			
				mov( ebx, esi );
				cmp( (type byte [esi]), '.' );
				je invalid_value;
				call get_word_value;
				push( eax );
				inc( esi );
				lodsb;
				cmp( al, '(' );
				jne invalid_operand;
				mov( value_type, al );
				push( eax );
				cmp( (type byte [esi]), '.' );
				je invalid_value;
				call get_dword_value;
				call mark_relocation;
				stosd;
				pop( eax );
				mov( al, value_type );
				pop( eax );
				call mark_relocation;
				stosw;
				
			endif;
			
		endif;
		
	endfor;
	ret();

end get_data_pwords;




proc( get_data_qwords );

	foreach define_data() do
	
		lodsb;
		if( al <> '(' ) then
		
			cmp( al, '?' );
			jne invalid_argument;
			mov( edi, eax );
			mov( 0, (type dword [edi]) );
			mov( 0, (type dword [edi+4]) );
			add(8, edi );
			undefined_data( eax, edi );

			
		else
		
			call get_qword_value;
			call mark_relocation;
			stosd;
			mov( edx, eax );
			stosd;
			
		endif;
		
	endfor;
	ret();

end get_data_qwords;


proc( get_data_twords );

	foreach define_data() do
	
		lodsb;
		if( al <> '(' ) then
		
			cmp( al, '?' );
			jne invalid_argument;
			mov( edi, eax );
			mov( 0, (type dword [edi]) );
			mov( 0, (type dword [edi+4]) );
			mov( 0, (type word [edi+8]) );
			add( 10, edi );
			undefined_data( eax, edi );
			
		elseif( (type byte [esi]) = '.' ) then
		
			inc( esi );
			if( (type word [esi+8]) <> $8000 ) then
			
				mov( [esi], eax );
				stosd;
				mov( [esi+4], eax );
				stosd;
				mov( [esi+8], ax );
				add( $3FFF, ax );
				cmp( ax, $8000 );
				jae value_out_of_range;
				mov( [esi+11], bl );
				shl( 15, bx );
				or( bx, ax );
				stosw;
				add( 13, esi );

		  	else
			
				xor( eax, eax );
				stosd;
				stosd;
				mov( [esi+11], al );
				shl( 15, ax );
				stosw;
				add( 13, esi );
				
			endif;
			
		else

			call get_word_value;
			push( eax );
			inc( esi );
			lodsb;
			cmp( al, '(' );
			jne invalid_operand;
			mov( value_type, al );
			push( eax );
			cmp( (type byte [esi]), '.' );
			je invalid_value;
			call get_qword_value;
			call mark_relocation;
			stosd;
			mov( edx, eax );
			stosd;
			pop( eax );
			mov( al, value_type );
			pop( eax );
			call mark_relocation;
			stosw;
			
		endif;
		
	endfor;
	ret();

end get_data_twords;


proc( store_segment_prefix_if_necessary );

	mov( segment_register, al );
	or( al, al );
	jz segment_prefix_ok;
	cmp( al, 3 );
	je ss_prefix;
	cmp( al, 4 );
	ja segment_prefix_386;
	jb segment_prefix_86;
	cmp( bl, $25 );
	je segment_prefix_86;
	cmp( bh, $25 );
	je segment_prefix_86;
	cmp( bh, $45 );
	je segment_prefix_86;
	cmp( bh, $44 );
	je segment_prefix_86;
	ret();

  ss_prefix:
	cmp( bl, $25 );
	je segment_prefix_ok;
	cmp( bh, $25 );
	je segment_prefix_ok;
	cmp( bh, $45 );
	je segment_prefix_ok;
	cmp( bh, $44 );
	je segment_prefix_ok;
	
  segment_prefix_86:
	dec( al );
	shl( 3, al );
	add( $26, al );
	stosb;
	jmp segment_prefix_ok;
	
  segment_prefix_386:
	add( $64-5, al );
	stosb;
  segment_prefix_ok:
	ret();

end store_segment_prefix_if_necessary;



proc( store_segment_prefix );

	mov( segment_register, al );
	or( al, al );
	jz segment_prefix_ok;
	cmp( al, 5 );
	jae segment_prefix_386;
	
  segment_prefix_86:
	dec( al );
	shl( 3, al );
	add( $26, al );
	stosb;
	jmp segment_prefix_ok;
	
  segment_prefix_386:
	add( $64-5, al );
	stosb;
	
  segment_prefix_ok:
	ret();
	
end store_segment_prefix;



proc( operand_16bit );

	cmp( code_type, 16 );
	je size_prefix_ok;
	mov( $66, operand_prefix );
  size_prefix_ok:
	ret();
	
end operand_16bit;


proc( operand_32bit );

	cmp( code_type, 16 );
	jne size_prefix_ok;
	mov( $66, operand_prefix );
  size_prefix_ok:
	ret();

end operand_32bit;


proc( operand_64bit );

	cmp( code_type, 64 );
	jne illegal_instruction;
	or( $48, rex_prefix );
	ret();
	
end operand_64bit;


proc( operand_autodetect );

	cmp( al, 2 );
	je operand16bit;
	cmp( al, 4 );
	je operand32bit;
	cmp( al, 8 );
	je operand64bit;
	raise( aerr.illegal_instruction );
	
  operand16bit:
  	jmp operand_16bit;
	
  operand32bit:
  	jmp operand_32bit;
	
  operand64bit:
  	jmp operand_64bit;

end operand_autodetect;


proc( address_16bit_prefix );

	cmp( code_type, 16 );
	je instruction_prefix_ok;
	mov( $67, al );
	stosb;
  instruction_prefix_ok:
	ret();
	
end address_16bit_prefix;


proc( address_32bit_prefix );

	cmp( code_type, 32 );
	je instruction_prefix_ok;
	mov( $67, al );
	stosb;
  instruction_prefix_ok:
	ret();
	
end address_32bit_prefix;





proc( store_instruction_code );

	mov( operand_prefix, al );
	or( al, al );
	jz operand_prefix_ok;
	stosb;
	
  operand_prefix_ok:
	mov( rex_prefix, al );
	test( $40, al );
	jz rex_prefix_ok;
	
	cmp( code_type, 64 );
	jne invalid_operand;
	
	test( $0B0, al );
	jnz prefix_conflict;
	stosb;
	
  rex_prefix_ok:
	mov( base_code, al );
	stosb;
	cmp( al, $0F );
	jne instruction_code_ok;
	
  store_extended_code:
	mov( extended_code, al );
	stosb;
	
  instruction_code_ok:
	ret();

end store_instruction_code;


proc( store_address_32bit_value );

	test( $0F0, ch );
	jz address_32bit_relocation_ok;
	mov( 2, al );
	xchg( al, value_type );
	mov( address_symbol, ebx );
	xchg( symbol_identifier, ebx );
	call mark_relocation;
	mov( al, value_type );
	mov( ebx, symbol_identifier );
  address_32bit_relocation_ok:
	mov( edx, eax );
	stosd;
	ret();

end store_address_32bit_value;

proc( store_address_64bit_value );

	test( $0F0, ch );
	jz address_64bit_relocation_ok;
	mov( 4, al );
	xchg( al, value_type );
	mov( address_symbol, ebx );
	xchg( symbol_identifier, ebx );
	call mark_relocation;
	mov( al, value_type );
	mov( ebx, symbol_identifier );
  address_64bit_relocation_ok:
	mov( edx, eax );
	stosd;
	mov( address_high, eax );
	stosd;
	ret();
	
end store_address_64bit_value;



proc( store_instruction );

	mov( edi, current_offset );
	test( %1000, postbyte_register );
	jz reg_code_ok;
	or( $44, rex_prefix );
	and( %111, postbyte_register );
	
  reg_code_ok:
	call store_segment_prefix_if_necessary;
	or( bx, bx );
	jz address_immediate;
	
	cmp( bx, $0F000 );
	je address_rip_based;
	
	cmp( bx, $0FF00 );
	je address_relative;
	
	mov( bl, al );
	or( bh, al );
	and( %11110000, al );
	cmp( al, $80 );
	je postbyte_64bit;
	
	cmp( al, $40 );
	je postbyte_32bit;
	
	cmp( al, $20 );
	jne invalid_address;
	
	cmp( code_type, 64 );
	je invalid_address_size;
	
	call address_16bit_prefix;
	call store_instruction_code;
	
	cmp( bx, $2326 );
	je address_bx_si;
	cmp( bx, $2623 );
	je address_bx_si;
	cmp( bx, $2327 );
	je address_bx_di;
	cmp( bx, $2723 );
	je address_bx_di;
	cmp( bx, $2526 );
	je address_bp_si;
	cmp( bx, $2625 );
	je address_bp_si;
	cmp( bx, $2527 );
	je address_bp_di;
	cmp( bx, $2725 );
	je address_bp_di;
	cmp( bx, $2600 );
	je address_si;
	cmp( bx, $2700 );
	je address_di;
	cmp( bx, $2300 );
	je address_bx;
	cmp( bx, $2500 );
	je address_bp;
	jmp invalid_address;
	
  address_bx_si:
	xor( al, al );
	jmp postbyte_16bit;
	
  address_bx_di:
	mov( 1, al );
	jmp postbyte_16bit;
	
  address_bp_si:
	mov( %10, al );
	jmp postbyte_16bit;
	
  address_bp_di:
	mov( %11, al );
	jmp postbyte_16bit;
	
  address_si:
	mov( %100, al );
	jmp postbyte_16bit;
	
  address_di:
	mov( %101, al );
	jmp postbyte_16bit;
	
  address_bx:
	mov( %111, al );
	jmp postbyte_16bit;
	
  address_bp:
	mov( %110, al );
  postbyte_16bit:
	test( $22, ch );
	jnz address_16bit_value;
	
	or( ch, ch );
	jnz address_sizes_do_not_agree;
	
	cmp( edx, $10000 );
	jge value_out_of_range;
	
	cmp( edx, -$8000 );
	jl value_out_of_range;
	
	or( dx, dx );
	jz address;
	
	cmp( dx, $80 );
	jb address_8bit_value;
	
	cmp( dx, _word(-$80) );
	jae address_8bit_value;
	
  address_16bit_value:
	or( %10000000, al );
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosb;
	mov( edx, eax );
	stosw;
	ret();

  address_8bit_value:
	or( %01000000, al );
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosb;
	mov( dl, al );
	stosb;
	cmp( dx, $80 );
	jge value_out_of_range;
	cmp( dx, _word(-$80) );
	jl value_out_of_range;
	ret();

  address:
	cmp( al, %110 );
	je address_8bit_value;
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosb;
	ret();

  postbyte_32bit:
	call address_32bit_prefix;
	jmp address_prefix_ok;
	
  postbyte_64bit:
	cmp( code_type, 64 );
	jne invalid_address_size;
	
  address_prefix_ok:
	test( %1000, bh );
	jz base_code_ok;
	or( $41, rex_prefix );
	
  base_code_ok:
	test( %1000, bl );
	jz index_code_ok;
	or( $42, rex_prefix );
	
  index_code_ok:
	call store_instruction_code;
	cmp( bl, $44 );
	je invalid_address;
	cmp( bl, $84 );
	je invalid_address;
	or( cl, cl );
	jz only_base_register;
	
  base_and_index:
	mov( %100, al );
	xor( ah, ah );
	cmp( cl, 1 );
	je scale_ok;
	cmp( cl, 2 );
	je scale_1;
	cmp( cl, 4 );
	je scale_2;
	or( %11000000, ah );
	jmp scale_ok;
	
  scale_2:
	or( %10000000, ah );
	jmp scale_ok;
	
  scale_1:
	or( %01000000, ah );
	
  scale_ok:
	or( bh, bh );
	jz only_index_register;
	
	and( %111, bl );
	shl( 3, bl );
	or( bl, ah );
	and( %111, bh );
	or( bh, ah );
	test( $44, ch );
	jnz sib_address_32bit_value;
	
	or( ch, ch );
	jnz address_sizes_do_not_agree;
	
	cmp( bh, 5 );
	je address_value;
	
	or( edx, edx );
	jz sib_address;
	
  address_value:
	cmp( edx, $80 );
	jb sib_address_8bit_value;
	
	cmp( edx, -$80 );
	jae sib_address_8bit_value;
	
  sib_address_32bit_value:
	or( %10000000, al );
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosw;
	jmp store_address_32bit_value;
	
  sib_address_8bit_value:
	or( %01000000, al );
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosw;
	mov( dl, al );
	stosb;
	cmp( edx, $80 );
	jge value_out_of_range;
	
	cmp( edx, -$80 );
	jl value_out_of_range;
	ret();

  sib_address:
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosw;
	ret();

  only_index_register:
	or( %101, ah );
	and( %111, bl );
	shl( 3, bl );
	or( bl, ah );
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosw;
	test( $44, ch );
	jnz store_address_32bit_value;
	
	or( ch, ch );
	jnz invalid_address_size;
	jmp store_address_32bit_value;
	
  zero_index_register:
	mov( 4, bl );
	mov( 1, cl );
	jmp base_and_index;
	
  only_base_register:
	mov( bh, al );
	and( %111, al );
	cmp( al, 4 );
	je zero_index_register;
	
	test( $44, ch );
	jnz simple_address_32bit_value;
	
	or( ch, ch );
	jnz address_sizes_do_not_agree;
	
	or( edx, edx );
	jz simple_address;
	
	cmp( edx, $80 );
	jb simple_address_8bit_value;
	
	cmp( edx, -$80 );
	jae simple_address_8bit_value;
	
  simple_address_32bit_value:
	or( %10000000, al );
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosb;
	jmp store_address_32bit_value;
	
  simple_address_8bit_value:
	or( %01000000, al );
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosb;
	mov( dl, al );
	stosb;
	cmp( edx, $80 );
	jge value_out_of_range;
	
	cmp( edx, -$80 );
	jl value_out_of_range;
	ret();

  simple_address:
	cmp( al, 5 );
	je simple_address_8bit_value;
	
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosb;
	ret();

  address_immediate:
	cmp( code_type, 64 );
	je address_immediate_sib;
	
	test( $44, ch );
	jnz address_immediate_32bit;
	
	test( $22, ch );
	jnz address_immediate_16bit;
	
	or( ch, ch );
	jnz invalid_address_size;
	
	cmp( code_type, 16 );
	je addressing_16bit;
	
  address_immediate_32bit:
	call address_32bit_prefix;
	call store_instruction_code;
	
  store_immediate_address:
	mov( %101, al );
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosb;
	jmp store_address_32bit_value;


  address_immediate_sib:
	test( _byte( !$44 ), ch );
	jnz invalid_address_size;
	call address_32bit_prefix;
	call store_instruction_code;
	mov( %100, al );
	mov( %100101, ah );
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosw;
	jmp store_address_32bit_value;
	
  address_rip_based:
	cmp( code_type, 64 );
	jne invalid_address;
	
	call store_instruction_code;
	jmp store_immediate_address;
	
  address_relative:
	call store_instruction_code;
	movzx( immediate_size, eax );
	add( edi, eax );
	sub( current_offset, eax );
	add( 5, eax );
	sub( eax, edx );
	jo value_out_of_range;
	
	mov( %101, al );
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosb;
	xchg( ch, value_type );
	mov( address_symbol, ebx );
	xchg( symbol_identifier, ebx );
	mov( edx, eax );
	call mark_relocation;
	mov( ch, value_type );
	mov( ebx, symbol_identifier );
	stosd;
	ret();

  addressing_16bit:
	cmp( edx, $10000 );
	jge address_immediate_32bit;
	
	cmp( edx, -$8000 );
	jl address_immediate_32bit;
	
	movzx( dx, edx );
  address_immediate_16bit:
	call address_16bit_prefix;
	call store_instruction_code;
	mov( %110, al );
	mov( postbyte_register, cl );
	shl( 3, cl );
	or( cl, al );
	stosb;
	mov( edx, eax );
	stosw;
	cmp( edx, $10000 );
	jge value_out_of_range;
	
	cmp( edx, -$8000 );
	jl value_out_of_range;
	ret();
	
end store_instruction;


proc( store_instruction_with_imm8 );

	mov( 1, immediate_size );
	call store_instruction;
	mov( (type byte value), al );
	stosb;
	ret();
	
end store_instruction_with_imm8;


proc( store_instruction_with_imm16 );

	mov( 2, immediate_size );
	call store_instruction;
	mov( (type word value), ax );
	call mark_relocation;
	stosw;
	ret();
	
end store_instruction_with_imm16;


proc( store_instruction_with_imm32 );

	mov( 4, immediate_size );
	call store_instruction;
	mov( (type dword value), eax );
	call mark_relocation;
	stosd;
	ret();
	
end store_instruction_with_imm32;

	
proc( get_simm32 );

	call get_qword_value;
	mov( edx, ecx );
	cdq;
	cmp( ecx, edx );
	jne value_out_of_range;
	ret();
	
end get_simm32;




proc( store_nomem_instruction );

	test( %1000, postbyte_register );
	jz nomem_reg_code_ok;
	or( $44, rex_prefix );
	and( %111, postbyte_register );
  nomem_reg_code_ok:
	test( %1000, bl );
	jz nomem_rm_code_ok;
	or( $41, rex_prefix );
	and( %111, bl );
  nomem_rm_code_ok:
	call store_instruction_code;
	mov( postbyte_register, al );
	shl( 3, al );
	or( bl, al );
	or( %11000000, al );
	stosb;
	ret();
	
end store_nomem_instruction;


	
	
proc( calculate_relative_address );

	call calculate_relative_offset;
	cmp( (type byte [esi-1]), ']' );
	jne invalid_address;
	mov( edx, address_high );
	mov( symbol_identifier, edx );
	mov( edx, address_symbol );
	mov( eax, edx );
	mov( value_type, ch );
	mov( $0FF00, bx );
	xor( cl, cl );
  address_ok:
	ret();
	
end calculate_relative_address;



proc( get_address );

	mov( 0, segment_register );
	mov( 0, address_size );
	mov( code_type, al );
	shr( 3, al );
	mov( al, value_size );
	mov( [esi], al );
	and( %11110000, al );
	cmp( al, $60 );
	jne get_size_prefix;
	lodsb;
	sub( $60, al );
	mov( al, segment_register );
	mov( [esi], al );
	and( %11110000, al );
  get_size_prefix:
	cmp( al, $70 );
	jne address_size_prefix_ok;
	lodsb;
	sub( $70, al );
	cmp( al, 2 );
	jb invalid_address_size;
	cmp( al, 8 );
	ja invalid_address_size;
	mov( al, address_size );
	mov( al, value_size );
  address_size_prefix_ok:
	call calculate_address;
	cmp( (type byte [esi-1]), ']' );
	jne invalid_address;
	mov( edx, address_high );
	mov( eax, edx );
	cmp( code_type, 64 );
	jne address_ok;
	or( bx, bx );
	jnz address_ok;
	test( $0F, ch );
	jnz address_ok;
	call  calculate_relative_address;
  address_ok:
	ret();

end get_address;



proc( store_mov_reg_imm_code );

	mov( postbyte_register, ah );
	test( %1000, ah );
	jz mov_reg_imm_prefix_ok;
	or( $41, rex_prefix );
  mov_reg_imm_prefix_ok:
	and( %111, ah );
	add( ah, al );
	mov( al, base_code );
	call store_instruction_code;
	ret();
	
end store_mov_reg_imm_code;


proc( calculate_jump_offset );

	cmp( value_undefined, 0 );
	jne jump_offset_ok;
	add( (type dword org_origin), eax );
	adc( (type dword org_origin[4]), edx );
	lea( ebx, [edi+2] );
	sub( ebx, eax );
	sbb( 0, edx );
	mov( value_type, bl );
	or( bl, bl );
	je jump_offset_ok;
	test( 1, bl );
	jnz invalid_use_of_symbol;
	cmp( bl, labels_type );
	jne invalid_use_of_symbol;
	mov( 0, value_type );
	mov( symbol_identifier, ecx );
	cmp( ecx, org_symbol );
	je jump_offset_ok;
	mov( 3, value_type );
  jump_offset_ok:
	ret();
	
end calculate_jump_offset;



proc( check_for_short_jump );

	cmp( jump_type, 1 );
	je forced_short;
	ja no_short_jump;
	cmp( base_code, $0E8 );
	je no_short_jump;
	cmp( value_type, 0 );
	jne no_short_jump;
	cmp( eax, $80 );
	jb short_jump;
	cmp( eax, -$80 );
	jae short_jump;
  no_short_jump:
	clc;
	ret();

  forced_short:
	cmp( base_code, $0E8 );
	je illegal_instruction;
	cmp( next_pass_needed, 0 );
	jne jmp_short_value_type_ok;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
  jmp_short_value_type_ok:
	cmp( eax, -$80 );
	jae short_jump;
	cmp( eax, $80 );
	jae jump_out_of_range;
  short_jump:
  	stc();
    ret();

  jump_out_of_range:
	cmp( error_line, 0 );
	jne instruction_assembled;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &relative_jump_out_of_range, error );
	
  instruction_assembled:
  	mov( [esi], al );
	cmp( al, $f );
	if( @nz ) then
	
	    or( al, al );
	    jnz extra_characters_on_line;
	
  	endif;
    clc;
    ret();
	
	
end check_for_short_jump;



proc( make_mmx_prefix );

	cmp( operand_size, 16 );
	jne no_mmx_prefix;
	mov( $66, operand_prefix );
  no_mmx_prefix:
	ret();
	
end make_mmx_prefix;


proc( get_nextbyte );

	cmp( (type byte value), -1 );
	jne nextbyte_ok;
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	test( _byte( !1 ), operand_size );
	jnz invalid_value;
	cmp( al, '(' );
	jne invalid_operand;
	call get_byte_value;
	cmp( al, 7 );
	ja invalid_value;
	mov( al, (type byte value) );
  nextbyte_ok:
	ret();
	
end get_nextbyte;


proc( match_register_size );

	cmp( ah, operand_size );
	je register_size_ok;
	cmp( operand_size, 0 );
	jne operand_sizes_do_not_match;
	mov( ah, operand_size );
  register_size_ok:
	ret();
	
end match_register_size;



proc( convert_register );

	mov( al, ah );
	shr( 4, ah );
	and( $0F, al );
	cmp( ah, 8 );
	je match_register_size;
	cmp( ah, 4 );
	ja invalid_operand;
	cmp( ah, 1 );
	ja match_register_size;
	cmp( al, 4 );
	jb match_register_size;
	or( ah, ah );
	jz high_byte_register;
	or( $40, rex_prefix );
	jmp match_register_size;
	
  high_byte_register:
	mov( 1, ah );
	or( $80, rex_prefix );
	jmp match_register_size;
	
end convert_register;


proc( convert_fpu_register );

	mov( al, ah );
	shr( 4, ah );
	and( %111, al );
	cmp( ah, 10 );
	jne invalid_operand;
	jmp match_register_size;

end convert_fpu_register;

	
proc( convert_mmx_register );

	mov( al, ah );
	shr( 4, ah );
	cmp( ah, $0C );
	je xmm_register;
	ja invalid_operand;
	and( %111, al );
	cmp( ah, $0B );
	jne invalid_operand;
	mov( 8, ah );
	jmp match_register_size;
	
  xmm_register:
	and( $0F, al );
	mov( 16, ah );
	cmp( al, 8 );
	jb match_register_size;
	cmp( code_type, 64 );
	jne invalid_operand;
	jmp match_register_size;
	
end convert_mmx_register;


	
proc( get_jump_operator );
 
	mov( 0, jump_type );
	cmp( al, $12 );
	jne jump_operator_ok;
	lodsw;
	mov( al, jump_type );
	mov( ah, al );
  jump_operator_ok:
	ret();
	
end get_jump_operator;


proc( make_stub );

	mov( edx, stub_file );
	or( edx, edx );
	jnz stub_from_file;
	
	push( esi );
	mov( edi, edx );
	xor( eax, eax );
	mov( $20, ecx );
	rep.stosd;
	mov( &default_stub_end, eax );
	sub( &default_stub, eax );
	add( $40, eax );
	lea( ecx, [eax+$100-$40] );
	mov( asWord( "MZ" ), (type word [edx]) );
	mov( 1, (type word [edx+4]) );
	mov( ax, (type word [edx+2]) );
	mov( 4, (type word [edx+8]) );
	mov( $10, (type word [edx+$0A]) );
	mov( $0FFFF, (type word [edx+$0C]) );
	mov( cx, (type word [edx+$10]) );
	mov( ax, (type word [edx+$3C]) );
	mov( $40, (type word [edx+$18]) );
	lea( edi, [edx+$40] );
	mov( &default_stub, esi );
	mov( &default_stub_end, ecx );
	sub( &default_stub, ecx );
	rep.movsb;
	pop( esi );
	jmp stub_ok;
	
  default_stub:

	// The following is hand-assembled 16-bit code (HLA does not
	// handle 16-bit code).
	
	byte	$0e;				// push( cseg );
	byte	$1f;				// push( dseg );
	byte	$ba, $0e, $00;		// mov dx, offset stub_message
	byte	$b4, $09;			// mov( 9, ah );
	byte	$cd, $21;			// int( $21 );
	byte	$b8, $01, $4c;		// mov ax, $4c01
	byte	$cd, $21;			// int( $21 );

stub_message:
	byte "This program cannot be run in DOS mode.",cr,lf,$24;
	qword	0;
  default_stub_end:



  stub_from_file:
	push( esi );
	mov( edx, esi );
	call open_binary_file;
	mov( edi, edx );
	mov( $1C, ecx );
	mov( edx, esi );
	read( ebx, edx, ecx );
	jc binary_stub;
	cmp( (type word [esi]), asWord( "MZ" ) );
	jne binary_stub;
	add( $1C, edi );
	movzx( (type word [esi+6]), ecx );
	add( %11, ecx );
	and( !%11, ecx );
	add( ($40-$1C) >> 2, ecx );
	lea( eax, [edi+ecx*4] );
	out_of_mem( ae, edi, display_buffer );
	xor( eax, eax );
	rep.stosd;
	mov( $40, edx );
	xchg( [esi+$18], dx );
	seek( ebx, edx );
	movzx( (type word [esi+6]), ecx );
	shl( 2, ecx );
	lea( edx, [esi+$40] );
	read( ebx, edx, ecx );
	mov( edi, edx );
	sub( esi, edx );
	shr( 4, edx );
	xchg( [esi+8], dx );
	shl( 4, edx );
	seek( ebx, edx );
	movzx( (type word [esi+4]), ecx );
	dec( ecx );
	shl( 9, ecx );
	movzx( (type word [esi+2]), edx );
	add( edx, ecx );
	mov( edi, edx );
	sub( eax, ecx );
	je read_stub_code;
	jb stub_code_ok;
	push( ecx );
	dec( ecx );
	shr( 3, ecx );
	inc( ecx );
	shl( 1, ecx );
	lea( eax, [edi+ecx*4] );
	out_of_mem( ae, eax, display_buffer );
	xor( eax, eax );
	rep.stosd;
	pop( ecx );
  read_stub_code:
	read( ebx, edx, ecx );
  stub_code_ok:
	close( ebx );
	mov( edi, edx );
	sub( esi, edx );
	mov( dx, ax );
	and( $1FF, ax );
	mov( ax, [esi+2] );
	dec( edx );
	shr( 9, edx );
	inc( edx );
	mov( dx, [esi+4] );
	mov( edi, eax );
	sub( esi, eax );
	mov( eax, [esi+$3C] );
	pop( esi );
  stub_ok:
	ret();
	
  binary_stub:
	mov( edi, esi );
	mov( $40 >> 2, ecx );
	xor( eax, eax );
	rep.stosd;
	xor( edx, edx );
	rseek( ebx, edx );
	push( eax );
	xor( edx, edx );
	seek( ebx, edx );
	mov( [esp], ecx );
	add( $40+%111, ecx );
	and( !%111, ecx );
	mov( cx, ax );
	and( $1FF, ax );
	mov( ax, [esi+2] );
	lea( eax, [ecx+$1FF] );
	and( !$1FF, eax );
	mov( ax, [esi+4] );
	mov( ecx, [esi+$3C] );
	sub( $40, ecx );
	mov( $10000, eax );
	sub( ecx, eax );
	jbe binary_heap_ok;
	shr( 4, eax );
	mov( ax, [esi+$0A] );
  binary_heap_ok:
	mov( asWord( "MZ" ), (type word [esi]) );
	mov( 4, (type word [esi+8]) );
	mov( $0FFFF, ax );
	mov( ax, [esi+$0C] );
	dec( ax );
	mov( ax, [esi+$10] );
	sub( $0E, ax );
	mov( ax, [esi+$0E] );
	mov( ax, [esi+$16] );
	mov( $100, (type word [esi+$14]) );
	mov( $40, (type word [esi+$18]) );
	mov( display_buffer, eax );
	sub( ecx, eax );
	out_of_mem( ae, edi, eax );
	mov( edi, edx );
	shr( 2, ecx );
	xor( eax, eax );
	rep.stosd;
	pop( ecx );
	read( ebx, edx, ecx );
	close( ebx );
	pop( esi );
	ret();

end make_stub;



//////////////////////////////////////////////////////////////////////////
//
// Assembler

procedure fasmAssembler;
begin fasmAssembler;

	xor( eax, eax );
	mov( eax, stub_size );
	mov( eax, number_of_sections );
	mov( ax, current_pass );
	
  assembler_loop:
	mov( labels_list, eax );
	mov( eax, display_buffer );
	mov( additional_memory, eax );
	mov( eax, free_additional_memory );
	mov( additional_memory_end, eax );
	mov( eax, structures_buffer );
	mov( source_start, esi );
	mov( code_start, edi );
	xor( eax, eax );
	mov( eax, (type dword adjustment) );
	mov( eax, (type dword adjustment[4]) );
	mov( edi, (type dword org_origin) );
	mov( eax, (type dword org_origin[4]) );
	mov( edi, org_start );
	mov( eax, org_registers );
	mov( eax, org_symbol );
	mov( eax, error_line );
	mov( eax, counter );
	mov( eax, format_flags );
	mov( eax, number_of_relocations );
	mov( eax, undefined_data_end );
	mov( al, next_pass_needed );
	mov( al, output_format );
	mov( al, labels_type );
	mov( al, virtual_data );
	mov( 16, code_type );
	
  pass_loop:
	call assemble_line;
	jnc pass_loop;
	
	mov( additional_memory_end, eax );
	cmp( eax, structures_buffer );
	je pass_done;
	
	sub( $20, eax );
	mov( [eax+4], eax );
	mov( eax, current_line );
	jmp missing_end_directive;
	
  pass_done:
	call close_pass;
	mov( labels_list, eax );
	
  check_symbols:
	cmp( eax, memory_end );
	jae symbols_checked;
	
	test( 8, (type byte [eax+8]) );
	jz symbol_defined_ok;
	
	mov( current_pass, cx );
	cmp( cx, [eax+18] );
	jne symbol_defined_ok;
	
	test( 1, (type byte [eax+8]) );
	jz symbol_defined_ok;
	
	sub( [eax+16], cx );
	cmp( cx, 1 );
	jne symbol_defined_ok;
	
	and( _byte( !1 ), (type byte [eax+8]) );
	or( -1, next_pass_needed );
  symbol_defined_ok:
	test( $10, (type byte [eax+8]) );
	jz use_prediction_ok;
	
	mov( current_pass, cx );
	and( _byte( !$10 ), (type byte [eax+8]) );
	test( $20, (type byte [eax+8]) );
	jnz check_use_prediction;
	
	cmp( cx, [eax+18] );
	jne use_prediction_ok;
	
	test( 8, (type byte [eax+8]) );
	jz use_prediction_ok;
	jmp use_misprediction;
	
  check_use_prediction:
	test( 8, (type byte [eax+8]) );
	jz use_misprediction;
	
	cmp( cx, [eax+18] );
	je use_prediction_ok;
	
  use_misprediction:
	or( -1, next_pass_needed );
	
  use_prediction_ok:
	test( $40, (type byte [eax+8]) );
	jz check_next_symbol;
	
	and( _byte( !$40 ), (type byte [eax+8]) );
	test( 4, (type byte [eax+8]) );
	jnz define_misprediction;
	
	mov( current_pass, cx );
	test( $80, (type byte [eax+8]) );
	jnz check_define_prediction;
	
	cmp( cx, [eax+16] );
	jne check_next_symbol;
	
	test( 1, (type byte [eax+8]) );
	jz check_next_symbol;
	jmp define_misprediction;
	
  check_define_prediction:
	test( 1, (type byte [eax+8]) );
	jz define_misprediction;
	
	cmp( cx, [eax+16] );
	je check_next_symbol;
	
  define_misprediction:
	or( -1, next_pass_needed );
	
  check_next_symbol:
	add( LABEL_STRUCTURE_SIZE, eax );
	jmp check_symbols;
	
  symbols_checked:
	cmp( next_pass_needed, 0 );
	jne next_pass;
	
	mov( error_line, eax );
	or( eax, eax );
	jz assemble_ok;
	
	mov( eax, current_line );
	jmp( error );
	
  next_pass:
	inc( current_pass );
	mov( current_pass, ax );
	cmp( ax, passes_limit );
	je code_cannot_be_generated;
	jmp assembler_loop;
	
  assemble_ok:
	ret();
	
end fasmAssembler;


proc( reserve_negative );

	if( error_line == 0 ) then

		mov( current_line, eax );
		mov( eax, error_line );
		mov( &invalid_value, error );

	endif;
  	mov( [esi], al );
	cmp( al, $f );
	if( @nz ) then
	
	    or( al, al );
	    jnz extra_characters_on_line;
	
  	endif;
    clc;
    ret();
	
end reserve_negative;


proc( reserve_bytes );

	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	call get_dword_value;
	cmp( next_pass_needed, 0 );
	jne rb_value_ok;
	
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
  rb_value_ok:
	cmp( eax, 0 );
	jl reserve_negative;
	
	mov( eax, ecx );
	mov( ecx, edx );
	add( edi, edx );
	out_of_mem( c );
	
	out_of_mem( a, edx, display_buffer );
	
	push( edi );
	cmp( next_pass_needed, 0 );
	je zero_bytes;
	
	add( ecx, edi );
	jmp reserved_data;
	
  zero_bytes:
	xor( eax, eax );
	shr( 1, ecx );
	jnc bytes_stosb_ok;
	stosb;
	
  bytes_stosb_ok:
	shr( 1, ecx );
	jnc bytes_stosw_ok;
	stosw;
	
  bytes_stosw_ok:
	rep.stosd;
	
  reserved_data:
	pop( eax );
	undefined_data( eax, edi );
  	mov( [esi], al );
	cmp( al, $f );
	if( @nz ) then
	
	    or( al, al );
	    jnz extra_characters_on_line;
	
  	endif;
    clc;
    ret();

end	reserve_bytes;
	

proc( reserve_words );

	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	call get_dword_value;
	cmp( next_pass_needed, 0 );
	jne rw_value_ok;
	
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
  rw_value_ok:
	cmp( eax, 0 );
	jl reserve_negative;
	
	mov( eax, ecx );
	mov( ecx, edx );
	shl( 1, edx );
	out_of_mem( c );
	
	add( edi, edx );
	out_of_mem( c );
	
	out_of_mem( a, edx, display_buffer );
	
	push( edi );
	cmp( next_pass_needed, 0 );
	je zero_words;
	lea( edi, [edi+ecx*2] );
  reserved_data:
	pop( eax );
	undefined_data( eax, edi );
  	mov( [esi], al );
	cmp( al, $f );
	if( @nz ) then
	
	    or( al, al );
	    jnz extra_characters_on_line;
	
  	endif;
    clc;
    ret();

  zero_words:
	xor( eax, eax );
	shr( 1, ecx );
	jnc words_stosw_ok;
	stosw;
	
  words_stosw_ok:
	rep.stosd;
	jmp reserved_data;

end reserve_words;



proc( reserve_dwords );

	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	call get_dword_value;
	cmp( next_pass_needed, 0 );
	jne rd_value_ok;
	
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
  rd_value_ok:
	cmp( eax, 0 );
	jl reserve_negative;
	
	mov( eax, ecx );
	mov( ecx, edx );
	shl( 1, edx );
	out_of_mem( c );
	
	shl( 1, edx );
	out_of_mem( c );
	
	add( edi, edx );
	out_of_mem( c );
	
	out_of_mem( a, edx, display_buffer );
	
	push( edi );
	cmp( next_pass_needed, 0 );
	je zero_dwords;
	
	lea( edi, [edi+ecx*4] );
  reserved_data:
	pop( eax );
	undefined_data( eax, edi );
  	mov( [esi], al );
	cmp( al, $f );
	if( @nz ) then
	
	    or( al, al );
	    jnz extra_characters_on_line;
	
  	endif;
    clc;
    ret();

  zero_dwords:
	xor( eax, eax );
	rep.stosd;
	jmp reserved_data;
	
end reserve_dwords;


proc( reserve_pwords );

	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	call get_dword_value;
	cmp( next_pass_needed, 0 );
	jne rp_value_ok;
	
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
  rp_value_ok:
	cmp( eax, 0 );
	jl reserve_negative;
	
	mov( eax, ecx );
	shl( 1, ecx );
	out_of_mem( c );
	
	add( eax, ecx );
	mov( ecx, edx );
	shl( 1, edx );
	out_of_mem( c );
	
	add( edi, edx );
	out_of_mem( c );
	
	out_of_mem( a, edx, display_buffer );
	
	push( edi );
	cmp( next_pass_needed, 0 );
	je zero_words;
	
	lea( edi, [edi+ecx*2] );
  reserved_data:
	pop( eax );
	undefined_data( eax, edi );
  	mov( [esi], al );
	cmp( al, $f );
	if( @nz ) then
	
	    or( al, al );
	    jnz extra_characters_on_line;
	
  	endif;
    clc;
    ret();

  zero_words:
	xor( eax, eax );
	shr( 1, ecx );
	jnc words_stosw_ok;
	stosw;
	
  words_stosw_ok:
	rep.stosd;
	jmp reserved_data;

end reserve_pwords;



proc( reserve_qwords );

	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	call get_dword_value;
	cmp( next_pass_needed, 0 );
	jne rq_value_ok;
	
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
  rq_value_ok:
	cmp( eax, 0 );
	jl reserve_negative;
	
	mov( eax, ecx );
	shl( 1, ecx );
	out_of_mem( c );
	
	mov( ecx, edx );
	shl( 1, edx );
	out_of_mem( c );
	
	shl( 1, edx );
	out_of_mem( c );
	
	add( edi, edx );
	out_of_mem( c );
	
	out_of_mem( a, edx, display_buffer );
	
	push( edi );
	cmp( next_pass_needed, 0 );
	je zero_dwords;
	
	lea( edi, [edi+ecx*4] );
  reserved_data:
	pop( eax );
	undefined_data( eax, edi );
  	mov( [esi], al );
	cmp( al, $f );
	if( @nz ) then
	
	    or( al, al );
	    jnz extra_characters_on_line;
	
  	endif;
    clc;
    ret();

  zero_dwords:
	xor( eax, eax );
	rep.stosd;
	jmp reserved_data;
	
end reserve_qwords;	
	



proc( reserve_twords );

	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	call get_dword_value;
	cmp( next_pass_needed, 0 );
	jne rt_value_ok;
	
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
  rt_value_ok:
	cmp( eax, 0 );
	jl reserve_negative;
	
	mov( eax, ecx );
	shl( 2, ecx );
	out_of_mem( c );
	
	add( eax, ecx );
	mov( ecx, edx );
	shl( 1, edx );
	out_of_mem( c );
	
	add( edi, edx );
	out_of_mem( c );
	
	out_of_mem( a, edx, display_buffer );
	
	push( edi );
	cmp( next_pass_needed, 0 );
	je zero_words;
	
	lea( edi, [edi+ecx*2] );
  reserved_data:
	pop( eax );
	undefined_data( eax, edi );
  	mov( [esi], al );
	cmp( al, $f );
	if( @nz ) then
	
	    or( al, al );
	    jnz extra_characters_on_line;
	
  	endif;
    clc;
    ret();

  zero_words:
	xor( eax, eax );
	shr( 1, ecx );
	jnc words_stosw_ok;
	stosw;
	
  words_stosw_ok:
	rep.stosd;
	jmp reserved_data;
	
end reserve_twords;


proc( data_file );

  data_file_entry:
	lodsw;
	cmp( ax, '(' );
	jne invalid_argument;
	
	add( 4, esi );
	call open_binary_file;
	mov( [esi-4], eax );
	lea( esi, [esi+eax+1] );
	xor( edx, edx );
	rseek( ebx, edx );
	push( eax );
	xor( edx, edx );
	cmp( (type byte [esi]), ':' );
	jne position_ok;
	
	inc( esi );
	cmp( (type byte [esi]), '(' );
	jne invalid_argument;
	
	inc( esi );
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	push( ebx );
	call get_dword_value;
	pop( ebx );
	mov( eax, edx );
	sub( edx, [esp] );
	
  position_ok:
	cmp( (type byte [esi]), ',' );
	jne size_ok;
	
	inc( esi );
	cmp( (type byte [esi]), '(' );
	jne invalid_argument;
	
	inc( esi );
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	push( ebx );
	push( edx );
	call get_dword_value;
	pop( edx );
	pop( ebx );
	mov( eax, [esp] );
	
  size_ok:
	seek( ebx, edx );
	pop( ecx );
	mov( edi, edx );
	add( ecx, edi );
	out_of_mem( c );
	
	out_of_mem( a, edi, display_buffer );
	
	read( ebx, edx, ecx );
	jc error_reading_file;
	
	close( ebx );
	lodsb;
	cmp( al, ',' );
	je data_file_entry;
	
	dec( esi );
  	mov( [esi], al );
	cmp( al, $f );
	if( @nz ) then
	
	    or( al, al );
	    jnz extra_characters_on_line;
	
  	endif;
    clc;
    ret();

end data_file;



proc( align_directive );

	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	call get_dword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
	mov( eax, edx );
	dec( edx );
	test( edx, eax );
	jnz invalid_value;
	
	or( eax, eax );
	jz invalid_value;
	
	cmp( eax, 1 );
	je instruction_assembled;
	
	mov( edi, ecx );
	sub( (type dword org_origin), ecx );
	cmp( org_registers, 0 );
	jne section_not_aligned_enough;
	
	cmp( labels_type, 0 );
	je make_alignment;
	
	cmp( output_format, 3 );
	je pe_alignment;
	
	mov( org_symbol, ebx );
	cmp( (type byte [ebx]), 0 );
	jne section_not_aligned_enough;
	
	cmp( eax, [ebx+$10] );
	jbe make_alignment;
	jmp section_not_aligned_enough;
	
  pe_alignment:
	cmp( eax, $1000 );
	ja section_not_aligned_enough;
	
  make_alignment:
	dec( eax );
	and( eax, ecx );
	jz instruction_assembled;
	
	neg( ecx );
	add( eax, ecx );
	inc( ecx );
	mov( ecx, edx );
	add( edi, edx );
	out_of_mem( c );
	

	out_of_mem( a, edx, display_buffer );
	
	push( edi );
	cmp( next_pass_needed, 0 );
	je nops;
	
	add( ecx, edi );
	pop( eax );
	undefined_data( eax, edi );
  	mov( [esi], al );
	cmp( al, $f );
	if( @nz ) then
	
	    or( al, al );
	    jnz extra_characters_on_line;
	
  	endif;
    clc;
    ret();
	
  nops:
	mov( $90909090, eax );
	shr( 1, ecx );
	jnc nops_stosb_ok;
	
	stosb;
  nops_stosb_ok:
	shr( 1, ecx );
	jnc nops_stosw_ok;
	
	stosw;
  nops_stosw_ok:
	rep.stosd;
	pop( eax );
	undefined_data( eax, edi );
  instruction_assembled:
  	mov( [esi], al );
	cmp( al, $f );
	if( @nz ) then
	
	    or( al, al );
	    jnz extra_characters_on_line;
	
  	endif;
    clc;
    ret();

end align_directive;









proc( assemble_line );

	mov( display_buffer, eax );
	sub( $100, eax );
	out_of_mem( a, edi, eax );
	
	lodsb;
	cmp( al, 1 );
	je assemble_instruction;
	jb source_end;
	
	cmp( al, 3 );
	jb define_label;
	je define_constant;
	
	cmp( al, $0F );
	je new_line;
	
	cmp( al, $13 );
	je code_type_setting;
	
	cmp( al, $10 );
	jne illegal_instruction;
	lodsb;
	jmp segment_prefix;
	
  code_type_setting:
	lodsb;
	mov( al, code_type );
	jmp line_assembled;
	
  new_line:
	lodsd;
	mov( eax, current_line );
	mov( 0, prefixed_instruction );
	
  continue_line:
	cmp( (type byte [esi]), $0F );
	je line_assembled;
	jmp assemble_line;
	
  define_label:
	lodsd;
	cmp( eax, $0F );
	jb invalid_use_of_symbol;
	je reserved_word_used_as_symbol;
	
	mov( eax, ebx );
	lodsb;
	mov( al, cl );
	mov( edi, eax );
	xor( edx, edx );
	sub( (type dword org_origin), eax );
	sbb( (type dword org_origin[4]), edx );
	mov( labels_type, ch );
	cmp( virtual_data, 0 );
	jne make_virtual_label;
	or( 1, (type byte [ebx+9]) );
	xchg( [ebx], eax );
	xchg( [ebx+4], edx );
	sub( [ebx], eax );
	sbb( [ebx+4], edx );
	mov( eax, (type dword adjustment) );
	mov( edx, (type dword adjustment[4]) );
	or( edx, eax );
	setnz( ah );
	jmp finish_label_symbol;
	
  make_virtual_label:
	and( _byte( !1 ), (type byte [ebx+9]) );
	cmp( eax, [ebx] );
	mov( eax, [ebx] );
	setne( ah );
	cmp( edx, [ebx+4] );
	mov( edx, [ebx+4] );
	setne( al );
	or( al, ah );
	
  finish_label_symbol:
	cmp( cl, [ebx+10] );
	mov( cl, [ebx+10] );
	setne( al );
	or( al, ah );
	cmp( ch, [ebx+11] );
	mov( ch, [ebx+11] );
	setne( al );
	or( al, ah );
	mov( org_registers, edx );
	cmp( edx, [ebx+12] );
	mov( edx, [ebx+12] );
	setne( al );
	or( al, ah );
	or( ch, ch );
	jz label_symbol_ok;
	
	mov( org_symbol, edx );
	cmp( edx, [ebx+20] );
	mov( edx, [ebx+20] );
	setne( al );
	or( al, ah );
  label_symbol_ok:
	mov( current_pass, cx );
	xchg( cx, [ebx+16] );
	mov( current_line, edx );
	mov( edx, [ebx+28] );
	and( _byte( !2 ), (type byte [ebx+8]) );
	test( 1, (type byte [ebx+8]) );
	jz new_label;
	
	cmp( cx, [ebx+16] );
	je symbol_already_defined;
	
	inc( cx );
	sub( [ebx+16], cx );
	setnz( al );
	or( al, ah );
	jz continue_line;
	
	test( 8, (type byte [ebx+8]) );
	jz continue_line;
	
	mov( current_pass, cx );
	cmp( cx, [ebx+18] );
	jne continue_line;
	or( -1, next_pass_needed );
	jmp continue_line;
	
  new_label:
	or( 1, (type byte [ebx+8]) );
	jmp continue_line;
	
  define_constant:
	lodsd;
	inc( esi );
	cmp( eax, $0F );
	jb invalid_use_of_symbol;
	je reserved_word_used_as_symbol;
	
	mov( [eax+8], edx );
	push( edx );
	cmp( current_pass, 0 );
	je get_constant_value;
	
	test( 4, dl );
	jnz get_constant_value;
	
	mov( current_pass, cx );
	cmp( cx, [eax+16] );
	je get_constant_value;
	
	and( _byte( !1 ), dl );
	mov( dl, [eax+8] );
  get_constant_value:
	push( eax );
	mov( (type byte [esi-1]), al );
	push( eax );
	call get_value;
	pop( ebx );
	mov( bl, ch );
	pop( ebx );
	pop( (type dword [ebx+8]) );
	cmp( ebx, $0F );
	jb invalid_use_of_symbol;
	je reserved_word_used_as_symbol;
	
	xor( cl, cl );
	mov( value_type, ch );
	cmp( ch, 3 );
	je invalid_use_of_symbol;
	
  make_constant:
	and( _byte( !1 ), (type byte [ebx+9]) );
	cmp( eax, [ebx] );
	mov( eax, [ebx] );
	setne( ah );
	cmp( edx, [ebx+4] );
	mov( edx, [ebx+4] );
	setne( al );
	or( al, ah );
	cmp( cl, [ebx+10] );
	mov( cl, [ebx+10] );
	setne( al );
	or( al, ah );
	cmp( ch, [ebx+11] );
	mov( ch, [ebx+11] );
	setne( al );
	or( al, ah );
	xor( edx, edx );
	cmp( edx, [ebx+12] );
	mov( edx, [ebx+12] );
	setne( al );
	or( al, ah );
	or( ch, ch );
	jz constant_symbol_ok;
	mov( symbol_identifier, edx );
	cmp( edx, [ebx+20] );
	mov( edx, [ebx+20] );
	setne( al );
	or( al, ah );
  constant_symbol_ok:
	mov( current_pass, cx );
	xchg( cx, [ebx+16] );
	mov( current_line, edx );
	mov( edx, [ebx+28] );
	test( 1, (type byte [ebx+8]) );
	jz new_constant;
	cmp( cx, [ebx+16] );
	jne redeclare_constant;
	test( 2, (type byte [ebx+8]) );
	jz symbol_already_defined;
	or( 4, (type byte [ebx+8]) );
	jmp instruction_assembled;
  redeclare_constant:
	inc( cx );
	sub( [ebx+16], cx );
	setnz( al );
	or( al, ah );
	jz instruction_assembled;
	test( 4, (type byte [ebx+8]) );
	jnz instruction_assembled;
	test( 8, (type byte [ebx+8]) );
	jz instruction_assembled;
	mov( current_pass, cx );
	cmp( cx, [ebx+18] );
	jne instruction_assembled;
	or( -1, next_pass_needed );
	jmp instruction_assembled;
  new_constant:
	or( 1+2, (type byte [ebx+8]) );
	jmp instruction_assembled;
  assemble_instruction:
	mov( 0, operand_size );
	mov( 0, size_override );
	mov( 0, operand_prefix );
	mov( 0, rex_prefix );
	mov( 0, immediate_size );
	movzx( (type word [esi]), ebx );
	mov( [esi+2], al );
	mov( instrHandlerPtrs[ebx*4], ebx );
//fasmassembler:	add( &fasmAssembler, ebx );
	add( 3, esi );
	jmp( ebx );
	
  instruction_assembled:
	mov( [esi], al );
	cmp( al, $0F );
	je line_assembled;
	or( al, al );
	jnz extra_characters_on_line;
  line_assembled:
	clc;
	ret();

  source_end:
	dec( esi );
	stc;
	ret();


  org_directive::
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	call get_qword_value;
	mov( value_type, cl );
	test( 1, cl );
	jnz invalid_use_of_symbol;
	mov( cl, labels_type );
	mov( edi, ecx );
	sub( eax, ecx );
	adc( 0, edx );
	neg( edx );
	mov( ecx, (type dword org_origin) );
	mov( edx, (type dword org_origin[4]) );
	mov( 0, org_registers );
	mov( edi, org_start );
	mov( symbol_identifier, edx );
	mov( edx, org_symbol );
	cmp( output_format, 1 );
	ja instruction_assembled;
	cmp( edi, code_start );
	jne instruction_assembled;
	cmp( eax, $100 );
	jne instruction_assembled;
	bts( 0, format_flags );
	jmp instruction_assembled;
	
  label_directive::
	lodsb;
	cmp( al, 2 );
	jne invalid_argument;
	lodsd;
	cmp( eax, $0F );
	jb invalid_use_of_symbol;
	je reserved_word_used_as_symbol;
	inc( esi );
	mov( eax, ebx );
	xor( cl, cl );
	lodsb;
	cmp( al, ':' );
	je get_label_size;
	dec( esi );
	cmp( al, $11 );
	jne label_size_ok;
  get_label_size:
	lodsw;
	cmp( al, $11 );
	jne invalid_argument;
	mov( ah, cl );
  label_size_ok:
	mov( edi, eax );
	xor( edx, edx );
	sub( (type dword org_origin), eax );
	sbb( (type dword org_origin[4]), edx );
	mov( org_registers, ebp );
	cmp( (type byte [esi]), $80 );
	je get_free_label_value;
	mov( labels_type, ch );
	push( org_symbol );
	pop( address_symbol );
	cmp( virtual_data, 0 );
	jne make_free_label;
	or( 1, (type byte [ebx+9]) );
	xchg( [ebx], eax );
	xchg( [ebx+4], edx );
	sub( [ebx], eax );
	sbb( [ebx+4], edx );
	mov( eax, (type dword adjustment) );
	mov( edx, (type dword adjustment[4]) );
	or( edx, eax );
	setne( ah );
	jmp finish_label;
  get_free_label_value:
	inc( esi );
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	push( (type dword [ebx+8]) );
	push( ebx );
	push( ecx );
	and( _byte( !1 ), (type byte [ebx+8]) );
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	call get_address_value;
	or( bh, bh );
	setnz( ch );
	xchg( cl, ch );
	mov( cx, bp );
	shl( 16, ebp );
	xchg( bh, bl );
	mov( bx, bp );
	pop( ecx );
	pop( ebx );
	pop( (type dword [ebx+8]) );
	mov( value_type, ch );
	or( ch, ch );
	jz make_free_label;
	cmp( ch, 2 );
	jne invalid_use_of_symbol;

  make_free_label:
	and( _byte( !1 ), (type byte [ebx+9]) );
	cmp( eax, [ebx] );
	mov( eax, [ebx] );
	setne( ah );
	cmp( edx, [ebx+4] );
	mov( edx, [ebx+4] );
	setne( al );
	or( al, ah );
	jmp finish_label;
  finish_label:
	cmp( cl, [ebx+10] );
	mov( cl, [ebx+10] );
	setne( al );
	or( al, ah );
	cmp( ch, [ebx+11] );
	mov( ch, [ebx+11] );
	setne( al );
	or( al, ah );
	cmp( ebp, [ebx+12] );
	mov( ebp, [ebx+12] );
	setne( al );
	or( al, ah );
	or( ch, ch );
	jz free_label_symbol_ok;
	mov( address_symbol, edx );
	cmp( edx, [ebx+20] );
	mov( edx, [ebx+20] );
	setne( al );
	or( al, ah );
  free_label_symbol_ok:
	mov( current_pass, cx );
	xchg( cx, [ebx+16] );
	mov( current_line, edx );
	mov( edx, [ebx+28] );
	and( _byte( !2 ), (type byte [ebx+8]) );
	test( 1, (type byte [ebx+8]) );
	jz new_free_label;
	cmp( cx, [ebx+16] );
	je symbol_already_defined;
	inc( cx );
	sub( [ebx+16], cx );
	setnz( al );
	or( al, ah );
	jz instruction_assembled;
	test( 8, (type byte [ebx+8]) );
	jz instruction_assembled;
	mov( current_pass, cx );
	cmp( cx, [ebx+18] );
	jne instruction_assembled;
	or( -1, next_pass_needed );
	jmp instruction_assembled;
  new_free_label:
	or( 1, (type byte [ebx+8]) );
	jmp instruction_assembled;
  load_directive::
	lodsb;
	cmp( al, 2 );
	jne invalid_argument;
	lodsd;
	cmp( eax, $0F );
	jb invalid_use_of_symbol;
	je reserved_word_used_as_symbol;
	inc( esi );
	push( eax );
	mov( 1, al );
	cmp( (type byte [esi]), $11 );
	jne load_size_ok;
	lodsb;
	lodsb;
  load_size_ok:
	cmp( al, 8 );
	ja invalid_value;
	mov( al, operand_size );
	mov( 0, (type dword value) );
	mov( 0, (type dword value[4]) );
	lodsw;
	cmp( ax, '(' );
	jne invalid_argument;
  load_from_code:
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	call get_relative_offset;
	neg( eax );
	cmp( next_pass_needed, 0 );
	jne load_address_ok;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
  load_address_ok:
	push( esi );
	push( edi );
	mov( edi, esi );
	sub( eax, esi );
	jc bad_load_address;
	cmp( esi, org_start );
	jb bad_load_address;
	mov( &value, edi );
	movzx( operand_size, ecx );
	cmp( ecx, eax );
	ja bad_load_address;
	rep.movsb;
	jmp value_loaded;
  bad_load_address:
	cmp( error_line, 0 );
	jne value_loaded;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &value_out_of_range, error );
  value_loaded:
	pop( edi );
	pop( esi );
	mov( (type dword value), eax );
	mov( (type dword value[4]), edx );
	pop( ebx );
	xor( cx, cx );
	jmp make_constant;
  store_directive::
	cmp( (type byte [esi]), $11 );
	je sized_store;
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	call get_byte_value;
	xor( edx, edx );
	movzx( al, eax );
	mov( 1, operand_size );
	jmp store_value_ok;
  sized_store:
	call get_value;
  store_value_ok:
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( eax, (type dword value) );
	mov( edx, (type dword value[4]) );
	lodsw;
	cmp( ax, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	call get_relative_offset;
	neg( eax );
	cmp( next_pass_needed, 0 );
	jne store_address_ok;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
  store_address_ok:
	push( esi );
	push( edi );
	sub( eax, edi );
	jc bad_store_address;
	
	cmp( edi, org_start );
	jb bad_store_address;
	
	mov( &value, esi );
	movzx( operand_size, ecx );
	cmp( ecx, eax );
	ja bad_store_address;
	
	rep.movsb;
	mov( edi, eax );
	pop( edi );
	pop( esi );
	cmp( edi, undefined_data_end );
	jne instruction_assembled;
	
	cmp( eax, undefined_data_start );
	jbe instruction_assembled;
	
	mov( eax, undefined_data_start );
	jmp instruction_assembled;
	
  bad_store_address:
	pop( edi );
	pop( esi );
	cmp( error_line, 0 );
	jne instruction_assembled;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &value_out_of_range, error );
	jmp instruction_assembled;

  display_directive::
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), 0 );
	jne display_byte;
	inc( esi );
	lodsd;
	mov( eax, ecx );
	push( edi );
	mov( display_buffer, edi );
	sub( 4, edi );
	sub( eax, edi );
	mov( edi, display_buffer );
	rep.movsb;
	stosd;
	pop( edi );
	inc( esi );
	jmp display_next;
  display_byte:
	call get_byte_value;
	push( edi );
	mov( display_buffer, edi );
	sub( 4+1, edi );
	mov( edi, display_buffer );
	stosb;
	mov( 1, eax );
	stosd;
	pop( edi );
  display_next:
	out_of_mem( a, edi, display_buffer );
	lodsb;
	cmp( al, ',' );
	je display_directive;
	dec( esi );
	jmp instruction_assembled;
	
  times_directive::
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	call get_dword_value;
	cmp( next_pass_needed, 0 );
	jne times_value_ok;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
  times_value_ok:
	cmp( eax, 0 );
	je zero_times;
	jl negative_times;
	cmp( (type byte [esi]), ':' );
	jne times_argument_ok;
	inc( esi );
  times_argument_ok:
	push( counter );
	push( counter_limit );
	mov( eax, counter_limit );
	mov( 1, counter );
  times_loop:
	mov( esp, eax );
	sub( $100, eax );
	jc stack_overflow;
	cmp( eax, stack_limit );
	jb stack_overflow;
	push( esi );
	or( -1, prefixed_instruction );
	if( (type byte [esi]) <> $0F ) then
	
		call assemble_line;
		
	endif;
	mov( counter_limit, eax );
	cmp( counter, eax );
	je times_done;
	inc( counter );
	pop( esi );
	jmp times_loop;
  times_done:
	pop( eax );
	pop( counter_limit );
	pop( counter );
	jmp instruction_assembled;
  negative_times:
	cmp( error_line, 0 );
	jne zero_times;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_value, error );
  zero_times:
	call skip_line;
	jmp instruction_assembled;

  virtual_directive::
	lodsb;
	cmp( al, $80 );
	jne virtual_at_current;
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	call get_address_value;
	mov( address_symbol, ebp );
	xor( ch, ch );
	or( bh, bh );
	jz set_virtual;
	mov( 1, ch );
	jmp set_virtual;
  virtual_at_current:
	dec( esi );
	mov( labels_type, al );
	mov( al, value_type );
	mov( org_symbol, ebp );
	mov( edi, eax );
	xor( edx, edx );
	sub( (type dword org_origin), eax );
	sbb( (type dword org_origin[4]), edx );
	mov( (type word org_registers), bx );
	mov( (type word org_registers[2]), cx );
	xchg( bl, bh );
	xchg( cl, ch );
  set_virtual:
	push( org_registers );
	mov( bh, (type byte org_registers) );
	mov( bl, (type byte org_registers[1]) );
	mov( ch, (type byte org_registers[2]) );
	mov( cl, (type byte org_registers[3]) );
	call allocate_structure_data;
	mov( virtual_directive_assembler, (type word [ebx]) );
	not( eax );
	not( edx );
	add( 1, eax );
	adc( 0, edx );
	add( edi, eax );
	adc( 0, edx );
	xchg( eax, (type dword org_origin) );
	xchg( edx, (type dword org_origin[4]) );
	mov( eax, [ebx+$10] );
	mov( edx, [ebx+$14] );
	pop( eax );
	mov( eax, [ebx+$18] );
	mov( virtual_data, al );
	mov( al, [ebx+2] );
	mov( labels_type, al );
	mov( al, [ebx+3] );
	mov( edi, eax );
	xchg( org_start, eax );
	mov( eax, [ebx+$0C] );
	xchg( org_symbol, ebp );
	mov( ebp, [ebx+$1C] );
	mov( edi, [ebx+8] );
	mov( current_line, eax );
	mov( eax, [ebx+4] );
	or( -1, virtual_data );
	mov( value_type, al );
	test( 1, al );
	jnz invalid_use_of_symbol;
	mov( al, labels_type );
	jmp instruction_assembled;
	

  end_virtual:
	call find_structure_data;
	jc unexpected_instruction;
	mov( [ebx+2], al );
	mov( al, virtual_data );
	mov( [ebx+3], al );
	mov( al, labels_type );
	mov( [ebx+$10], eax );
	mov( eax, (type dword org_origin) );
	mov( [ebx+$14], eax );
	mov( eax, (type dword org_origin[4]) );
	mov( [ebx+$18], eax );
	mov( eax, org_registers );
	mov( [ebx+$0C], eax );
	mov( eax, org_start );
	mov( [ebx+$1C], eax );
	mov( eax, org_symbol );
	mov( [ebx+8], edi );
	jmp remove_structure_data;
	

  repeat_directive::
	cmp( prefixed_instruction, 0 );
	jne unexpected_instruction;
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	call get_dword_value;
	cmp( next_pass_needed, 0 );
	jne repeat_value_ok;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
  repeat_value_ok:
	cmp( eax, 0 );
	je zero_repeat;
	jl negative_repeat;
	call allocate_structure_data;
	mov( repeat_directive_assembler, (type word [ebx]) );
	xchg( counter_limit, eax );
	mov( eax, [ebx+$10] );
	mov( 1, eax );
	xchg( counter, eax );
	mov( eax, [ebx+$14] );
	mov( esi, [ebx+8] );
	mov( current_line, eax );
	mov( eax, [ebx+4] );
	jmp instruction_assembled;
  end_repeat:
	cmp( prefixed_instruction, 0 );
	jne unexpected_instruction;
	call find_structure_data;
	jc unexpected_instruction;
	mov( counter_limit, eax );
	inc( counter );
	cmp( counter, eax );
	jbe continue_repeating;
  stop_repeat:
	mov( [ebx+$10], eax );
	mov( eax, counter_limit );
	mov( [ebx+$14], eax );
	mov( eax, counter );
	call remove_structure_data;
	jmp instruction_assembled;
  continue_repeating:
	mov( [ebx+8], esi );
	jmp instruction_assembled;
  negative_repeat:
	cmp( error_line, 0 );
	jne zero_repeat;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_value, error );
  zero_repeat:
	mov( [esi], al );
	or( al, al );
	jz missing_end_directive;
	cmp( al, $0F );
	jne extra_characters_on_line;
	call find_end_repeat;
	jmp instruction_assembled;
	
	
  while_directive::
	cmp( prefixed_instruction, 0 );
	jne unexpected_instruction;
	call allocate_structure_data;
	mov( while_directive_assembler, (type word [ebx]) );
	mov( 1, eax );
	xchg( counter, eax );
	mov( eax, [ebx+$10] );
	mov( esi, [ebx+8] );
	mov( current_line, eax );
	mov( eax, [ebx+4] );
  do_while:
	push( ebx );
	call calculate_logical_expression;
	or( al, al );
	jnz while_true;
	mov( [esi], al );
	or( al, al );
	jz missing_end_directive;
	cmp( al, $0F );
	jne extra_characters_on_line;
  stop_while:
	call find_end_while;
	pop( ebx );
	mov( [ebx+$10], eax );
	mov( eax, counter );
	call remove_structure_data;
	jmp instruction_assembled;
  while_true:
	pop( ebx );
	jmp instruction_assembled;
  end_while:
	cmp( prefixed_instruction, 0 );
	jne unexpected_instruction;
	call find_structure_data;
	jc unexpected_instruction;
	mov( [ebx+4], eax );
	mov( eax, current_line );
	inc( counter );
	jz too_many_repeats;
	mov( [ebx+8], esi );
	jmp do_while;
	
  if_directive::
	cmp( prefixed_instruction, 0 );
	jne unexpected_instruction;
	call calculate_logical_expression;
	mov( al, dl );
	mov( [esi], al );
	or( al, al );
	jz missing_end_directive;
	cmp( al, $0F );
	jne extra_characters_on_line;
	or( dl, dl );
	jnz if_true;
	call find_else;
	jc instruction_assembled;
	mov( [esi], al );
	cmp( al, 1 );
	jne else_true;
	mov( (type word [esi+1]), ax );
	cmp( ax, if_directive_assembler );
	jne else_true;
	add( 4, esi );
	jmp if_directive;
  if_true:
	xor( al, al );
  make_if_structure:
	call allocate_structure_data;
	mov( if_directive_assembler, (type word [ebx]) );
	mov( al, (type byte [ebx+2]) );
	mov( current_line, eax );
	mov( eax, [ebx+4] );
	jmp instruction_assembled;
  else_true:
	or( al, al );
	jz missing_end_directive;
	cmp( al, $0F );
	jne extra_characters_on_line;
	or( -1, al );
	jmp make_if_structure;
  else_directive::
	cmp( prefixed_instruction, 0 );
	jne unexpected_instruction;
	mov( if_directive_assembler, ax );
	call find_structure_data;
	jc unexpected_instruction;
	cmp( (type byte [ebx+2]), 0 );
	jne unexpected_instruction;
  found_else:
	mov( [esi], al );
	cmp( al, 1 );
	jne skip_else;
	mov( (type word [esi+1]), ax );
	cmp( ax, if_directive_assembler );
	jne skip_else;
	add( 4, esi );
	call find_else;
	jnc found_else;
	call remove_structure_data;
	jmp instruction_assembled;
  skip_else:
	or( al, al );
	jz missing_end_directive;
	cmp( al, $0F );
	jne extra_characters_on_line;
	call find_end_if;
	call remove_structure_data;
	jmp instruction_assembled;
  end_if:
	cmp( prefixed_instruction, 0 );
	jne unexpected_instruction;
	call find_structure_data;
	jc unexpected_instruction;
	call remove_structure_data;
	jmp instruction_assembled;
	


  end_directive::
	lodsb;
	cmp( al, 1 );
	jne invalid_argument;
	lodsw;
	inc( esi );
	cmp( ax, virtual_directive_assembler );
	je end_virtual;
	cmp( ax, repeat_directive_assembler );
	je end_repeat;
	cmp( ax, while_directive_assembler );
	je end_while;
	cmp( ax, if_directive_assembler );
	je end_if;
	cmp( ax, data_directive_assembler );
	je end_data;
	jmp invalid_argument;
	
  end_data:
	cmp( output_format, 3 );
	jne illegal_instruction;
	call find_structure_data;
	jc unexpected_instruction;
	
	movzx( (type byte [ebx+2]), eax );
	mov( current_section, edx );
	mov( edi, ecx );
	sub( [edx+$14], ecx );
	add( [edx+$0C], ecx );
	mov( code_start, edx );
	test( 8, format_flags );
	jnz end_pe64_data;
	sub( [edx+eax*8+$78], ecx );
	mov( ecx, [edx+eax*8+4+$78] );
	jmp remove_structure_data;
  end_pe64_data:
	sub( [edx+eax*8+$88], ecx );
	mov( ecx, [edx+eax*8+4+$88] );
	jmp remove_structure_data;
	
	
  break_directive::
	mov( structures_buffer, ebx );
	mov( [esi], al );
	or( al, al );
	jz find_breakable_structure;
	cmp( al, $0F );
	jne extra_characters_on_line;
  find_breakable_structure:
	cmp( ebx, additional_memory_end );
	je unexpected_instruction;
	mov( [ebx], ax );
	cmp( ax, repeat_directive_assembler );
	je break_repeat;
	cmp( ax, while_directive_assembler );
	je break_while;
	cmp( ax, if_directive_assembler );
	je break_if;
	add( $20, ebx );
	jmp find_breakable_structure;
  break_if:
	push( current_line );
	mov( [ebx+4], eax );
	mov( eax, current_line );
	call remove_structure_data;
	call skip_if_block;
	pop( current_line );
	mov( structures_buffer, ebx );
	jmp find_breakable_structure;
  break_repeat:
	push( ebx );
	call find_end_repeat;
	pop( ebx );
	jmp stop_repeat;
  break_while:
	push( ebx );
	jmp stop_while;

  data_bytes::
  	call get_data_bytes;
	jmp instruction_assembled;
		
	
  data_unicode::
	or( -1, base_code );
  	call get_data_words;
	jmp instruction_assembled;

  data_words::
	mov( 0, base_code );
  	call get_data_words;
	jmp instruction_assembled;
	
  data_dwords::
  	call get_data_dwords;
	jmp instruction_assembled;
	
	


  data_pwords::
  	call get_data_pwords;
	jmp instruction_assembled;
	
  data_qwords::
  	call get_data_qwords;
	jmp instruction_assembled;
	
  data_twords::
  	call get_data_twords;
	jmp instruction_assembled;
	



  simple_instruction_except64::
	cmp( code_type, 64 );
	je illegal_instruction;
  simple_instruction::
	stosb;
	jmp instruction_assembled;
  simple_instruction_only64::
	cmp( code_type, 64 );
	jne illegal_instruction;
	jmp simple_instruction;
  simple_instruction_16bit_except64::
	cmp( code_type, 64 );
	je illegal_instruction;
  simple_instruction_16bit::
	cmp( code_type, 16 );
	jne size_prefix;
	stosb;
	jmp instruction_assembled;
	
  size_prefix:
	mov( al, ah );
	mov( $66, al );
	stosw;
	jmp instruction_assembled;
	
  simple_instruction_32bit_except64::
	cmp( code_type, 64 );
	je illegal_instruction;
  simple_instruction_32bit::
	cmp( code_type, 16 );
	je size_prefix;
	stosb;
	jmp instruction_assembled;
  simple_instruction_64bit::
	cmp( code_type, 64 );
	jne illegal_instruction;
	mov( al, ah );
	mov( $48, al );
	stosw;
	jmp instruction_assembled;
	
  simple_extended_instruction::
	mov( al, ah );
	mov( $0F, al );
	stosw;
	jmp instruction_assembled;
	
  prefix_instruction::
	stosb;
	or( -1, prefixed_instruction );
	jmp continue_line;
  segment_prefix:
	mov( al, ah );
	shr( 4, ah );
	cmp( ah, 6 );
	jne illegal_instruction;
	and( %1111, al );
	mov( al, segment_register );
	call store_segment_prefix;
	or( -1, prefixed_instruction );
	jmp continue_line;
  int_instruction::
	lodsb;
	call get_size_operator;
	cmp( ah, 1 );
	ja invalid_operand_size;
	cmp( al, '(' );
	jne invalid_operand;
	call get_byte_value;
	mov( al, ah );
	mov( $0CD, al );
	stosw;
	jmp instruction_assembled;
  iret_instruction::
	cmp( code_type, 64 );
	jne simple_instruction;
	call operand_64bit;
	jmp simple_instruction;
  aa_instruction::
	cmp( code_type, 64 );
	je illegal_instruction;
	push( eax );
	mov( 10, bl );
	cmp( (type byte [esi]), '(' );
	jne aa_store;
	inc( esi );
	xor( al, al );
	xchg( operand_size, al );
	cmp( al, 1 );
	ja invalid_operand_size;
	call get_byte_value;
	mov( al, bl );
  aa_store:
	cmp( operand_size, 0 );
	jne invalid_operand;
	pop( eax );
	mov( bl, ah );
	stosw;
	jmp instruction_assembled;

  basic_instruction::
	mov( al, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je basic_reg;
	cmp( al, '[' );
	jne invalid_operand;
	
  basic_mem:
	call get_address;
	push( edx );
	push( bx );
	push( cx );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	je basic_mem_imm;
	cmp( al, $10 );
	jne invalid_operand;
	
  basic_mem_reg:
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	pop( cx );
	pop( bx );
	pop( edx );
	mov( ah, al );
	cmp( al, 1 );
	je basic_mem_reg_8bit;
	call operand_autodetect;
	inc( base_code );
	
  basic_mem_reg_8bit:
	call store_instruction;
	jmp instruction_assembled;
	
  basic_mem_imm:
	mov( operand_size, al );
	cmp( al, 1 );
	je basic_mem_imm_8bit;
	cmp( al, 2 );
	je basic_mem_imm_16bit;
	cmp( al, 4 );
	je basic_mem_imm_32bit;
	cmp( al, 8 );
	je basic_mem_imm_64bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( error_line, 0 );
	jne basic_mem_imm_8bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
	
  basic_mem_imm_8bit:
	call get_byte_value;
	mov( al, (type byte value) );
	mov( base_code, al );
	shr( 3, al );
	mov( al, postbyte_register );
	pop( cx );
	pop( bx );
	pop( edx );
	mov( $80, base_code );
	call store_instruction_with_imm8;
	jmp instruction_assembled;
	
  basic_mem_imm_16bit:
	call operand_16bit;
	call get_word_value;
	mov( ax, (type word value) );
	mov( base_code, al );
	shr( 3, al );
	mov( al, postbyte_register );
	pop( cx );
	pop( bx );
	pop( edx );
	cmp( value_type, 0 );
	jne basic_mem_imm_16bit_store;
	cmp( size_declared, 0 );
	jne basic_mem_imm_16bit_store;
	cmp( (type word value), $80 );
	jb basic_mem_simm_8bit;
	cmp( (type word value), _word(-$80) );
	jae basic_mem_simm_8bit;
	
  basic_mem_imm_16bit_store:
	mov( $81, base_code );
	call store_instruction_with_imm16;
	jmp instruction_assembled;
	
  basic_mem_simm_8bit:
	mov( $83, base_code );
	call store_instruction_with_imm8;
	jmp instruction_assembled;
	
  basic_mem_imm_32bit:
	call operand_32bit;
	call get_dword_value;
	
  basic_mem_imm_32bit_ok:
	mov( eax, (type dword value) );
	mov( base_code, al );
	shr( 3, al );
	mov( al, postbyte_register );
	pop( cx );
	pop( bx );
	pop( edx );
	cmp( value_type, 0 );
	jne basic_mem_imm_32bit_store;
	cmp( size_declared, 0 );
	jne basic_mem_imm_32bit_store;
	cmp( (type dword value), $80 );
	jb basic_mem_simm_8bit;
	cmp( (type dword value), -$80 );
	jae basic_mem_simm_8bit;
	
  basic_mem_imm_32bit_store:
	mov( $81, base_code );
	call store_instruction_with_imm32;
	jmp instruction_assembled;
	
  basic_mem_imm_64bit:
	cmp( size_declared, 0 );
	jne long_immediate_not_encodable;
	
	call operand_64bit;
	call get_simm32;
	cmp( value_type, 4 );
	jae long_immediate_not_encodable;
	jmp basic_mem_imm_32bit_ok;
	

  basic_reg:
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je basic_reg_reg;
	
	cmp( al, '(' );
	je basic_reg_imm;
	
	cmp( al, '[' );
	jne invalid_operand;
	
  basic_reg_mem:
	call get_address;
	mov( operand_size, al );
	cmp( al, 1 );
	je basic_reg_mem_8bit;
	call operand_autodetect;
	add( 3, base_code );
	call store_instruction;
	jmp instruction_assembled;
	
  basic_reg_mem_8bit:
	add( 2, base_code );
	call store_instruction;
	jmp instruction_assembled;
	
  basic_reg_reg:
	lodsb;
	call convert_register;
	mov( postbyte_register, bl );
	mov( al, postbyte_register );
	mov( ah, al );
	cmp( al, 1 );
	je basic_reg_reg_8bit;
	call operand_autodetect;
	inc( base_code );
	
  basic_reg_reg_8bit:
	call store_nomem_instruction;
	jmp instruction_assembled;
	
  basic_reg_imm:
	mov( operand_size, al );
	cmp( al, 1 );
	je basic_reg_imm_8bit;
	cmp( al, 2 );
	je basic_reg_imm_16bit;
	cmp( al, 4 );
	je basic_reg_imm_32bit;
	cmp( al, 8 );
	je basic_reg_imm_64bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( error_line, 0 );
	jne basic_reg_imm_32bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
	jmp basic_reg_imm_32bit;
	
  basic_reg_imm_8bit:
	call get_byte_value;
	mov( al, dl );
	mov( base_code, bl );
	shr( 3, bl );
	xchg( postbyte_register, bl );
	or( bl, bl );
	jz basic_al_imm;
	mov( $80, base_code );
	call store_nomem_instruction;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
	
  basic_al_imm:
	mov( base_code, al );
	add( 4, al );
	stosb;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
	
  basic_reg_imm_16bit:
	call operand_16bit;
	call get_word_value;
	mov( ax, dx );
	mov( base_code, bl );
	shr( 3, bl );
	xchg( postbyte_register, bl );
	cmp( value_type, 0 );
	jne basic_reg_imm_16bit_store;
	cmp( size_declared, 0 );
	jne basic_reg_imm_16bit_store;
	cmp( dx, $80 );
	jb basic_reg_simm_8bit;
	cmp( dx, _word(-$80) );
	jae basic_reg_simm_8bit;
	
  basic_reg_imm_16bit_store:
	or( bl, bl );
	jz basic_ax_imm;
	mov( $81, base_code );
	call store_nomem_instruction;
	mov( dx, ax );
	call mark_relocation;
	stosw;
	jmp instruction_assembled;
	
  basic_reg_simm_8bit:
	mov( $83, base_code );
	call store_nomem_instruction;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
	
  basic_ax_imm:
	add( 5, base_code );
	call store_instruction_code;
	mov( dx, ax );
	call mark_relocation;
	stosw;
	jmp instruction_assembled;
	
  basic_reg_imm_32bit:
	call operand_32bit;
	call get_dword_value;
	
  basic_reg_imm_32bit_ok:
	mov( eax, edx );
	mov( base_code, bl );
	shr( 3, bl );
	xchg( postbyte_register, bl );
	cmp( value_type, 0 );
	jne basic_reg_imm_32bit_store;
	cmp( size_declared, 0 );
	jne basic_reg_imm_32bit_store;
	cmp( edx, $80 );
	jb basic_reg_simm_8bit;
	cmp( edx, -$80 );
	jae basic_reg_simm_8bit;
	
  basic_reg_imm_32bit_store:
	or( bl, bl );
	jz basic_eax_imm;
	mov( $81, base_code );
	call store_nomem_instruction;
	mov( edx, eax );
	call mark_relocation;
	stosd;
	jmp instruction_assembled;
	
  basic_eax_imm:
	add( 5, base_code );
	call store_instruction_code;
	mov( edx, eax );
	call mark_relocation;
	stosd;
	jmp instruction_assembled;
	
  basic_reg_imm_64bit:
	cmp( size_declared, 0 );
	jne long_immediate_not_encodable;
	call operand_64bit;
	call get_simm32;
	cmp( value_type, 4 );
	jae long_immediate_not_encodable;
	jmp basic_reg_imm_32bit_ok;
	
  single_operand_instruction::
	mov( $0F6, base_code );
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je single_reg;
	cmp( al, '[' );
	jne invalid_operand;
	
  single_mem:
	call get_address;
	mov( operand_size, al );
	cmp( al, 1 );
	je single_mem_8bit;
	jb single_mem_nosize;
	call operand_autodetect;
	inc( base_code );
	call store_instruction;
	jmp instruction_assembled;
	
  single_mem_nosize:
	cmp( error_line, 0 );
	jne single_mem_8bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
	
  single_mem_8bit:
	call store_instruction;
	jmp instruction_assembled;
	
  single_reg:
	lodsb;
	call convert_register;
	mov( al, bl );
	mov( ah, al );
	cmp( al, 1 );
	je single_reg_8bit;
	call operand_autodetect;
	inc( base_code );
	
  single_reg_8bit:
	call store_nomem_instruction;
	jmp instruction_assembled;
	
  mov_instruction::
	mov( $88, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je mov_reg;
	cmp( al, '[' );
	jne invalid_operand;
	
  mov_mem:
	call get_address;
	push( edx );
	push( bx );
	push( cx );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	je mov_mem_imm;
	cmp( al, $10 );
	jne invalid_operand;
	
  mov_mem_reg:
	lodsb;
	cmp( al, $60 );
	jb mov_mem_general_reg;
	cmp( al, $70 );
	jb mov_mem_sreg;
	
  mov_mem_general_reg:
	call convert_register;
	mov( al, postbyte_register );
	pop( cx );
	pop( bx );
	pop( edx );
	cmp( ah, 1 );
	je mov_mem_reg_8bit;
	
	// 16/32-bit gp register.
	
	mov( ah, al );
	call operand_autodetect;
	mov( postbyte_register, al );
	or( bl, al );
	or( bh, al );
	jz mov_mem_ax;
	inc( base_code );
	call store_instruction;
	jmp instruction_assembled;
	
  mov_mem_reg_8bit:
	or( bl, al );
	or( bh, al );
	jz mov_mem_al;
	call store_instruction;
	jmp instruction_assembled;
	
  mov_mem_al:
	test( $22, ch );
	jnz mov_mem_address16_al;
	test( $44, ch );
	jnz mov_mem_address32_al;
	test( $88, ch );
	jnz mov_mem_address64_al;
	or( ch, ch );
	jnz invalid_address_size;
	cmp( code_type, 64 );
	je mov_mem_address64_al;
	cmp( code_type, 32 );
	je mov_mem_address32_al;
	cmp( edx, $10000 );
	jb mov_mem_address16_al;
	
  mov_mem_address32_al:
	call store_segment_prefix_if_necessary;
	call address_32bit_prefix;
	mov( $0A2, base_code );
	
  store_mov_address32:
	call store_instruction_code;
	pushd( &instruction_assembled );
	jmp store_address_32bit_value;
	
  mov_mem_address16_al:
	call store_segment_prefix_if_necessary;
	call address_16bit_prefix;
	mov( $0A2, base_code );
	
  store_mov_address16:
	cmp( code_type, 64 );
	je invalid_address;
	
	call store_instruction_code;
	mov( edx, eax );
	stosw;
	cmp( edx, $10000 );
	jge value_out_of_range;
	jmp instruction_assembled;
	
  mov_mem_address64_al:
	call store_segment_prefix_if_necessary;
	mov( $0A2, base_code );
	
  store_mov_address64:
	call store_instruction_code;
	pushd( &instruction_assembled );
	jmp store_address_64bit_value;
	
  mov_mem_ax:
	test( $22, ch );
	jnz mov_mem_address16_ax;
	
	test( $44, ch );
	jnz mov_mem_address32_ax;
	
	test( $88, ch );
	jnz mov_mem_address64_ax;
	
	or( ch, ch );
	jnz invalid_address_size;
	
	cmp( code_type, 64 );
	je mov_mem_address64_ax;
	
	cmp( code_type, 32 );
	je mov_mem_address32_ax;
	
	cmp( edx, $10000 );
	jb mov_mem_address16_ax;
	
  mov_mem_address32_ax:
	call store_segment_prefix_if_necessary;
	call address_32bit_prefix;
	mov( $0A3, base_code );
	jmp store_mov_address32;
	
  mov_mem_address16_ax:
	call store_segment_prefix_if_necessary;
	call address_16bit_prefix;
	mov( $0A3, base_code );
	jmp store_mov_address16;
	
  mov_mem_address64_ax:
	call store_segment_prefix_if_necessary;
	mov( $0A3, base_code );
	jmp store_mov_address64;
	
  mov_mem_sreg:
	sub( $61, al );
	mov( al, postbyte_register );
	pop( cx );
	pop( bx );
	pop( edx );
	mov( operand_size, ah );
	or( ah, ah );
	jz mov_mem_sreg_store;
	cmp( ah, 2 );
	jne invalid_operand_size;
	
  mov_mem_sreg_store:
	mov( $8C, base_code );
	call store_instruction;
	jmp instruction_assembled;
	
  mov_mem_imm:
	mov( operand_size, al );
	cmp( al, 1 );
	je mov_mem_imm_8bit;
	
	cmp( al, 2 );
	je mov_mem_imm_16bit;
	
	cmp( al, 4 );
	je mov_mem_imm_32bit;
	
	cmp( al, 8 );
	je mov_mem_imm_64bit;
	
	or( al, al );
	jnz invalid_operand_size;
	
	cmp( error_line, 0 );
	jne mov_mem_imm_32bit;
	
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
	jmp mov_mem_imm_32bit;
	
  mov_mem_imm_8bit:
	call get_byte_value;
	mov( al, (type byte value) );
	mov( 0, postbyte_register );
	mov( $0C6, base_code );
	pop( cx );
	pop( bx );
	pop( edx );
	call store_instruction_with_imm8;
	jmp instruction_assembled;
	
  mov_mem_imm_16bit:
	call operand_16bit;
	call get_word_value;
	mov( ax, (type word value) );
	mov( 0, postbyte_register );
	mov( $0C7, base_code );
	pop( cx );
	pop( bx );
	pop( edx );
	call store_instruction_with_imm16;
	jmp instruction_assembled;
	
  mov_mem_imm_32bit:
	call operand_32bit;
	call get_dword_value;
	
  mov_mem_imm_32bit_store:
	mov( eax, (type dword value) );
	mov( 0, postbyte_register );
	mov( $0C7, base_code );
	pop( cx );
	pop( bx );
	pop( edx );
	call store_instruction_with_imm32;
	jmp instruction_assembled;
	
  mov_mem_imm_64bit:
	cmp( size_declared, 0 );
	jne long_immediate_not_encodable;
	call operand_64bit;
	call get_simm32;
	cmp( value_type, 4 );
	jae long_immediate_not_encodable;
	jmp mov_mem_imm_32bit_store;
	
  mov_reg:
	lodsb;
	mov( al, ah );
	sub( $10, ah );
	and( al, ah );
	test( $0F0, ah );
	jnz mov_sreg;
	
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	je mov_reg_mem;
	
	cmp( al, '(' );
	je mov_reg_imm;
	
	cmp( al, $10 );
	jne invalid_operand;
	
  mov_reg_reg:
	lodsb;
	mov( al, ah );
	sub( $10, ah );
	and( al, ah );
	test( $0F0, ah );
	jnz mov_reg_sreg;
	
	call convert_register;
	mov( postbyte_register, bl );
	mov( al, postbyte_register );
	mov( ah, al );
	cmp( al, 1 );
	je mov_reg_reg_8bit;
	
	call operand_autodetect;
	inc( base_code );
	
  mov_reg_reg_8bit:
	call store_nomem_instruction;
	jmp instruction_assembled;
	
  mov_reg_sreg:
	mov( postbyte_register, bl );
	mov( al, ah );
	and( %1111, al );
	mov( al, postbyte_register );
	shr( 4, ah );
	cmp( ah, 5 );
	je mov_reg_creg;
	cmp( ah, 7 );
	je mov_reg_dreg;
	ja mov_reg_treg;
	dec( postbyte_register );
	cmp( operand_size, 8 );
	je mov_reg_sreg64;
	cmp( operand_size, 4 );
	je mov_reg_sreg32;
	cmp( operand_size, 2 );
	jne invalid_operand_size;
	call operand_16bit;
	jmp mov_reg_sreg_store;
  mov_reg_sreg64:
	call operand_64bit;
	jmp mov_reg_sreg_store;
  mov_reg_sreg32:
	call operand_32bit;
  mov_reg_sreg_store:
	mov( $8C, base_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  mov_reg_treg:
	cmp( ah, 9 );
	jne invalid_operand;
	mov( $24, extended_code );
	jmp mov_reg_xrx;
  mov_reg_dreg:
	mov( $21, extended_code );
	jmp mov_reg_xrx;
  mov_reg_creg:
	mov( $20, extended_code );
  mov_reg_xrx:
	mov( $0F, base_code );
	cmp( code_type, 64 );
	je mov_reg_xrx_64bit;
	cmp( operand_size, 4 );
	jne invalid_operand_size;
	call store_nomem_instruction;
	jmp instruction_assembled;
  mov_reg_xrx_64bit:
	cmp( operand_size, 8 );
	jne invalid_operand_size;
	call store_nomem_instruction;
	jmp instruction_assembled;
  mov_reg_mem:
	call get_address;
	mov( operand_size, al );
	cmp( al, 1 );
	je mov_reg_mem_8bit;
	call operand_autodetect;
	mov( postbyte_register, al );
	or( bl, al );
	or( bh, al );
	jz mov_ax_mem;
	add( 3, base_code );
	call store_instruction;
	jmp instruction_assembled;
  mov_reg_mem_8bit:
	mov( postbyte_register, al );
	or( bl, al );
	or( bh, al );
	jz mov_al_mem;
	add( 2, base_code );
	call store_instruction;
	jmp instruction_assembled;
  mov_al_mem:
	test( $22, ch );
	jnz mov_al_mem_address16;
	test( $44, ch );
	jnz mov_al_mem_address32;
	test( $88, ch );
	jnz mov_al_mem_address64;
	or( ch, ch );
	jnz invalid_address_size;
	cmp( code_type, 64 );
	je mov_al_mem_address64;
	cmp( code_type, 32 );
	je mov_al_mem_address32;
	cmp( edx, $10000 );
	jb mov_al_mem_address16;
  mov_al_mem_address32:
	call store_segment_prefix_if_necessary;
	call address_32bit_prefix;
	mov( $0A0, base_code );
	jmp store_mov_address32;
  mov_al_mem_address16:
	call store_segment_prefix_if_necessary;
	call address_16bit_prefix;
	mov( $0A0, base_code );
	jmp store_mov_address16;
  mov_al_mem_address64:
	call store_segment_prefix_if_necessary;
	mov( $0A0, base_code );
	jmp store_mov_address64;
  mov_ax_mem:
	test( $22, ch );
	jnz mov_ax_mem_address16;
	test( $44, ch );
	jnz mov_ax_mem_address32;
	test( $88, ch );
	jnz mov_ax_mem_address64;
	or( ch, ch );
	jnz invalid_address_size;
	cmp( code_type, 64 );
	je mov_ax_mem_address64;
	cmp( code_type, 32 );
	je mov_ax_mem_address32;
	cmp( edx, $10000 );
	jb mov_ax_mem_address16;
  mov_ax_mem_address32:
	call store_segment_prefix_if_necessary;
	call address_32bit_prefix;
	mov( $0A1, base_code );
	jmp store_mov_address32;
  mov_ax_mem_address16:
	call store_segment_prefix_if_necessary;
	mov( $0A1, base_code );
	jmp store_mov_address16;
  mov_ax_mem_address64:
	call store_segment_prefix_if_necessary;
	mov( $0A1, base_code );
	jmp store_mov_address64;
  mov_reg_imm:
	mov( operand_size, al );
	cmp( al, 1 );
	je mov_reg_imm_8bit;
	cmp( al, 2 );
	je mov_reg_imm_16bit;
	cmp( al, 4 );
	je mov_reg_imm_32bit;
	cmp( al, 8 );
	je mov_reg_imm_64bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( error_line, 0 );
	jne mov_reg_imm_32bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
	jmp mov_reg_imm_32bit;
  mov_reg_imm_8bit:
	call get_byte_value;
	mov( al, dl );
	mov( $0B0, al );
	call store_mov_reg_imm_code;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
  mov_reg_imm_16bit:
	call get_word_value;
	mov( ax, dx );
	call operand_16bit;
	mov( $0B8, al );
	call store_mov_reg_imm_code;
	mov( dx, ax );
	call mark_relocation;
	stosw;
	jmp instruction_assembled;
  mov_reg_imm_32bit:
	call operand_32bit;
	call get_dword_value;
	mov( eax, edx );
	mov( $0B8, al );
	call store_mov_reg_imm_code;
	mov( edx, eax );
	call mark_relocation;
	stosd;
	jmp instruction_assembled;
  mov_reg_imm_64bit:
	call operand_64bit;
	call get_qword_value;
	mov( edx, ecx );
	cmp( size_declared, 0 );
	jne mov_reg_imm_64bit_store;
	cmp( value_type, 4 );
	jae mov_reg_imm_64bit_store;
	cdq;
	cmp( ecx, edx );
	je mov_reg_64bit_imm_32bit;
  mov_reg_imm_64bit_store:
	push( eax );
	push( ecx );
	mov( $0B8, al );
	call store_mov_reg_imm_code;
	pop( edx );
	pop( eax );
	call mark_relocation;
	stosd;
	mov( edx, eax );
	stosd;
	jmp instruction_assembled;
	
  mov_reg_64bit_imm_32bit:
	mov( eax, edx );
	mov( postbyte_register, bl );
	mov( 0, postbyte_register );
	mov( $0C7, base_code );
	call store_nomem_instruction;
	mov( edx, eax );
	call mark_relocation;
	stosd;
	jmp instruction_assembled;
  mov_sreg:
	mov( al, ah );
	and( %1111, al );
	mov( al, postbyte_register );
	shr( 4, ah );
	cmp( ah, 5 );
	je mov_creg;
	cmp( ah, 7 );
	je mov_dreg;
	ja mov_treg;
	cmp( al, 2 );
	je illegal_instruction;
	dec( postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	je mov_sreg_mem;
	cmp( al, $10 );
	jne invalid_operand;
  mov_sreg_reg:
	lodsb;
	call convert_register;
	or( ah, ah );
	jz mov_sreg_reg_size_ok;
	cmp( ah, 2 );
	jne invalid_operand_size;
	mov( al, bl );
  mov_sreg_reg_size_ok:
	mov( $8E, base_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  mov_sreg_mem:
	call get_address;
	mov( operand_size, al );
	or( al, al );
	jz mov_sreg_mem_size_ok;
	cmp( al, 2 );
	jne invalid_operand_size;
  mov_sreg_mem_size_ok:
	mov( $8E, base_code );
	call store_instruction;
	jmp instruction_assembled;
  mov_treg:
	cmp( ah, 9 );
	jne invalid_operand;
	mov( $26, extended_code );
	jmp mov_xrx;
  mov_dreg:
	mov( $23, extended_code );
	jmp mov_xrx;
  mov_creg:
	mov( $22, extended_code );
  mov_xrx:
	mov( $0F, base_code );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, bl );
	cmp( code_type, 64 );
	je mov_xrx_64bit;
	cmp( ah, 4 );
	jne invalid_operand_size;
	call store_nomem_instruction;
	jmp instruction_assembled;
  mov_xrx_64bit:
	cmp( ah, 8 );
	jne invalid_operand_size;
	call store_nomem_instruction;
	jmp instruction_assembled;
  cmov_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	je cmov_reg_mem;
	cmp( al, $10 );
	jne invalid_operand;
  cmov_reg_reg:
	lodsb;
	call convert_register;
	mov( al, bl );
	mov( ah, al );
	call operand_autodetect;
	call store_nomem_instruction;
	jmp instruction_assembled;
  cmov_reg_mem:
	call get_address;
	mov( operand_size, al );
	call operand_autodetect;
	call store_instruction;
	jmp instruction_assembled;
  test_instruction::
	mov( $84, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je test_reg;
	cmp( al, '[' );
	jne invalid_operand;
  test_mem:
	call get_address;
	push( edx );
	push( bx );
	push( cx );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	je test_mem_imm;
	cmp( al, $10 );
	jne invalid_operand;
  test_mem_reg:
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	pop( cx );
	pop( bx );
	pop( edx );
	mov( ah, al );
	cmp( al, 1 );
	je test_mem_reg_8bit;
	call operand_autodetect;
	inc( base_code );
  test_mem_reg_8bit:
	call store_instruction;
	jmp instruction_assembled;
  test_mem_imm:
	mov( operand_size, al );
	cmp( al, 1 );
	je test_mem_imm_8bit;
	cmp( al, 2 );
	je test_mem_imm_16bit;
	cmp( al, 4 );
	je test_mem_imm_32bit;
	cmp( al, 8 );
	je test_mem_imm_64bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( error_line, 0 );
	jne test_mem_imm_32bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
	jmp test_mem_imm_32bit;
  test_mem_imm_8bit:
	call get_byte_value;
	mov( al, (type byte value) );
	mov( 0, postbyte_register );
	mov( $0F6, base_code );
	pop( cx );
	pop( bx );
	pop( edx );
	call store_instruction_with_imm8;
	jmp instruction_assembled;
  test_mem_imm_16bit:
	call operand_16bit;
	call get_word_value;
	mov( ax, (type word value) );
	mov( 0, postbyte_register );
	mov( $0F7, base_code );
	pop( cx );
	pop( bx );
	pop( edx );
	call store_instruction_with_imm16;
	jmp instruction_assembled;
  test_mem_imm_32bit:
	call operand_32bit;
	call get_dword_value;
  test_mem_imm_32bit_store:
	mov( eax, (type dword value) );
	mov( 0, postbyte_register );
	mov( $0F7, base_code );
	pop( cx );
	pop( bx );
	pop( edx );
	call store_instruction_with_imm32;
	jmp instruction_assembled;
  test_mem_imm_64bit:
	cmp( size_declared, 0 );
	jne long_immediate_not_encodable;
	call operand_64bit;
	call get_simm32;
	cmp( value_type, 4 );
	jae long_immediate_not_encodable;
	jmp test_mem_imm_32bit_store;
  test_reg:
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	je test_reg_mem;
	cmp( al, '(' );
	je test_reg_imm;
	cmp( al, $10 );
	jne invalid_operand;
  test_reg_reg:
	lodsb;
	call convert_register;
	mov( postbyte_register, bl );
	mov( al, postbyte_register );
	mov( ah, al );
	cmp( al, 1 );
	je test_reg_reg_8bit;
	call operand_autodetect;
	inc( base_code );
  test_reg_reg_8bit:
	call store_nomem_instruction;
	jmp instruction_assembled;
  test_reg_imm:
	mov( operand_size, al );
	cmp( al, 1 );
	je test_reg_imm_8bit;
	cmp( al, 2 );
	je test_reg_imm_16bit;
	cmp( al, 4 );
	je test_reg_imm_32bit;
	cmp( al, 8 );
	je test_reg_imm_64bit;
	jmp invalid_operand_size;
  test_reg_imm_8bit:
	call get_byte_value;
	mov( al, dl );
	mov( postbyte_register, bl );
	mov( 0, postbyte_register );
	mov( $0F6, base_code );
	or( bl, bl );
	jz test_al_imm;
	call store_nomem_instruction;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
  test_al_imm:
	mov( $0A8, base_code );
	call store_instruction_code;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
  test_reg_imm_16bit:
	call operand_16bit;
	call get_word_value;
	mov( ax, dx );
	mov( postbyte_register, bl );
	mov( 0, postbyte_register );
	mov( $0F7, base_code );
	or( bl, bl );
	jz test_ax_imm;
	call store_nomem_instruction;
	mov( dx, ax );
	call mark_relocation;
	stosw;
	jmp instruction_assembled;
  test_ax_imm:
	mov( $0A9, base_code );
	call store_instruction_code;
	mov( dx, ax );
	stosw;
	jmp instruction_assembled;
  test_reg_imm_32bit:
	call operand_32bit;
	call get_dword_value;
  test_reg_imm_32bit_store:
	mov( eax, edx );
	mov( postbyte_register, bl );
	mov( 0, postbyte_register );
	mov( $0F7, base_code );
	or( bl, bl );
	jz test_eax_imm;
	call store_nomem_instruction;
	mov( edx, eax );
	call mark_relocation;
	stosd;
	jmp instruction_assembled;
  test_eax_imm:
	mov( $0A9, base_code );
	call store_instruction_code;
	mov( edx, eax );
	stosd;
	jmp instruction_assembled;
  test_reg_imm_64bit:
	cmp( size_declared, 0 );
	jne long_immediate_not_encodable;
	call operand_64bit;
	call get_simm32;
	cmp( value_type, 4 );
	jae long_immediate_not_encodable;
	jmp test_reg_imm_32bit_store;
  test_reg_mem:
	call get_address;
	mov( operand_size, al );
	cmp( al, 1 );
	je test_reg_mem_8bit;
	call operand_autodetect;
	inc( base_code );
  test_reg_mem_8bit:
	call store_instruction;
	jmp instruction_assembled;
  xchg_instruction::
	mov( $86, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je xchg_reg;
	cmp( al, '[' );
	jne invalid_operand;
  xchg_mem:
	call get_address;
	push( edx );
	push( bx );
	push( cx );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je test_mem_reg;
	jmp invalid_operand;
  xchg_reg:
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	je test_reg_mem;
	cmp( al, $10 );
	jne invalid_operand;
  xchg_reg_reg:
	lodsb;
	call convert_register;
	mov( al, bl );
	mov( ah, al );
	cmp( al, 1 );
	je xchg_reg_reg_8bit;
	call operand_autodetect;
	cmp( postbyte_register, 0 );
	je xchg_ax_reg;
	or( bl, bl );
	jnz xchg_reg_reg_store;
	mov( postbyte_register, bl );
  xchg_ax_reg:
	cmp( code_type, 64 );
	jne xchg_ax_reg_ok;
	cmp( ah, 4 );
	jne xchg_ax_reg_ok;
	or( bl, bl );
	jz xchg_reg_reg_store;
  xchg_ax_reg_ok:
	test( %1000, bl );
	jz xchg_ax_reg_store;
	or( $41, rex_prefix );
	and( %111, bl );
  xchg_ax_reg_store:
	add( $90, bl );
	mov( bl, base_code );
	call store_instruction_code;
	jmp instruction_assembled;
  xchg_reg_reg_store:
	inc( base_code );
  xchg_reg_reg_8bit:
	call store_nomem_instruction;
	jmp instruction_assembled;
  push_instruction::
	mov( al, push_size );
  push_next:
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je push_reg;
	cmp( al, '(' );
	je push_imm;
	cmp( al, '[' );
	jne invalid_operand;
  push_mem:
	call get_address;
	mov( operand_size, al );
	mov( push_size, ah );
	cmp( al, 2 );
	je push_mem_16bit;
	cmp( al, 4 );
	je push_mem_32bit;
	cmp( al, 8 );
	je push_mem_64bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( ah, 2 );
	je push_mem_16bit;
	cmp( ah, 4 );
	je push_mem_32bit;
	cmp( ah, 8 );
	je push_mem_64bit;
	cmp( error_line, 0 );
	jne push_mem_store;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
	jmp push_mem_store;
  push_mem_16bit:
	test( _byte( !2 ), ah );
	jnz invalid_operand_size;
	call operand_16bit;
	jmp push_mem_store;
  push_mem_32bit:
	test( _byte( !4 ), ah );
	jnz invalid_operand_size;
	cmp( code_type, 64 );
	je illegal_instruction;
	call operand_32bit;
	jmp push_mem_store;
  push_mem_64bit:
	test( _byte( !8 ), ah );
	jnz invalid_operand_size;
	cmp( code_type, 64 );
	jne illegal_instruction;
  push_mem_store:
	mov( $0FF, base_code );
	mov( %110, postbyte_register );
	call store_instruction;
	jmp push_done;
  push_reg:
	lodsb;
	mov( al, ah );
	sub( $10, ah );
	and( al, ah );
	test( $0F0, ah );
	jnz push_sreg;
	call convert_register;
	test( %1000, al );
	jz push_reg_ok;
	or( $41, rex_prefix );
	and( %111, al );
  push_reg_ok:
	add( $50, al );
	mov( al, base_code );
	mov( ah, al );
	mov( push_size, ah );
	cmp( al, 2 );
	je push_reg_16bit;
	cmp( al, 4 );
	je push_reg_32bit;
	cmp( al, 8 );
	jne invalid_operand_size;
  push_reg_64bit:
	test( _byte( !8 ), ah );
	jnz invalid_operand_size;
	cmp( code_type, 64 );
	jne illegal_instruction;
	jmp push_reg_store;
  push_reg_32bit:
	test( _byte( !4 ), ah );
	jnz invalid_operand_size;
	cmp( code_type, 64 );
	je illegal_instruction;
	call operand_32bit;
	jmp push_reg_store;
  push_reg_16bit:
	test( _byte( !2 ), ah );
	jnz invalid_operand_size;
	call operand_16bit;
  push_reg_store:
	call store_instruction_code;
	jmp push_done;
  push_sreg:
	mov( al, bl );
	mov( operand_size, dl );
	mov( push_size, dh );
	cmp( dl, 2 );
	je push_sreg16;
	cmp( dl, 4 );
	je push_sreg32;
	cmp( dl, 8 );
	je push_sreg64;
	or( dl, dl );
	jnz invalid_operand_size;
	cmp( dh, 2 );
	je push_sreg16;
	cmp( dh, 4 );
	je push_sreg32;
	cmp( dh, 8 );
	je push_sreg64;
	jmp push_sreg_store;
  push_sreg16:
	test( _byte( !2 ), dh );
	jnz invalid_operand_size;
	call operand_16bit;
	jmp push_sreg_store;
  push_sreg32:
	test( _byte( !4 ), dh );
	jnz invalid_operand_size;
	cmp( code_type, 64 );
	je illegal_instruction;
	call operand_32bit;
	jmp push_sreg_store;
  push_sreg64:
	test( _byte( !8 ), dh );
	jnz invalid_operand_size;
	cmp( code_type, 64 );
	jne illegal_instruction;
  push_sreg_store:
	mov( bl, al );
	cmp( al, $70 );
	jae invalid_operand;
	sub( $61, al );
	cmp( al, 4 );
	jae push_sreg_386;
	shl( 3, al );
	add( 6, al );
	mov( al, base_code );
	cmp( code_type, 64 );
	je illegal_instruction;
	jmp push_reg_store;
  push_sreg_386:
	sub( 4, al );
	shl( 3, al );
	add( $0A0, al );
	mov( al, extended_code );
	mov( $0F, base_code );
	jmp push_reg_store;
  push_imm:
	mov( operand_size, al );
	mov( push_size, ah );
	or( al, al );
	je push_imm_size_ok;
	or( ah, ah );
	je push_imm_size_ok;
	cmp( al, ah );
	jne invalid_operand_size;
  push_imm_size_ok:
	cmp( al, 2 );
	je push_imm_16bit;
	cmp( al, 4 );
	je push_imm_32bit;
	cmp( al, 8 );
	je push_imm_64bit;
	cmp( ah, 2 );
	je push_imm_optimized_16bit;
	cmp( ah, 4 );
	je push_imm_optimized_32bit;
	cmp( ah, 8 );
	je push_imm_optimized_64bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( code_type, 16 );
	je push_imm_optimized_16bit;
	cmp( code_type, 32 );
	je push_imm_optimized_32bit;
  push_imm_optimized_64bit:
	cmp( code_type, 64 );
	jne illegal_instruction;
	call get_simm32;
	mov( eax, edx );
	cmp( value_type, 0 );
	jne push_imm_32bit_store;
	cmp( eax, -$80 );
	jl push_imm_32bit_store;
	cmp( eax, $80 );
	jge push_imm_32bit_store;
	jmp push_imm_8bit;
  push_imm_optimized_32bit:
	cmp( code_type, 64 );
	je illegal_instruction;
	call get_dword_value;
	mov( eax, edx );
	call operand_32bit;
	cmp( value_type, 0 );
	jne push_imm_32bit_store;
	cmp( eax, -$80 );
	jl push_imm_32bit_store;
	cmp( eax, $80 );
	jge push_imm_32bit_store;
	jmp push_imm_8bit;
  push_imm_optimized_16bit:
	call get_word_value;
	mov( ax, dx );
	call operand_16bit;
	cmp( value_type, 0 );
	jne push_imm_16bit_store;
	cmp( ax, _word(-$80) );
	jl push_imm_16bit_store;
	cmp( ax, $80 );
	jge push_imm_16bit_store;
  push_imm_8bit:
	mov( al, ah );
	mov( $6A, base_code );
	call store_instruction_code;
	mov( ah, al );
	stosb;
	jmp push_done;
  push_imm_16bit:
	call get_word_value;
	mov( ax, dx );
	call operand_16bit;
  push_imm_16bit_store:
	mov( $68, base_code );
	call store_instruction_code;
	mov( dx, ax );
	call mark_relocation;
	stosw;
	jmp push_done;
  push_imm_64bit:
	cmp( code_type, 64 );
	jne illegal_instruction;
	call get_simm32;
	mov( eax, edx );
	jmp push_imm_32bit_store;
  push_imm_32bit:
	cmp( code_type, 64 );
	je illegal_instruction;
	call get_dword_value;
	mov( eax, edx );
	call operand_32bit;
  push_imm_32bit_store:
	mov( $68, base_code );
	call store_instruction_code;
	mov( edx, eax );
	call mark_relocation;
	stosd;
  push_done:
	lodsb;
	dec( esi );
	cmp( al, $0F );
	je instruction_assembled;
	or( al, al );
	jz instruction_assembled;
	mov( 0, operand_size );
	mov( 0, size_override );
	mov( 0, operand_prefix );
	mov( 0, rex_prefix );
	jmp push_next;
  pop_instruction::
	mov( al, push_size );
  pop_next:
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je pop_reg;
	cmp( al, '[' );
	jne invalid_operand;
  pop_mem:
	call get_address;
	mov( operand_size, al );
	mov( push_size, ah );
	cmp( al, 2 );
	je pop_mem_16bit;
	cmp( al, 4 );
	je pop_mem_32bit;
	cmp( al, 8 );
	je pop_mem_64bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( ah, 2 );
	je pop_mem_16bit;
	cmp( ah, 4 );
	je pop_mem_32bit;
	cmp( ah, 8 );
	je pop_mem_64bit;
	cmp( error_line, 0 );
	jne pop_mem_store;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
	jmp pop_mem_store;
  pop_mem_16bit:
	test( _byte( !2 ), ah );
	jnz invalid_operand_size;
	call operand_16bit;
	jmp pop_mem_store;
  pop_mem_32bit:
	test( _byte( !4 ), ah );
	jnz invalid_operand_size;
	cmp( code_type, 64 );
	je illegal_instruction;
	call operand_32bit;
	jmp pop_mem_store;
  pop_mem_64bit:
	test( _byte( !8 ), ah );
	jnz invalid_operand_size;
	cmp( code_type, 64 );
	jne illegal_instruction;
  pop_mem_store:
	mov( $08F, base_code );
	mov( 0, postbyte_register );
	call store_instruction;
	jmp pop_done;
  pop_reg:
	lodsb;
	mov( al, ah );
	sub( $10, ah );
	and( al, ah );
	test( $0F0, ah );
	jnz pop_sreg;
	call convert_register;
	test( %1000, al );
	jz pop_reg_ok;
	or( $41, rex_prefix );
	and( %111, al );
  pop_reg_ok:
	add( $58, al );
	mov( al, base_code );
	mov( ah, al );
	mov( push_size, ah );
	cmp( al, 2 );
	je pop_reg_16bit;
	cmp( al, 4 );
	je pop_reg_32bit;
	cmp( al, 8 );
	je pop_reg_64bit;
	jmp invalid_operand_size;
  pop_reg_64bit:
	test( _byte( !8 ), ah );
	jnz invalid_operand_size;
	cmp( code_type, 64 );
	jne illegal_instruction;
	jmp pop_reg_store;
  pop_reg_32bit:
	test( _byte( !4 ), ah );
	jnz invalid_operand_size;
	cmp( code_type, 64 );
	je illegal_instruction;
	call operand_32bit;
	jmp pop_reg_store;
  pop_reg_16bit:
	test( _byte( !2 ), ah );
	jnz invalid_operand_size;
	call operand_16bit;
  pop_reg_store:
	call store_instruction_code;
  pop_done:
	lodsb;
	dec( esi );
	cmp( al, $0F );
	je instruction_assembled;
	or( al, al );
	jz instruction_assembled;
	mov( 0, operand_size );
	mov( 0, size_override );
	mov( 0, operand_prefix );
	mov( 0, rex_prefix );
	jmp pop_next;
  pop_sreg:
	mov( operand_size, dl );
	mov( push_size, dh );
	cmp( al, $62 );
	je pop_cs;
	mov( al, bl );
	cmp( dl, 2 );
	je pop_sreg16;
	cmp( dl, 4 );
	je pop_sreg32;
	cmp( dl, 8 );
	je pop_sreg64;
	or( dl, dl );
	jnz invalid_operand_size;
	cmp( dh, 2 );
	je pop_sreg16;
	cmp( dh, 4 );
	je pop_sreg32;
	cmp( dh, 8 );
	je pop_sreg64;
	jmp pop_sreg_store;
  pop_sreg16:
	test( _byte( !2 ), dh );
	jnz invalid_operand_size;
	call operand_16bit;
	jmp pop_sreg_store;
  pop_sreg32:
	test( _byte( !4 ), dh );
	jnz invalid_operand_size;
	cmp( code_type, 64 );
	je illegal_instruction;
	call operand_32bit;
	jmp pop_sreg_store;
  pop_sreg64:
	test( _byte( !8 ), dh );
	jnz invalid_operand_size;
	cmp( code_type, 64 );
	jne illegal_instruction;
  pop_sreg_store:
	mov( bl, al );
	cmp( al, $70 );
	jae invalid_operand;
	sub( $61, al );
	cmp( al, 4 );
	jae pop_sreg_386;
	shl( 3, al );
	add( 7, al );
	mov( al, base_code );
	cmp( code_type, 64 );
	je illegal_instruction;
	jmp pop_reg_store;
  pop_cs:
	cmp( code_type, 16 );
	jne illegal_instruction;
	cmp( dl, 2 );
	je pop_cs_store;
	or( dl, dl );
	jnz invalid_operand_size;
	cmp( dh, 2 );
	je pop_cs_store;
	or( dh, dh );
	jnz illegal_instruction;
  pop_cs_store:
	test( _byte( !2 ), dh );
	jnz invalid_operand_size;
	mov( $0F, al );
	stosb;
	jmp pop_done;
  pop_sreg_386:
	sub( 4, al );
	shl( 3, al );
	add( $0A1, al );
	mov( al, extended_code );
	mov( $0F, base_code );
	jmp pop_reg_store;
  inc_instruction::
	mov( al, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je inc_reg;
	cmp( al, '[' );
	je inc_mem;
	jne invalid_operand;
  inc_mem:
	call get_address;
	mov( operand_size, al );
	cmp( al, 1 );
	je inc_mem_8bit;
	jb inc_mem_nosize;
	call operand_autodetect;
	mov( $0FF, al );
	xchg( base_code, al );
	mov( al, postbyte_register );
	call store_instruction;
	jmp instruction_assembled;
  inc_mem_nosize:
	cmp( error_line, 0 );
	jne inc_mem_8bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
  inc_mem_8bit:
	mov( $0FE, al );
	xchg( base_code, al );
	mov( al, postbyte_register );
	call store_instruction;
	jmp instruction_assembled;
  inc_reg:
	lodsb;
	call convert_register;
	mov( al, bl );
	mov( $0FE, al );
	xchg( base_code, al );
	mov( al, postbyte_register );
	mov( ah, al );
	cmp( al, 1 );
	je inc_reg_8bit;
	call operand_autodetect;
	cmp( code_type, 64 );
	je inc_reg_long_form;
	mov( postbyte_register, al );
	shl( 3, al );
	add( bl, al );
	add( $40, al );
	mov( al, base_code );
	call store_instruction_code;
	jmp instruction_assembled;
  inc_reg_long_form:
	inc( base_code );
  inc_reg_8bit:
	call store_nomem_instruction;
	jmp instruction_assembled;
  set_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je set_reg;
	cmp( al, '[' );
	jne invalid_operand;
  set_mem:
	call get_address;
	cmp( operand_size, 1 );
	ja invalid_operand_size;
	mov( 0, postbyte_register );
	call store_instruction;
	jmp instruction_assembled;
  set_reg:
	lodsb;
	call convert_register;
	cmp( ah, 1 );
	jne invalid_operand_size;
	mov( al, bl );
	mov( 0, postbyte_register );
	call store_nomem_instruction;
	jmp instruction_assembled;
  arpl_instruction::
	cmp( code_type, 64 );
	je illegal_instruction;
	mov( $63, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je arpl_reg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	cmp( ah, 2 );
	jne invalid_operand_size;
	call store_instruction;
	jmp instruction_assembled;
  arpl_reg:
	lodsb;
	call convert_register;
	cmp( ah, 2 );
	jne invalid_operand_size;
	mov( al, bl );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	cmp( ah, 2 );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	call store_nomem_instruction;
	jmp instruction_assembled;
  bound_instruction::
	cmp( code_type, 64 );
	je illegal_instruction;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	cmp( al, 2 );
	je bound_16bit;
	cmp( al, 4 );
	je bound_32bit;
	jmp invalid_operand_size;
  bound_32bit:
	call operand_32bit;
	mov( $62, base_code );
	call store_instruction;
	jmp instruction_assembled;
  bound_16bit:
	call operand_16bit;
	mov( $62, base_code );
	call store_instruction;
	jmp instruction_assembled;
  enter_instruction::
	lodsb;
	call get_size_operator;
	cmp( ah, 2 );
	je enter_imm16_size_ok;
	or( ah, ah );
	jnz invalid_operand_size;
  enter_imm16_size_ok:
	cmp( al, '(' );
	jne invalid_operand;
	call get_word_value;
	cmp( next_pass_needed, 0 );
	jne enter_imm16_ok;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
  enter_imm16_ok:
	push( eax );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( ah, 1 );
	je enter_imm8_size_ok;
	or( ah, ah );
	jnz invalid_operand_size;
  enter_imm8_size_ok:
	cmp( al, '(' );
	jne invalid_operand;
	call get_byte_value;
	mov( al, dl );
	pop( ebx );
	mov( $0C8, al );
	stosb;
	mov( bx, ax );
	stosw;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
	
  ret_instruction_only64::
	cmp( code_type, 64 );
	jne illegal_instruction;
	jmp ret_instruction;
  ret_instruction_32bit_except64::
	cmp( code_type, 64 );
	je illegal_instruction;
  ret_instruction_32bit::
	call operand_32bit;
	jmp ret_instruction;
  ret_instruction_16bit::
	call operand_16bit;
	jmp ret_instruction;
  retf_instruction::
	cmp( code_type, 64 );
	jne ret_instruction;
  ret_instruction_64bit::
	call operand_64bit;
  ret_instruction::
	mov( al, base_code );
	lodsb;
	dec( esi );
	or( al, al );
	jz simple_ret;
	cmp( al, $0F );
	je simple_ret;
	lodsb;
	call get_size_operator;
	or( ah, ah );
	jz ret_imm;
	cmp( ah, 2 );
	je ret_imm;
	jmp invalid_operand_size;
  ret_imm:
	cmp( al, '(' );
	jne invalid_operand;
	call get_word_value;
	cmp( next_pass_needed, 0 );
	jne ret_imm_ok;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
  ret_imm_ok:
	cmp( size_declared, 0 );
	jne ret_imm_store;
	or( ax, ax );
	jz simple_ret;
  ret_imm_store:
	mov( ax, dx );
	call store_instruction_code;
	mov( dx, ax );
	stosw;
	jmp instruction_assembled;
  simple_ret:
	inc( base_code );
	call store_instruction_code;
	jmp instruction_assembled;
  lea_instruction::
	mov( $8D, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	xor( al, al );
	xchg( operand_size, al );
	push( eax );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	mov( -1, size_override );
	call get_address;
	pop( eax );
	mov( al, operand_size );
	call operand_autodetect;
	call store_instruction;
	jmp instruction_assembled;
  ls_instruction::
	or( al, al );
	jz les_instruction;
	cmp( al, 3 );
	jz lds_instruction;
	add( $0B0, al );
	mov( al, extended_code );
	mov( $0F, base_code );
	jmp ls_code_ok;
  les_instruction::
	mov( $0C4, base_code );
	jmp ls_short_code;
  lds_instruction::
	mov( $0C5, base_code );
  ls_short_code:
	cmp( code_type, 64 );
	je illegal_instruction;
  ls_code_ok:
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	add( 2, operand_size );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	cmp( al, 4 );
	je ls_16bit;
	cmp( al, 6 );
	je ls_32bit;
	cmp( al, 10 );
	je ls_64bit;
	jmp invalid_operand_size;
  ls_16bit:
	call operand_16bit;
	call store_instruction;
	jmp instruction_assembled;
  ls_32bit:
	call operand_32bit;
	call store_instruction;
	jmp instruction_assembled;
  ls_64bit:
	call operand_64bit;
	call store_instruction;
	jmp instruction_assembled;
  sh_instruction::
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je sh_reg;
	cmp( al, '[' );
	jne invalid_operand;
  sh_mem:
	call get_address;
	push( edx );
	push( bx );
	push( cx );
	mov( operand_size, al );
	push( eax );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	je sh_mem_imm;
	cmp( al, $10 );
	jne invalid_operand;
  sh_mem_reg:
	lodsb;
	cmp( al, $11 );
	jne invalid_operand;
	pop( eax );
	pop( cx );
	pop( bx );
	pop( edx );
	cmp( al, 1 );
	je sh_mem_cl_8bit;
	jb sh_mem_cl_nosize;
	call operand_autodetect;
	mov( $0D3, base_code );
	call store_instruction;
	jmp instruction_assembled;
  sh_mem_cl_nosize:
	cmp( error_line, 0 );
	jne sh_mem_cl_8bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
  sh_mem_cl_8bit:
	mov( $0D2, base_code );
	call store_instruction;
	jmp instruction_assembled;
  sh_mem_imm:
	mov( operand_size, al );
	or( al, al );
	jz sh_mem_imm_size_ok;
	cmp( al, 1 );
	jne invalid_operand_size;
  sh_mem_imm_size_ok:
	call get_byte_value;
	mov( al, (type byte value) );
	pop( eax );
	pop( cx );
	pop( bx );
	pop( edx );
	cmp( al, 1 );
	je sh_mem_imm_8bit;
	jb sh_mem_imm_nosize;
	call operand_autodetect;
	cmp( (type byte value), 1 );
	je sh_mem_1;
	mov( $0C1, base_code );
	call store_instruction_with_imm8;
	jmp instruction_assembled;
  sh_mem_1:
	mov( $0D1, base_code );
	call store_instruction;
	jmp instruction_assembled;
  sh_mem_imm_nosize:
	cmp( error_line, 0 );
	jne sh_mem_imm_8bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
  sh_mem_imm_8bit:
	cmp( (type byte value), 1 );
	je sh_mem_1_8bit;
	mov( $0C0, base_code );
	call store_instruction_with_imm8;
	jmp instruction_assembled;
  sh_mem_1_8bit:
	mov( $0D0, base_code );
	call store_instruction;
	jmp instruction_assembled;
  sh_reg:
	lodsb;
	call convert_register;
	mov( ax, bx );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	je sh_reg_imm;
	cmp( al, $10 );
	jne invalid_operand;
  sh_reg_reg:
	lodsb;
	cmp( al, $11 );
	jne invalid_operand;
	mov( bh, al );
	cmp( al, 1 );
	je sh_reg_cl_8bit;
	call operand_autodetect;
	mov( $0D3, base_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  sh_reg_cl_8bit:
	mov( $0D2, base_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  sh_reg_imm:
	mov( operand_size, al );
	or( al, al );
	jz sh_reg_imm_size_ok;
	cmp( al, 1 );
	jne invalid_operand_size;
  sh_reg_imm_size_ok:
	push( ebx );
	call get_byte_value;
	mov( al, dl );
	pop( ebx );
	mov( bh, al );
	cmp( al, 1 );
	je sh_reg_imm_8bit;
	call operand_autodetect;
	cmp( dl, 1 );
	je sh_reg_1;
	mov( $0C1, base_code );
	call store_nomem_instruction;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
  sh_reg_1:
	mov( $0D1, base_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  sh_reg_imm_8bit:
	cmp( dl, 1 );
	je sh_reg_1_8bit;
	mov( $0C0, base_code );
	call store_nomem_instruction;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
  sh_reg_1_8bit:
	mov( $0D0, base_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  shd_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je shd_reg;
	cmp( al, '[' );
	jne invalid_operand;
  shd_mem:
	call get_address;
	push( edx );
	push( bx );
	push( cx );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	mov( ah, al );
	mov( 0, operand_size );
	push( eax );
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	je shd_mem_reg_imm;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	cmp( al, $11 );
	jne invalid_operand;
	pop( eax );
	pop( cx );
	pop( bx );
	pop( edx );
	call operand_autodetect;
	inc( extended_code );
	call store_instruction;
	jmp instruction_assembled;
  shd_mem_reg_imm:
	mov( operand_size, al );
	or( al, al );
	jz shd_mem_reg_imm_size_ok;
	cmp( al, 1 );
	jne invalid_operand_size;
  shd_mem_reg_imm_size_ok:
	call get_byte_value;
	mov( al, (type byte value) );
	pop( eax );
	pop( cx );
	pop( bx );
	pop( edx );
	call operand_autodetect;
	call store_instruction_with_imm8;
	jmp instruction_assembled;
  shd_reg:
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( postbyte_register, bl );
	mov( al, postbyte_register );
	mov( ah, al );
	push( eax );
	push( ebx );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	mov( 0, operand_size );
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	je shd_reg_reg_imm;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	cmp( al, $11 );
	jne invalid_operand;
	pop( ebx );
	pop( eax );
	call operand_autodetect;
	inc( extended_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  shd_reg_reg_imm:
	mov( operand_size, al );
	or( al, al );
	jz shd_reg_reg_imm_size_ok;
	cmp( al, 1 );
	jne invalid_operand_size;
  shd_reg_reg_imm_size_ok:
	call get_byte_value;
	mov( al, dl );
	pop( ebx );
	pop( eax );
	call operand_autodetect;
	call store_nomem_instruction;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
  movx_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	mov( ah, al );
	push( eax );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	mov( 0, operand_size );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je movx_reg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	pop( eax );
	mov( operand_size, ah );
	or( ah, ah );
	jz movx_unknown_size;
	cmp( ah, al );
	jae invalid_operand_size;
	cmp( ah, 1 );
	je movx_mem_8bit;
	cmp( ah, 2 );
	jne invalid_operand_size;
  movx_mem_16bit:
	inc( extended_code );
	call operand_autodetect;
	call store_instruction;
	jmp instruction_assembled;
  movx_unknown_size:
	cmp( error_line, 0 );
	jne movx_mem_8bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
  movx_mem_8bit:
	call operand_autodetect;
	call store_instruction;
	jmp instruction_assembled;
  movx_reg:
	lodsb;
	call convert_register;
	pop( ebx );
	xchg( al, bl );
	cmp( ah, al );
	jae invalid_operand_size;
	cmp( ah, 1 );
	je movx_reg_8bit;
	cmp( ah, 2 );
	je movx_reg_16bit;
	jmp invalid_operand_size;
  movx_reg_8bit:
	call operand_autodetect;
	call store_nomem_instruction;
	jmp instruction_assembled;
  movx_reg_16bit:
	call operand_autodetect;
	inc( extended_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  movsxd_instruction::
	mov( al, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	cmp( ah, 8 );
	jne invalid_operand_size;
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	mov( 0, operand_size );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je movsxd_reg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	cmp( operand_size, 4 );
	je movsxd_mem_store;
	cmp( operand_size, 0 );
	jne invalid_operand_size;
  movsxd_mem_store:
	call operand_64bit;
	call store_instruction;
	jmp instruction_assembled;
  movsxd_reg:
	lodsb;
	call convert_register;
	cmp( ah, 4 );
	jne invalid_operand_size;
	mov( al, bl );
	call operand_64bit;
	call store_nomem_instruction;
	jmp instruction_assembled;
  bt_instruction::
	mov( al, postbyte_register );
	shl( 3, al );
	add( $83, al );
	mov( al, extended_code );
	mov( $0F, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je bt_reg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	push( eax );
	push( bx );
	push( cx );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	cmp( (type byte [esi]), '(' );
	je bt_mem_imm;
	cmp( (type byte [esi]), $11 );
	jne bt_mem_reg;
	cmp( (type byte [esi+2]), '(' );
	je bt_mem_imm;
  bt_mem_reg:
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	pop( cx );
	pop( bx );
	pop( edx );
	mov( ah, al );
	call operand_autodetect;
	call store_instruction;
	jmp instruction_assembled;
  bt_mem_imm:
	xor( al, al );
	xchg( operand_size, al );
	push( eax );
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	jne invalid_operand;
	mov( operand_size, al );
	or( al, al );
	jz bt_mem_imm_size_ok;
	cmp( al, 1 );
	jne invalid_operand_size;
  bt_mem_imm_size_ok:
	call get_byte_value;
	mov( al, (type byte value) );
	pop( eax );
	or( al, al );
	jz bt_mem_imm_nosize;
	call operand_autodetect;
  bt_mem_imm_store:
	pop( cx );
	pop( bx );
	pop( edx );
	mov( $0BA, extended_code );
	call store_instruction_with_imm8;
	jmp instruction_assembled;
  bt_mem_imm_nosize:
	cmp( error_line, 0 );
	jne bt_mem_imm_store;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
	jmp bt_mem_imm_store;
  bt_reg:
	lodsb;
	call convert_register;
	mov( al, bl );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	cmp( (type byte [esi]), '(' );
	je bt_reg_imm;
	cmp( (type byte [esi]), $11 );
	jne bt_reg_reg;
	cmp( (type byte [esi+2]), '(' );
	je bt_reg_imm;
  bt_reg_reg:
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	mov( ah, al );
	call operand_autodetect;
	call store_nomem_instruction;
	jmp instruction_assembled;
  bt_reg_imm:
	xor( al, al );
	xchg( operand_size, al );
	push( eax );
	push( ebx );
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	jne invalid_operand;
	mov( operand_size, al );
	or( al, al );
	jz bt_reg_imm_size_ok;
	cmp( al, 1 );
	jne invalid_operand_size;
  bt_reg_imm_size_ok:
	call get_byte_value;
	mov( al, (type byte value) );
	pop( ebx );
	pop( eax );
	call operand_autodetect;
  bt_reg_imm_store:
	mov( $0BA, extended_code );
	call store_nomem_instruction;
	mov( (type byte value), al );
	stosb;
	jmp instruction_assembled;
  bs_instruction::
	mov( al, extended_code );
	mov( $0F, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je bs_reg_reg;
	cmp( al, '[' );
	jne invalid_argument;
	call get_address;
	mov( operand_size, al );
	call operand_autodetect;
	call store_instruction;
	jmp instruction_assembled;
  bs_reg_reg:
	lodsb;
	call convert_register;
	mov( al, bl );
	mov( ah, al );
	call operand_autodetect;
	call store_nomem_instruction;
	jmp instruction_assembled;
  imul_instruction::
	mov( $0F6, base_code );
	mov( 5, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je imul_reg;
	cmp( al, '[' );
	jne invalid_operand;
  imul_mem:
	call get_address;
	mov( operand_size, al );
	cmp( al, 1 );
	je imul_mem_8bit;
	jb imul_mem_nosize;
	call operand_autodetect;
	inc( base_code );
	call store_instruction;
	jmp instruction_assembled;
  imul_mem_nosize:
	cmp( error_line, 0 );
	jne imul_mem_8bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
  imul_mem_8bit:
	call store_instruction;
	jmp instruction_assembled;
  imul_reg:
	lodsb;
	call convert_register;
	cmp( (type byte [esi]), ',' );
	je imul_reg_;
	mov( al, bl );
	mov( ah, al );
	cmp( al, 1 );
	je imul_reg_8bit;
	call operand_autodetect;
	inc( base_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  imul_reg_8bit:
	call store_nomem_instruction;
	jmp instruction_assembled;
  imul_reg_:
	mov( al, postbyte_register );
	inc( esi );
	cmp( (type byte [esi]), '(' );
	je imul_reg_imm;
	cmp( (type byte [esi]), $11 );
	jne imul_reg_noimm;
	cmp( (type byte [esi+2]), '(' );
	je imul_reg_imm;
  imul_reg_noimm:
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je imul_reg_reg;
	cmp( al, '[' );
	jne invalid_operand;
  imul_reg_mem:
	call get_address;
	push( edx );
	push( bx );
	push( cx );
	cmp( (type byte [esi]), ',' );
	je imul_reg_mem_imm;
	mov( operand_size, al );
	call operand_autodetect;
	pop( cx );
	pop( bx );
	pop( edx );
	mov( $0F, base_code );
	mov( $0AF, extended_code );
	call store_instruction;
	jmp instruction_assembled;
  imul_reg_mem_imm:
	inc( esi );
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	jne invalid_operand;
	mov( operand_size, al );
	cmp( al, 2 );
	je imul_reg_mem_imm_16bit;
	cmp( al, 4 );
	je imul_reg_mem_imm_32bit;
	cmp( al, 8 );
	je imul_reg_mem_imm_64bit;
	jmp invalid_operand_size;
  imul_reg_mem_imm_16bit:
	call operand_16bit;
	call get_word_value;
	mov( ax, (type word value) );
	cmp( value_type, 0 );
	jne imul_reg_mem_imm_16bit_store;
	cmp( size_declared, 0 );
	jne imul_reg_mem_imm_16bit_store;
	cmp( ax, _word(-$80) );
	jl imul_reg_mem_imm_16bit_store;
	cmp( ax, $80 );
	jl imul_reg_mem_imm_8bit_store;
  imul_reg_mem_imm_16bit_store:
	pop( cx );
	pop( bx );
	pop( edx );
	mov( $69, base_code );
	call store_instruction_with_imm16;
	jmp instruction_assembled;
  imul_reg_mem_imm_32bit:
	call operand_32bit;
	call get_dword_value;
  imul_reg_mem_imm_32bit_ok:
	mov( eax, (type dword value) );
	cmp( value_type, 0 );
	jne imul_reg_mem_imm_32bit_store;
	cmp( size_declared, 0 );
	jne imul_reg_mem_imm_32bit_store;
	cmp( eax, -$80 );
	jl imul_reg_mem_imm_32bit_store;
	cmp( eax, $80 );
	jl imul_reg_mem_imm_8bit_store;
  imul_reg_mem_imm_32bit_store:
	pop( cx );
	pop( bx );
	pop( edx );
	mov( $69, base_code );
	call store_instruction_with_imm32;
	jmp instruction_assembled;
  imul_reg_mem_imm_64bit:
	cmp( size_declared, 0 );
	jne long_immediate_not_encodable;
	call operand_64bit;
	call get_simm32;
	cmp( value_type, 4 );
	jae long_immediate_not_encodable;
	jmp imul_reg_mem_imm_32bit_ok;
  imul_reg_mem_imm_8bit_store:
	pop( cx );
	pop( bx );
	pop( edx );
	mov( $6B, base_code );
	call store_instruction_with_imm8;
	jmp instruction_assembled;
  imul_reg_imm:
	mov( postbyte_register, bl );
	dec( esi );
	jmp imul_reg_reg_imm;
  imul_reg_reg:
	lodsb;
	call convert_register;
	mov( al, bl );
	cmp( (type byte [esi]), ',' );
	je imul_reg_reg_imm;
	mov( ah, al );
	call operand_autodetect;
	mov( $0F, base_code );
	mov( $0AF, extended_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  imul_reg_reg_imm:
	inc( esi );
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	jne invalid_operand;
	mov( operand_size, al );
	cmp( al, 2 );
	je imul_reg_reg_imm_16bit;
	cmp( al, 4 );
	je imul_reg_reg_imm_32bit;
	cmp( al, 8 );
	je imul_reg_reg_imm_64bit;
	jmp invalid_operand_size;
  imul_reg_reg_imm_16bit:
	call operand_16bit;
	push( ebx );
	call get_word_value;
	pop( ebx );
	mov( ax, dx );
	cmp( value_type, 0 );
	jne imul_reg_reg_imm_16bit_store;
	cmp( size_declared, 0 );
	jne imul_reg_reg_imm_16bit_store;
	cmp( ax, _word(-$80) );
	jl imul_reg_reg_imm_16bit_store;
	cmp( ax, $80 );
	jl imul_reg_reg_imm_8bit_store;
  imul_reg_reg_imm_16bit_store:
	mov( $69, base_code );
	call store_nomem_instruction;
	mov( dx, ax );
	call mark_relocation;
	stosw;
	jmp instruction_assembled;
  imul_reg_reg_imm_32bit:
	call operand_32bit;
	push( ebx );
	call get_dword_value;
  imul_reg_reg_imm_32bit_ok:
	pop( ebx );
	mov( eax, edx );
	cmp( value_type, 0 );
	jne imul_reg_reg_imm_32bit_store;
	cmp( size_declared, 0 );
	jne imul_reg_reg_imm_32bit_store;
	cmp( eax, -$80 );
	jl imul_reg_reg_imm_32bit_store;
	cmp( eax, $80 );
	jl imul_reg_reg_imm_8bit_store;
  imul_reg_reg_imm_32bit_store:
	mov( $69, base_code );
	call store_nomem_instruction;
	mov( edx, eax );
	call mark_relocation;
	stosd;
	jmp instruction_assembled;
  imul_reg_reg_imm_64bit:
	cmp( size_declared, 0 );
	jne long_immediate_not_encodable;
	call operand_64bit;
	push( ebx );
	call get_simm32;
	cmp( value_type, 4 );
	jae long_immediate_not_encodable;
	jmp imul_reg_reg_imm_32bit_ok;
  imul_reg_reg_imm_8bit_store:
	mov( $6B, base_code );
	call store_nomem_instruction;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
  in_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	or( al, al );
	jnz invalid_operand;
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	mov( ah, al );
	push( eax );
	mov( 0, operand_size );
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	je in_imm;
	cmp( al, $10 );
	je in_reg;
	jmp invalid_operand;
  in_reg:
	lodsb;
	cmp( al, '"' );
	jne invalid_operand;
	pop( eax );
	cmp( al, 1 );
	je in_al_dx;
	cmp( al, 2 );
	je in_ax_dx;
	cmp( al, 4 );
	je in_eax_dx;
	jmp invalid_operand_size;
  in_al_dx:
	mov( $0EC, al );
	stosb;
	jmp instruction_assembled;
  in_ax_dx:
	call operand_16bit;
	mov( $0ED, base_code );
	call store_instruction_code;
	jmp instruction_assembled;
  in_eax_dx:
	call operand_32bit;
	mov( $0ED, base_code );
	call store_instruction_code;
	jmp instruction_assembled;
  in_imm:
	mov( operand_size, al );
	or( al, al );
	jz in_imm_size_ok;
	cmp( al, 1 );
	jne invalid_operand_size;
  in_imm_size_ok:
	call get_byte_value;
	mov( al, dl );
	pop( eax );
	cmp( al, 1 );
	je in_al_imm;
	cmp( al, 2 );
	je in_ax_imm;
	cmp( al, 4 );
	je in_eax_imm;
	jmp invalid_operand_size;
  in_al_imm:
	mov( $0E4, al );
	stosb;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
  in_ax_imm:
	call operand_16bit;
	mov( $0E5, base_code );
	call store_instruction_code;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
  in_eax_imm:
	call operand_32bit;
	mov( $0E5, base_code );
	call store_instruction_code;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
  out_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, '(' );
	je out_imm;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	cmp( al, '"' );
	jne invalid_operand;
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	mov( 0, operand_size );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	or( al, al );
	jnz invalid_operand;
	mov( ah, al );
	cmp( al, 1 );
	je out_dx_al;
	cmp( al, 2 );
	je out_dx_ax;
	cmp( al, 4 );
	je out_dx_eax;
	jmp invalid_operand_size;
  out_dx_al:
	mov( $0EE, al );
	stosb;
	jmp instruction_assembled;
  out_dx_ax:
	call operand_16bit;
	mov( $0EF, base_code );
	call store_instruction_code;
	jmp instruction_assembled;
  out_dx_eax:
	call operand_32bit;
	mov( $0EF, base_code );
	call store_instruction_code;
	jmp instruction_assembled;
  out_imm:
	mov( operand_size, al );
	or( al, al );
	jz out_imm_size_ok;
	cmp( al, 1 );
	jne invalid_operand_size;
  out_imm_size_ok:
	call get_byte_value;
	mov( al, dl );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	mov( 0, operand_size );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	or( al, al );
	jnz invalid_operand;
	mov( ah, al );
	cmp( al, 1 );
	je out_imm_al;
	cmp( al, 2 );
	je out_imm_ax;
	cmp( al, 4 );
	je out_imm_eax;
	jmp invalid_operand_size;
  out_imm_al:
	mov( $0E6, al );
	stosb;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
  out_imm_ax:
	call operand_16bit;
	mov( $0E7, base_code );
	call store_instruction_code;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;
  out_imm_eax:
	call operand_32bit;
	mov( $0E7, base_code );
	call store_instruction_code;
	mov( dl, al );
	stosb;
	jmp instruction_assembled;

  call_instruction::
	mov( %10, postbyte_register );
	mov( $0E8, base_code );
	mov( $9A, extended_code );
	jmp process_jmp;
  jmp_instruction::
	mov( %100, postbyte_register );
	mov( $0E9, base_code );
	mov( $0EA, extended_code );
  process_jmp:
	lodsb;
	call get_jump_operator;
	call get_size_operator;
	cmp( al, '(' );
	je jmp_imm;
	mov( $0FF, base_code );
	cmp( al, $10 );
	je jmp_reg;
	cmp( al, '[' );
	jne invalid_operand;
  jmp_mem:
	cmp( jump_type, 1 );
	je illegal_instruction;
	call get_address;
	mov( eax, edx );
	mov( operand_size, al );
	or( al, al );
	jz jmp_mem_size_not_specified;
	cmp( al, 2 );
	je jmp_mem_16bit;
	cmp( al, 4 );
	je jmp_mem_32bit;
	cmp( al, 6 );
	je jmp_mem_48bit;
	cmp( al, 8 );
	je jmp_mem_64bit;
	cmp( al, 10 );
	je jmp_mem_80bit;
	jmp invalid_operand_size;
  jmp_mem_size_not_specified:
	cmp( jump_type, 3 );
	je jmp_mem_far;
	cmp( jump_type, 2 );
	je jmp_mem_near;
	cmp( error_line, 0 );
	jne jmp_mem_near;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
  jmp_mem_near:
	cmp( code_type, 16 );
	je jmp_mem_16bit;
	cmp( code_type, 32 );
	je jmp_mem_near_32bit;
  jmp_mem_64bit:
	cmp( jump_type, 3 );
	je invalid_operand_size;
	cmp( code_type, 64 );
	jne illegal_instruction;
	call store_instruction;
	jmp instruction_assembled;
  jmp_mem_far:
	cmp( code_type, 16 );
	je jmp_mem_far_32bit;
  jmp_mem_48bit:
	call operand_32bit;
  jmp_mem_far_store:
	cmp( jump_type, 2 );
	je invalid_operand_size;
	inc( postbyte_register );
	call store_instruction;
	jmp instruction_assembled;
  jmp_mem_80bit:
	call operand_64bit;
	jmp jmp_mem_far_store;
  jmp_mem_far_32bit:
	call operand_16bit;
	jmp jmp_mem_far_store;
  jmp_mem_32bit:
	cmp( jump_type, 3 );
	je jmp_mem_far_32bit;
	cmp( jump_type, 2 );
	je jmp_mem_near_32bit;
	cmp( code_type, 16 );
	je jmp_mem_far_32bit;
  jmp_mem_near_32bit:
	cmp( code_type, 64 );
	je illegal_instruction;
	call operand_32bit;
	call store_instruction;
	jmp instruction_assembled;
  jmp_mem_16bit:
	cmp( jump_type, 3 );
	je invalid_operand_size;
	call operand_16bit;
	call store_instruction;
	jmp instruction_assembled;
  jmp_reg:
	test( 1, jump_type );
	jnz invalid_operand;
	lodsb;
	call convert_register;
	mov( al, bl );
	mov( ah, al );
	cmp( al, 2 );
	je jmp_reg_16bit;
	cmp( al, 4 );
	je jmp_reg_32bit;
	cmp( al, 8 );
	jne invalid_operand_size;
  jmp_reg_64bit:
	cmp( code_type, 64 );
	jne illegal_instruction;
	call store_nomem_instruction;
	jmp instruction_assembled;
  jmp_reg_32bit:
	cmp( code_type, 64 );
	je illegal_instruction;
	call store_nomem_instruction;
	jmp instruction_assembled;
  jmp_reg_16bit:
	call operand_16bit;
	call store_nomem_instruction;
	jmp instruction_assembled;
  jmp_imm:
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	mov( esi, ebx );
	dec( esi );
	call skip_symbol;
	xchg( ebx, esi );
	cmp( (type byte [ebx]), ':' );
	je jmp_far;
	cmp( jump_type, 3 );
	je invalid_operand;
  jmp_near:
	mov( operand_size, al );
	cmp( al, 2 );
	je jmp_imm_16bit;
	cmp( al, 4 );
	je jmp_imm_32bit;
	cmp( al, 8 );
	je jmp_imm_64bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( code_type, 16 );
	je jmp_imm_16bit;
	cmp( code_type, 64 );
	je jmp_imm_64bit;
  jmp_imm_32bit:
	cmp( code_type, 64 );
	je invalid_operand_size;
	call get_dword_value;
	cmp( code_type, 16 );
	jne jmp_imm_32bit_prefix_ok;
	mov( $66, (type byte [edi]) );
	inc( edi );
  jmp_imm_32bit_prefix_ok:
	call calculate_jump_offset;
	cdq;
	call check_for_short_jump;
	jc jmp_short;
  jmp_imm_32bit_store:
	mov( eax, edx );
	sub( 3, edx );
	mov( base_code, al );
	stosb;
	mov( edx, eax );
	call mark_relocation;
	stosd;
	jmp instruction_assembled;
  jmp_imm_64bit:
	cmp( code_type, 64 );
	jne invalid_operand_size;
	call get_qword_value;
	call calculate_jump_offset;
	mov( edx, ecx );
	cdq;
	cmp( edx, ecx );
	jne value_out_of_range;
	call check_for_short_jump;
	jnc jmp_imm_32bit_store;
  jmp_short:
	mov( al, ah );
	mov( $0EB, al );
	stosw;
	jmp instruction_assembled;
  jmp_imm_16bit:
	call get_word_value;
	cmp( code_type, 16 );
	je jmp_imm_16bit_prefix_ok;
	mov( $66, (type byte [edi]) );
	inc( edi );
  jmp_imm_16bit_prefix_ok:
	call calculate_jump_offset;
	cwde;
	cdq;
	call check_for_short_jump;
	jc jmp_short;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( eax, edx );
	dec( edx );
	mov( base_code, al );
	stosb;
	mov( edx, eax );
	stosw;
	jmp instruction_assembled;
	
  jump_out_of_range:
	cmp( error_line, 0 );
	jne instruction_assembled;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &relative_jump_out_of_range, error );
	jmp instruction_assembled;
	
  jmp_far:
	cmp( jump_type, 2 );
	je invalid_operand;
	cmp( code_type, 64 );
	je illegal_instruction;
	mov( extended_code, al );
	mov( al, base_code );
	call get_word_value;
	push( eax );
	inc( esi );
	lodsb;
	cmp( al, '(' );
	jne invalid_operand;
	mov( value_type, al );
	push( eax );
	push( symbol_identifier );
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	mov( operand_size, al );
	cmp( al, 4 );
	je jmp_far_16bit;
	cmp( al, 6 );
	je jmp_far_32bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( code_type, 16 );
	jne jmp_far_32bit;
  jmp_far_16bit:
	call get_word_value;
	mov( eax, ebx );
	call operand_16bit;
	call store_instruction_code;
	mov( bx, ax );
	call mark_relocation;
	stosw;
  jmp_far_segment:
	pop( symbol_identifier );
	pop( eax );
	mov( al, value_type );
	pop( eax );
	call mark_relocation;
	stosw;
	jmp instruction_assembled;
  jmp_far_32bit:
	call get_dword_value;
	mov( eax, ebx );
	call operand_32bit;
	call store_instruction_code;
	mov( ebx, eax );
	call mark_relocation;
	stosd;
	jmp jmp_far_segment;
	
  conditional_jump::
	mov( al, base_code );
	lodsb;
	call get_jump_operator;
	cmp( jump_type, 3 );
	je invalid_operand;
	call get_size_operator;
	cmp( al, '(' );
	jne invalid_operand;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	mov( operand_size, al );
	cmp( al, 2 );
	je conditional_jump_16bit;
	cmp( al, 4 );
	je conditional_jump_32bit;
	cmp( al, 8 );
	je conditional_jump_64bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( code_type, 16 );
	je conditional_jump_16bit;
	cmp( code_type, 64 );
	je conditional_jump_64bit;
  conditional_jump_32bit:
	cmp( code_type, 64 );
	je invalid_operand_size;
	call get_dword_value;
	cmp( code_type, 16 );
	jne conditional_jump_32bit_prefix_ok;
	mov( $66, (type byte [edi]) );
	inc( edi );
  conditional_jump_32bit_prefix_ok:
	call calculate_jump_offset;
	cdq;
	call check_for_short_jump;
	jc conditional_jump_short;
  conditional_jump_32bit_store:
	mov( eax, edx );
	sub( 4, edx );
	mov( base_code, ah );
	add( $10, ah );
	mov( $0F, al );
	stosw;
	mov( edx, eax );
	call mark_relocation;
	stosd;
	jmp instruction_assembled;
  conditional_jump_64bit:
	cmp( code_type, 64 );
	jne invalid_operand_size;
	call get_qword_value;
	call calculate_jump_offset;
	mov( edx, ecx );
	cdq;
	cmp( edx, ecx );
	jne value_out_of_range;
	call check_for_short_jump;
	jnc conditional_jump_32bit_store;
  conditional_jump_short:
	mov( al, ah );
	mov( base_code, al );
	stosw;
	jmp instruction_assembled;
  conditional_jump_16bit:
	call get_word_value;
	cmp( code_type, 16 );
	je conditional_jump_16bit_prefix_ok;
	mov( $66, (type byte [edi]) );
	inc( edi );
  conditional_jump_16bit_prefix_ok:
	call calculate_jump_offset;
	cwde;
	cdq;
	call check_for_short_jump;
	jc conditional_jump_short;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( eax, edx );
	sub( 2, edx );
	mov( base_code, ah );
	add( $10, ah );
	mov( $0F, al );
	stosw;
	mov( edx, eax );
	stosw;
	jmp instruction_assembled;
	
  loop_instruction_16bit::
	cmp( code_type, 64 );
	je illegal_instruction;
	mov( al, dl );
	call address_16bit_prefix;
	mov( dl, al );
	jmp loop_instruction;
	
  loop_instruction_32bit::
	mov( al, dl );
	call address_32bit_prefix;
	mov( dl, al );
	jmp loop_instruction;
	
  loop_instruction_64bit::
	cmp( code_type, 64 );
	jne illegal_instruction;
	
  loop_instruction::
	mov( al, base_code );
	lodsb;
	call get_jump_operator;
	cmp( jump_type, 1 );
	ja invalid_operand;
	call get_size_operator;
	cmp( al, '(' );
	jne invalid_operand;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	mov( operand_size, al );
	cmp( al, 2 );
	je loop_jump_16bit;
	cmp( al, 4 );
	je loop_jump_32bit;
	cmp( al, 8 );
	je loop_jump_64bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( code_type, 16 );
	je loop_jump_16bit;
	cmp( code_type, 64 );
	je loop_jump_64bit;
  loop_jump_32bit:
	cmp( code_type, 64 );
	je invalid_operand_size;
	call get_dword_value;
	cmp( code_type, 16 );
	jne loop_jump_32bit_prefix_ok;
	mov( $66, (type byte [edi]) );
	inc( edi );
  loop_jump_32bit_prefix_ok:
	call calculate_jump_offset;
	cdq;
  make_loop_jump:
	call check_for_short_jump;
	jc conditional_jump_short;
	jmp jump_out_of_range;
  loop_jump_64bit:
	cmp( code_type, 64 );
	jne invalid_operand_size;
	call get_qword_value;
	call calculate_jump_offset;
	mov( edx, ecx );
	cdq;
	cmp( edx, ecx );
	jne value_out_of_range;
	jmp make_loop_jump;
  loop_jump_16bit:
	call get_word_value;
	cmp( code_type, 16 );
	je loop_jump_16bit_prefix_ok;
	mov( $66, (type byte [edi]) );
	inc( edi );
  loop_jump_16bit_prefix_ok:
	call calculate_jump_offset;
	cwde;
	cdq;
	jmp make_loop_jump;

  movs_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	or( eax, eax );
	jnz invalid_address;
	or( ch, bl );
	jnz invalid_address;
	cmp( segment_register, 1 );
	ja invalid_address;
	push( ebx );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	pop( edx );
	or( eax, eax );
	jnz invalid_address;
	or( ch, bl );
	jnz invalid_address;
	mov( dh, al );
	mov( bh, ah );
	shr( 4, al );
	shr( 4, ah );
	cmp( al, ah );
	jne address_sizes_do_not_agree;
	and( %111, bh );
	and( %111, dh );
	cmp( bh, 6 );
	jne invalid_address;
	cmp( dh, 7 );
	jne invalid_address;
	cmp( al, 2 );
	je movs_address_16bit;
	cmp( al, 4 );
	je movs_address_32bit;
	cmp( code_type, 64 );
	jne invalid_address_size;
	jmp movs_store;
  movs_address_32bit:
	call address_32bit_prefix;
	jmp movs_store;
  movs_address_16bit:
	cmp( code_type, 64 );
	je invalid_address_size;
	call address_16bit_prefix;
  movs_store:
	cmp( segment_register, 4 );
	je movs_segment_ok;
	call store_segment_prefix;
  movs_segment_ok:
	mov( $0A4, al );
	mov( operand_size, bl );
	cmp( bl, 1 );
	je simple_instruction;
	inc( al );
	cmp( bl, 2 );
	je simple_instruction_16bit;
	cmp( bl, 4 );
	je simple_instruction_32bit;
	cmp( bl, 8 );
	je simple_instruction_64bit;
	or( bl, bl );
	jz operand_size_not_specified;
	jmp invalid_operand_size;
  lods_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	or( eax, eax );
	jnz invalid_address;
	or( ch, bl );
	jnz invalid_address;
	cmp( bh, $26 );
	je lods_address_16bit;
	cmp( bh, $46 );
	je lods_address_32bit;
	cmp( bh, $86 );
	jne invalid_address;
	cmp( code_type, 64 );
	jne invalid_address_size;
	jmp lods_store;
  lods_address_32bit:
	call address_32bit_prefix;
	jmp lods_store;
  lods_address_16bit:
	cmp( code_type, 64 );
	je invalid_address_size;
	call address_16bit_prefix;
  lods_store:
	cmp( segment_register, 4 );
	je lods_segment_ok;
	call store_segment_prefix;
  lods_segment_ok:
	mov( $0AC, al );
	mov( operand_size, bl );
	cmp( bl, 1 );
	je simple_instruction;
	inc( al );
	cmp( bl, 2 );
	je simple_instruction_16bit;
	cmp( bl, 4 );
	je simple_instruction_32bit;
	cmp( bl, 8 );
	je simple_instruction_64bit;
	or( bl, bl );
	jz operand_size_not_specified;
	jmp invalid_operand_size;
  stos_instruction::
	mov( al, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	or( eax, eax );
	jnz invalid_address;
	or( ch, bl );
	jnz invalid_address;
	cmp( bh, $27 );
	je stos_address_16bit;
	cmp( bh, $47 );
	je stos_address_32bit;
	cmp( bh, $87 );
	jne invalid_address;
	cmp( code_type, 64 );
	jne invalid_address_size;
	jmp stos_store;
  stos_address_32bit:
	call address_32bit_prefix;
	jmp stos_store;
  stos_address_16bit:
	cmp( code_type, 64 );
	je invalid_address_size;
	call address_16bit_prefix;
  stos_store:
	cmp( segment_register, 1 );
	ja invalid_address;
	mov( base_code, al );
	mov( operand_size, bl );
	cmp( bl, 1 );
	je simple_instruction;
	inc( al );
	cmp( bl, 2 );
	je simple_instruction_16bit;
	cmp( bl, 4 );
	je simple_instruction_32bit;
	cmp( bl, 8 );
	je simple_instruction_64bit;
	or( bl, bl );
	jz operand_size_not_specified;
	jmp invalid_operand_size;
  cmps_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	or( eax, eax );
	jnz invalid_address;
	or( ch, bl );
	jnz invalid_address;
	mov( segment_register, al );
	push( ax );
	push( bx );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	or( eax, eax );
	jnz invalid_address;
	or( ch, bl );
	jnz invalid_address;
	pop( dx );
	pop( ax );
	cmp( segment_register, 1 );
	ja invalid_address;
	mov( al, segment_register );
	mov( dh, al );
	mov( bh, ah );
	shr( 4, al );
	shr( 4, ah );
	cmp( al, ah );
	jne address_sizes_do_not_agree;
	and( %111, bh );
	and( %111, dh );
	cmp( bh, 7 );
	jne invalid_address;
	cmp( dh, 6 );
	jne invalid_address;
	cmp( al, 2 );
	je cmps_address_16bit;
	cmp( al, 4 );
	je cmps_address_32bit;
	cmp( code_type, 64 );
	jne invalid_address_size;
	jmp cmps_store;
  cmps_address_32bit:
	call address_32bit_prefix;
	jmp cmps_store;
  cmps_address_16bit:
	cmp( code_type, 64 );
	je invalid_address_size;
	call address_16bit_prefix;
  cmps_store:
	cmp( segment_register, 4 );
	je cmps_segment_ok;
	call store_segment_prefix;
  cmps_segment_ok:
	mov( $0A6, al );
	mov( operand_size, bl );
	cmp( bl, 1 );
	je simple_instruction;
	inc( al );
	cmp( bl, 2 );
	je simple_instruction_16bit;
	cmp( bl, 4 );
	je simple_instruction_32bit;
	cmp( bl, 8 );
	je simple_instruction_64bit;
	or( bl, bl );
	jz operand_size_not_specified;
	jmp invalid_operand_size;
  ins_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	or( eax, eax );
	jnz invalid_address;
	or( ch, bl );
	jnz invalid_address;
	cmp( bh, $27 );
	je ins_address_16bit;
	cmp( bh, $47 );
	je ins_address_32bit;
	cmp( bh, $87 );
	jne invalid_address;
	cmp( code_type, 64 );
	jne invalid_address_size;
	jmp ins_store;
  ins_address_32bit:
	call address_32bit_prefix;
	jmp ins_store;
  ins_address_16bit:
	cmp( code_type, 64 );
	je invalid_address_size;
	call address_16bit_prefix;
  ins_store:
	cmp( segment_register, 1 );
	ja invalid_address;
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	cmp( al, '"' );
	jne invalid_operand;
	mov( $6C, al );
	mov( operand_size, bl );
	cmp( bl, 1 );
	je simple_instruction;
	inc( al );
	cmp( bl, 2 );
	je simple_instruction_16bit;
	cmp( bl, 4 );
	je simple_instruction_32bit;
	or( bl, bl );
	jz operand_size_not_specified;
	jmp invalid_operand_size;
  outs_instruction::
	lodsb;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	cmp( al, '"' );
	jne invalid_operand;
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	or( eax, eax );
	jnz invalid_address;
	or( ch, bl );
	jnz invalid_address;
	cmp( bh, $26 );
	je outs_address_16bit;
	cmp( bh, $46 );
	je outs_address_32bit;
	cmp( bh, $86 );
	jne invalid_address;
	cmp( code_type, 64 );
	jne invalid_address_size;
	jmp outs_store;
  outs_address_32bit:
	call address_32bit_prefix;
	jmp outs_store;
  outs_address_16bit:
	cmp( code_type, 64 );
	je invalid_address_size;
	call address_16bit_prefix;
  outs_store:
	cmp( segment_register, 4 );
	je outs_segment_ok;
	call store_segment_prefix;
  outs_segment_ok:
	mov( $6E, al );
	mov( operand_size, bl );
	cmp( bl, 1 );
	je simple_instruction;
	inc( al );
	cmp( bl, 2 );
	je simple_instruction_16bit;
	cmp( bl, 4 );
	je simple_instruction_32bit;
	or( bl, bl );
	jz operand_size_not_specified;
	jmp invalid_operand_size;
  xlat_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	or( eax, eax );
	jnz invalid_address;
	or( ch, bl );
	jnz invalid_address;
	cmp( bh, $23 );
	je xlat_address_16bit;
	cmp( bh, $43 );
	je xlat_address_32bit;
	cmp( bh, $83 );
	jne invalid_address;
	cmp( code_type, 64 );
	jne invalid_address_size;
	jmp xlat_store;
  xlat_address_32bit:
	call address_32bit_prefix;
	jmp xlat_store;
  xlat_address_16bit:
	cmp( code_type, 64 );
	je invalid_address_size;
	call address_16bit_prefix;
  xlat_store:
	call store_segment_prefix_if_necessary;
	mov( $0D7, al );
	cmp( operand_size, 1 );
	jbe simple_instruction;
	jmp invalid_operand_size;

  pm_word_instruction::
	mov( al, ah );
	shr( 4, ah );
	and( %111, al );
	mov( $0F, base_code );
	mov( ah, extended_code );
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je pm_reg;
  pm_mem:
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	cmp( al, 2 );
	je pm_mem_store;
	or( al, al );
	jnz invalid_operand_size;
  pm_mem_store:
	call store_instruction;
	jmp instruction_assembled;
  pm_reg:
	lodsb;
	call convert_register;
	mov( al, bl );
	cmp( ah, 2 );
	jne invalid_operand_size;
	call store_nomem_instruction;
	jmp instruction_assembled;
  pm_store_word_instruction::
	mov( al, ah );
	shr( 4, ah );
	and( %111, al );
	mov( $0F, base_code );
	mov( ah, extended_code );
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne pm_mem;
	lodsb;
	call convert_register;
	mov( al, bl );
	mov( ah, al );
	call operand_autodetect;
	call store_nomem_instruction;
	jmp instruction_assembled;
  lgdt_instruction::
	mov( $0F, base_code );
	mov( 1, extended_code );
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	cmp( al, 6 );
	je lgdt_mem_48bit;
	cmp( al, 10 );
	je lgdt_mem_80bit;
	or( al, al );
	jnz invalid_operand_size;
	jmp lgdt_mem_store;
  lgdt_mem_80bit:
	cmp( code_type, 64 );
	jne illegal_instruction;
	jmp lgdt_mem_store;
  lgdt_mem_48bit:
	cmp( code_type, 64 );
	je illegal_instruction;
	cmp( postbyte_register, 2 );
	jb lgdt_mem_store;
	call operand_32bit;
  lgdt_mem_store:
	call store_instruction;
	jmp instruction_assembled;
  lar_instruction::
	mov( al, extended_code );
	mov( $0F, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	xor( al, al );
	xchg( operand_size, al );
	call operand_autodetect;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je lar_reg_reg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	or( al, al );
	jz lar_reg_mem;
	cmp( al, 2 );
	jne invalid_operand_size;
  lar_reg_mem:
	call store_instruction;
	jmp instruction_assembled;
  lar_reg_reg:
	lodsb;
	call convert_register;
	cmp( ah, 2 );
	jne invalid_operand_size;
	mov( al, bl );
	call store_nomem_instruction;
	jmp instruction_assembled;
  invlpg_instruction::
	mov( $0F, base_code );
	mov( 1, extended_code );
	mov( 7, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	call store_instruction;
	jmp instruction_assembled;
  swapgs_instruction::
	mov( $0F, base_code );
	mov( 1, extended_code );
	mov( 7, postbyte_register );
	mov( al, bl );
	call store_nomem_instruction;
	jmp instruction_assembled;

  basic_486_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je basic_486_reg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	push( edx );
	push( bx );
	push( cx );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	pop( cx );
	pop( bx );
	pop( edx );
	mov( ah, al );
	cmp( al, 1 );
	je basic_486_mem_reg_8bit;
	call operand_autodetect;
	inc( extended_code );
  basic_486_mem_reg_8bit:
	call store_instruction;
	jmp instruction_assembled;
  basic_486_reg:
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( postbyte_register, bl );
	mov( al, postbyte_register );
	mov( ah, al );
	cmp( al, 1 );
	je basic_486_reg_reg_8bit;
	call operand_autodetect;
	inc( extended_code );
  basic_486_reg_reg_8bit:
	call store_nomem_instruction;
	jmp instruction_assembled;
  bswap_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	test( %1000, al );
	jz bswap_reg_code_ok;
	or( $41, rex_prefix );
	and( %111, al );
  bswap_reg_code_ok:
	add( $0C8, al );
	mov( al, extended_code );
	mov( $0F, base_code );
	cmp( ah, 8 );
	je bswap_reg64;
	cmp( ah, 4 );
	jne invalid_operand_size;
	call operand_32bit;
	call store_instruction_code;
	jmp instruction_assembled;
  bswap_reg64:
	call operand_64bit;
	call store_instruction_code;
	jmp instruction_assembled;
	
  cmpxchgx_instruction::
	mov( $0F, base_code );
	mov( $0C7, extended_code );
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( 1, ah );
	xchg( ah, postbyte_register );
	mov( operand_size, al );
	or( al, al );
	jz cmpxchgx_size_ok;
	cmp( al, ah );
	jne invalid_operand_size;
  cmpxchgx_size_ok:
	cmp( ah, 16 );
	jne cmpxchgx_store;
	call operand_64bit;
  cmpxchgx_store:
	call store_instruction;
	jmp instruction_assembled;

  basic_fpu_instruction::
	mov( al, postbyte_register );
	mov( $0D8, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je basic_fpu_streg;
	cmp( al, '[' );
	je basic_fpu_mem;
	dec( esi );
	mov( postbyte_register, ah );
	cmp( ah, 2 );
	jb invalid_operand;
	cmp( ah, 3 );
	ja invalid_operand;
	mov( 1, bl );
	call store_nomem_instruction;
	jmp instruction_assembled;
  basic_fpu_mem:
	call get_address;
	mov( operand_size, al );
	cmp( al, 4 );
	je basic_fpu_mem_32bit;
	cmp( al, 8 );
	je basic_fpu_mem_64bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( error_line, 0 );
	jne basic_fpu_mem_32bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
  basic_fpu_mem_32bit:
	call store_instruction;
	jmp instruction_assembled;
  basic_fpu_mem_64bit:
	mov( $0DC, base_code );
	call store_instruction;
	jmp instruction_assembled;
  basic_fpu_streg:
	lodsb;
	call convert_fpu_register;
	mov( al, bl );
	mov( postbyte_register, ah );
	cmp( ah, 2 );
	je basic_fpu_single_streg;
	cmp( ah, 3 );
	je basic_fpu_single_streg;
	or( al, al );
	jz basic_fpu_st0;
	test( %110, ah );
	jz basic_fpu_streg_st0;
	xor( 1, postbyte_register );
  basic_fpu_streg_st0:
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_fpu_register;
	or( al, al );
	jnz invalid_operand;
	mov( $0DC, base_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  basic_fpu_st0:
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_fpu_register;
	mov( al, bl );
  basic_fpu_single_streg:
	mov( $0D8, base_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  simple_fpu_instruction::
	mov( al, ah );
	or( %11000000, ah );
	mov( $0D9, al );
	stosw;
	jmp instruction_assembled;
  fi_instruction::
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	cmp( al, 2 );
	je fi_mem_16bit;
	cmp( al, 4 );
	je fi_mem_32bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( error_line, 0 );
	jne fi_mem_32bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
  fi_mem_32bit:
	mov( $0DA, base_code );
	call store_instruction;
	jmp instruction_assembled;
  fi_mem_16bit:
	mov( $0DE, base_code );
	call store_instruction;
	jmp instruction_assembled;
  fld_instruction::
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je fld_streg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	cmp( al, 4 );
	je fld_mem_32bit;
	cmp( al, 8 );
	je fld_mem_64bit;
	cmp( al, 10 );
	je fld_mem_80bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( error_line, 0 );
	jne fld_mem_32bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
  fld_mem_32bit:
	mov( $0D9, base_code );
	call store_instruction;
	jmp instruction_assembled;
  fld_mem_64bit:
	mov( $0DD, base_code );
	call store_instruction;
	jmp instruction_assembled;
  fld_mem_80bit:
	mov( postbyte_register, al );
	cmp( al, 0 );
	je fld_mem_80bit_store;
	dec( postbyte_register );
	cmp( al, 3 );
	je fld_mem_80bit_store;
	jmp invalid_operand_size;
  fld_mem_80bit_store:
	add( 5, postbyte_register );
	mov( $0DB, base_code );
	call store_instruction;
	jmp instruction_assembled;
  fld_streg:
	lodsb;
	call convert_fpu_register;
	mov( al, bl );
	cmp( postbyte_register, 2 );
	jae fst_streg;
	mov( $0D9, base_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  fst_streg:
	mov( $0DD, base_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  fild_instruction::
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	cmp( al, 2 );
	je fild_mem_16bit;
	cmp( al, 4 );
	je fild_mem_32bit;
	cmp( al, 8 );
	je fild_mem_64bit;
	or( al, al );
	jnz invalid_operand_size;
	cmp( error_line, 0 );
	jne fild_mem_32bit;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &operand_size_not_specified, error );
  fild_mem_32bit:
	mov( $0DB, base_code );
	call store_instruction;
	jmp instruction_assembled;
  fild_mem_16bit:
	mov( $0DF, base_code );
	call store_instruction;
	jmp instruction_assembled;
  fild_mem_64bit:
	mov( postbyte_register, al );
	cmp( al, 1 );
	je fisttp_64bit_store;
	jb fild_mem_64bit_store;
	dec( postbyte_register );
	cmp( al, 3 );
	je fild_mem_64bit_store;
	jmp invalid_operand_size;
  fild_mem_64bit_store:
	add( 5, postbyte_register );
	mov( $0DF, base_code );
	call store_instruction;
	jmp instruction_assembled;
  fisttp_64bit_store:
	mov( $0DD, base_code );
	call store_instruction;
	jmp instruction_assembled;
  fbld_instruction::
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	or( al, al );
	jz fbld_mem_80bit;
	cmp( al, 10 );
	je fbld_mem_80bit;
	jmp invalid_operand_size;
  fbld_mem_80bit:
	mov( $0DF, base_code );
	call store_instruction;
	jmp instruction_assembled;
  faddp_instruction::
	mov( al, postbyte_register );
	mov( $0DE, base_code );
	mov( esi, edx );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je faddp_streg;
	mov( edx, esi );
	mov( 1, bl );
	call store_nomem_instruction;
	jmp instruction_assembled;
  faddp_streg:
	lodsb;
	call convert_fpu_register;
	mov( al, bl );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_fpu_register;
	or( al, al );
	jnz invalid_operand;
	call store_nomem_instruction;
	jmp instruction_assembled;
  fcompp_instruction::
	mov( $0D9DE, ax );
	stosw;
	jmp instruction_assembled;
  fucompp_instruction::
	mov( $0E9DA, ax );
	stosw;
	jmp instruction_assembled;
	
  fxch_instruction::
	mov( $01D9, dx );
	jmp fpu_single_operand;
	
  ffreep_instruction::
	mov( $00DF, dx );
	jmp fpu_single_operand;
	
  ffree_instruction::
	mov( $0DD, dl );
	mov( al, dh );
	
  fpu_single_operand:
	mov( esi, ebx );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je fpu_streg;

	or( dh, dh );
	jz invalid_operand;
	mov( ebx, esi );
	shl( 3, dh );
	or( %11000001, dh );
	mov( dx, ax );
	stosw;
	jmp instruction_assembled;
  fpu_streg:
	lodsb;
	call convert_fpu_register;
	shl( 3, dh );
	or( al, dh );
	or( %11000000, dh );
	mov( dx, ax );
	stosw;
	jmp instruction_assembled;
  fstenv_instruction::
	mov( $9B, (type byte [edi]) );
	inc( edi );
  fldenv_instruction::
	mov( $0D9, base_code );
	jmp fpu_mem;
  fsave_instruction::
	mov( $9B, (type byte [edi]) );
	inc( edi );
  fnsave_instruction::
	mov( $0DD, base_code );
  fpu_mem:
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	cmp( operand_size, 0 );
	jne invalid_operand_size;
	call store_instruction;
	jmp instruction_assembled;
  fstcw_instruction::
	mov( $9B, (type byte [edi]) );
	inc( edi );
  fldcw_instruction::
	mov( al, postbyte_register );
	mov( $0D9, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	or( al, al );
	jz fldcw_mem_16bit;
	cmp( al, 2 );
	je fldcw_mem_16bit;
	jmp invalid_operand_size;
  fldcw_mem_16bit:
	call store_instruction;
	jmp instruction_assembled;
  fstsw_instruction::
	mov( $9B, al );
	stosb;
  fnstsw_instruction::
	mov( $0DD, base_code );
	mov( 7, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je fstsw_reg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	or( al, al );
	jz fstsw_mem_16bit;
	cmp( al, 2 );
	je fstsw_mem_16bit;
	jmp invalid_operand_size;
  fstsw_mem_16bit:
	call store_instruction;
	jmp instruction_assembled;
  fstsw_reg:
	lodsb;
	call convert_register;
	cmp( ax, $0200 );
	jne invalid_operand;
	mov( $0E0DF, ax );
	stosw;
	jmp instruction_assembled;
  finit_instruction::
	mov( $9B, (type byte [edi]) );
	inc( edi );
  fninit_instruction::
	mov( al, ah );
	mov( $0DB, al );
	stosw;
	jmp instruction_assembled;
  fcmov_instruction::
	mov( $0DA, dh );
	jmp fcomi_streg;
  fcomi_instruction::
	mov( $0DB, dh );
	jmp fcomi_streg;
  fcomip_instruction::
	mov( $0DF, dh );
  fcomi_streg:
	mov( al, dl );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_fpu_register;
	mov( al, ah );
	cmp( (type byte [esi]), ',' );
	je fcomi_st0_streg;
	add( dl, ah );
	mov( dh, al );
	stosw;
	jmp instruction_assembled;
  fcomi_st0_streg:
	or( ah, ah );
	jnz invalid_operand;
	inc( esi );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_fpu_register;
	mov( al, ah );
	add( dl, ah );
	mov( dh, al );
	stosw;
	jmp instruction_assembled;

  mmx_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	call make_mmx_prefix;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je mmx_mmreg_mmreg;
	cmp( al, '[' );
	jne invalid_operand;
  mmx_mmreg_mem:
	call get_address;
	call store_instruction;
	jmp instruction_assembled;
  mmx_mmreg_mmreg:
	lodsb;
	call convert_mmx_register;
	mov( al, bl );
	call store_nomem_instruction;
	jmp instruction_assembled;
  mmx_ps_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	call make_mmx_prefix;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	mov( 0, operand_size );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je mmx_mmreg_mmreg;
	cmp( al, '(' );
	je mmx_ps_mmreg_imm8;
	cmp( al, '[' );
	je mmx_mmreg_mem;
	jmp invalid_operand;
  mmx_ps_mmreg_imm8:
	call get_byte_value;
	mov( al, (type byte value) );
	test( _byte( !1 ), operand_size );
	jnz invalid_value;
	mov( extended_code, bl );
	mov( bl, al );
	shr( 4, bl );
	and( %1111, al );
	add( $70, al );
	mov( al, extended_code );
	sub( $0C, bl );
	shl( 1, bl );
	xchg( postbyte_register, bl );
	call store_nomem_instruction;
	mov( (type byte value), al );
	stosb;
	jmp instruction_assembled;
  pextrw_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	cmp( ah, 4 );
	jnz invalid_operand_size;
	mov( al, postbyte_register );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	mov( al, bl );
	call make_mmx_prefix;
	cmp( extended_code, $0C5 );
	je mmx_nomem_imm8;
	call store_nomem_instruction;
	jmp instruction_assembled;
  mmx_imm8:
	push( bx );
	push( cx );
	push( edx );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	test( _byte( !1 ), ah );
	jnz invalid_operand_size;
	cmp( al, '(' );
	jne invalid_operand;
	call get_byte_value;
	mov( al, (type byte value) );
	pop( edx );
	pop( cx );
	pop( bx );
	call store_instruction_with_imm8;
	jmp instruction_assembled;
  mmx_nomem_imm8:
	call store_nomem_instruction;
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	test( _byte( !1 ), ah );
	jnz invalid_operand_size;
	cmp( al, '(' );
	jne invalid_operand;
	call get_byte_value;
	stosb;
	jmp instruction_assembled;
  pinsrw_instruction::
	mov( al, extended_code );
	mov( $0F, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	call make_mmx_prefix;
	mov( al, postbyte_register );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je pinsrw_mmreg_reg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	cmp( operand_size, 0 );
	je mmx_imm8;
	cmp( operand_size, 2 );
	jne invalid_operand_size;
	jmp mmx_imm8;
  pinsrw_mmreg_reg:
	lodsb;
	call convert_register;
	cmp( ah, 4 );
	jne invalid_operand_size;
	mov( al, bl );
	jmp mmx_nomem_imm8;
  pshufw_instruction::
	mov( 8, mmx_size );
	mov( al, operand_prefix );
	jmp pshuf_instruction;
  pshufd_instruction::
	mov( 16, mmx_size );
	mov( al, operand_prefix );
  pshuf_instruction::
	mov( $0F, base_code );
	mov( $70, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, mmx_size );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je pshuf_mmreg_mmreg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	jmp mmx_imm8;
  pshuf_mmreg_mmreg:
	lodsb;
	call convert_mmx_register;
	mov( al, bl );
	jmp mmx_nomem_imm8;
  movd_instruction::
	mov( $0F, base_code );
	mov( $7E, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je movd_reg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	test( _byte( !4 ), operand_size );
	jnz invalid_operand_size;
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	call make_mmx_prefix;
	mov( al, postbyte_register );
	call store_instruction;
	jmp instruction_assembled;
  movd_reg:
	lodsb;
	cmp( al, $0B0 );
	jae movd_mmreg;
	call convert_register;
	cmp( ah, 4 );
	jne invalid_operand_size;
	mov( 0, operand_size );
	mov( al, bl );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	mov( al, postbyte_register );
	call make_mmx_prefix;
	call store_nomem_instruction;
	jmp instruction_assembled;
	
  movd_mmreg:
	mov( $6E, extended_code );
	call convert_mmx_register;
	call make_mmx_prefix;
	mov( al, postbyte_register );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je movd_mmreg_reg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	test( _byte( !4 ), operand_size );
	jnz invalid_operand_size;
	call store_instruction;
	jmp instruction_assembled;
	
  movd_mmreg_reg:
	lodsb;
	call convert_register;
	cmp( ah, 4 );
	jne invalid_operand_size;
	mov( al, bl );
	call store_nomem_instruction;
	jmp instruction_assembled;
	
  movq_instruction::
	mov( $0F, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je movq_reg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	test( _byte( !8 ), operand_size );
	jnz invalid_operand_size;
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	mov( al, postbyte_register );
	cmp( ah, 16 );
	je movq_mem_xmmreg;
	mov( $7F, extended_code );
	call store_instruction;
	jmp instruction_assembled;
  movq_mem_xmmreg:
	mov( $0D6, extended_code );
	mov( $66, operand_prefix );
	call store_instruction;
	jmp instruction_assembled;
  movq_reg:
	lodsb;
	cmp( al, $0B0 );
	jae movq_mmreg;
	call convert_register;
	cmp( ah, 8 );
	jne invalid_operand_size;
	mov( 0, operand_size );
	mov( al, bl );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	mov( al, postbyte_register );
	call make_mmx_prefix;
	mov( $7E, extended_code );
	call operand_64bit;
	call store_nomem_instruction;
	jmp instruction_assembled;
  movq_mmreg:
	call convert_mmx_register;
	mov( al, postbyte_register );
	mov( $6F, extended_code );
	mov( ah, mmx_size );
	cmp( ah, 16 );
	jne movq_mmreg_;
	mov( $7E, extended_code );
	mov( $0F3, operand_prefix );
  movq_mmreg_:
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	mov( 0, operand_size );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je movq_mmreg_reg;
	call get_address;
	test( _byte( !8 ), operand_size );
	jnz invalid_operand_size;
	call store_instruction;
	jmp instruction_assembled;
  movq_mmreg_reg:
	lodsb;
	cmp( al, $0B0 );
	jae movq_mmreg_mmreg;
	mov( 0, operand_size );
	call convert_register;
	cmp( ah, 8 );
	jne invalid_operand_size;
	mov( $6E, extended_code );
	mov( 0, operand_prefix );
	mov( al, bl );
	cmp( mmx_size, 16 );
	jne movq_mmreg_reg_store;
	mov( $66, operand_prefix );
  movq_mmreg_reg_store:
	call operand_64bit;
	call store_nomem_instruction;
	jmp instruction_assembled;
  movq_mmreg_mmreg:
	call convert_mmx_register;
	mov( al, bl );
	call store_nomem_instruction;
	jmp instruction_assembled;
  movdq_instruction::
	mov( al, operand_prefix );
	mov( $0F, base_code );
	mov( $6F, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je movdq_mmreg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	mov( $7F, extended_code );
	call store_instruction;
	jmp instruction_assembled;
  movdq_mmreg:
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je movdq_mmreg_mmreg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	call store_instruction;
	jmp instruction_assembled;
  movdq_mmreg_mmreg:
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, bl );
	call store_nomem_instruction;
	jmp instruction_assembled;
  lddqu_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	push( eax );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	pop( eax );
	mov( al, postbyte_register );
	mov( $0F2, operand_prefix );
	mov( $0F, base_code );
	mov( $0F0, extended_code );
	call store_instruction;
	jmp instruction_assembled;
  movq2dq_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 8 );
	jne invalid_operand_size;
	mov( al, bl );
	mov( $0F3, operand_prefix );
	mov( $0F, base_code );
	mov( $0D6, extended_code );
	call store_nomem_instruction;
	jmp instruction_assembled;
  movdq2q_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 8 );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, bl );
	mov( $0F2, operand_prefix );
	mov( $0F, base_code );
	mov( $0D6, extended_code );
	call store_nomem_instruction;
	jmp instruction_assembled;

  sse_ps_instruction::
	mov( 16, mmx_size );
	jmp sse_instruction;
	
  sse_pd_instruction::
	mov( 16, mmx_size );
	mov( $66, operand_prefix );
	jmp sse_instruction;
  sse_ss_instruction::
	mov( 4, mmx_size );
	mov( $0F3, operand_prefix );
	jmp sse_instruction;
  sse_sd_instruction::
	mov( 8, mmx_size );
	mov( $0F2, operand_prefix );
	jmp sse_instruction;
  comiss_instruction::
	mov( 4, mmx_size );
	jmp sse_instruction;
  comisd_instruction::
	mov( 8, mmx_size );
	mov( $66, operand_prefix );
	jmp sse_instruction;
  cvtps2pd_instruction::
	mov( 8, mmx_size );
	jmp sse_instruction;
  cvtpd2dq_instruction::
	mov( 16, mmx_size );
	mov( $0F2, operand_prefix );
	jmp sse_instruction;
	
  cvtdq2pd_instruction::
	mov( 16, mmx_size );
	mov( $0F3, operand_prefix );
	
  sse_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	
  sse_xmmreg:
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
  sse_reg:
	mov( al, postbyte_register );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je sse_xmmreg_xmmreg;
  sse_reg_mem:
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	cmp( operand_size, 0 );
	je sse_mem_size_ok;
	mov( mmx_size, al );
	cmp( operand_size, al );
	jne invalid_operand_size;
  sse_mem_size_ok:
	cmp( extended_code, $0C6 );
	je mmx_imm8;
	call store_instruction;
	jmp instruction_assembled;
  sse_xmmreg_xmmreg:
	cmp( operand_prefix, $66 );
	jne sse_xmmreg_xmmreg_ok;
	cmp( extended_code, $12 );
	je invalid_operand;
	cmp( extended_code, $16 );
	je invalid_operand;
  sse_xmmreg_xmmreg_ok:
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, bl );
	cmp( extended_code, $0C6 );
	je mmx_nomem_imm8;
	call store_nomem_instruction;
	jmp instruction_assembled;
  ps_dq_instruction::
	mov( al, postbyte_register );
	mov( $66, operand_prefix );
	mov( $0F, base_code );
	mov( $73, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, bl );
	jmp mmx_nomem_imm8;
  movpd_instruction::
	mov( $66, operand_prefix );
  movps_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	mov( 16, mmx_size );
	jmp sse_mov_instruction;
  movss_instruction::
	mov( 4, mmx_size );
	mov( $0F3, operand_prefix );
	jmp sse_movs;
  movsd_instruction::
	mov( $0A5, al );
	mov( [esi], ah );
	or( ah, ah );
	jz simple_instruction_32bit;
	cmp( ah, $0F );
	je simple_instruction_32bit;
	mov( 8, mmx_size );
	mov( $0F2, operand_prefix );
  sse_movs:
	mov( $0F, base_code );
	mov( $10, extended_code );
	jmp sse_mov_instruction;
  sse_mov_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je sse_xmmreg;
  sse_mem:
	cmp( al, '[' );
	jne invalid_operand;
	inc( extended_code );
	call get_address;
	cmp( operand_size, 0 );
	je sse_mem_xmmreg;
	mov( mmx_size, al );
	cmp( operand_size, al );
	jne invalid_operand_size;
	mov( 0, operand_size );
  sse_mem_xmmreg:
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	call store_instruction;
	jmp instruction_assembled;
  movlpd_instruction::
	mov( $66, operand_prefix );
  movlps_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	mov( 8, mmx_size );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne sse_mem;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	jmp sse_reg_mem;
  movhlps_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	mov( 0, mmx_size );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je sse_xmmreg_xmmreg_ok;
	jmp invalid_operand;
  maskmovq_instruction::
	mov( 8, cl );
	jmp maskmov_instruction;
	
  maskmovdqu_instruction::
	mov( 16, cl );
	mov( $66, operand_prefix );
  maskmov_instruction::
	mov( $0F, base_code );
	mov( $0F7, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, cl );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	mov( al, bl );
	call store_nomem_instruction;
	jmp instruction_assembled;
  movmskpd_instruction::
	mov( $66, operand_prefix );
  movmskps_instruction::
	mov( $0F, base_code );
	mov( $50, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	cmp( ah, 4 );
	jne invalid_operand_size;
	mov( 0, operand_size );
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, bl );
	call store_nomem_instruction;
	jmp instruction_assembled;
  cmppd_instruction::
	mov( $66, operand_prefix );
  cmpps_instruction::
	mov( $0F, base_code );
	mov( $0C2, extended_code );
	mov( 16, mmx_size );
	mov( -1, (type byte value) );
	jmp sse_cmp_instruction;
  cmp_pd_instruction::
	mov( $66, operand_prefix );
	
  cmp_ps_instruction::
	mov( $0F, base_code );
	mov( $0C2, extended_code );
	mov( 16, mmx_size );
	mov( al, (type byte value) );
	jmp sse_cmp_instruction;
	
  cmpss_instruction::
	mov( 4, mmx_size );
	mov( $0F3, operand_prefix );
	jmp cmpsx_instruction;
  cmpsd_instruction::
	mov( $0A7, al );
	mov( [esi], ah );
	or( ah, ah );
	jz simple_instruction_32bit;
	cmp( ah, $0F );
	je simple_instruction_32bit;
	mov( 8, mmx_size );
	mov( $0F2, operand_prefix );
  cmpsx_instruction::
	mov( $0F, base_code );
	mov( $0C2, extended_code );
	mov( -1, (type byte value) );
	jmp sse_cmp_instruction;
	
  cmp_ss_instruction::
	mov( 4, mmx_size );
	mov( $0F3, operand_prefix );
	jmp cmp_sx_instruction;
	
  cmp_sd_instruction::
	mov( 8, mmx_size );
	mov( $0F2, operand_prefix );
	
  cmp_sx_instruction::
	mov( $0F, base_code );
	mov( $0C2, extended_code );
	mov( al, (type byte value) );
	
  sse_cmp_instruction::
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	mov( 0, operand_size );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je sse_cmp_xmmreg_xmmreg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	or( al, al );
	jz sse_cmp_size_ok;
	cmp( al, mmx_size );
	jne invalid_operand_size;
  sse_cmp_size_ok:
	push( bx );
	push( cx );
	push( edx );
	call get_nextbyte;
	pop( edx );
	pop( cx );
	pop( bx );
	call store_instruction_with_imm8;
	jmp instruction_assembled;
  sse_cmp_xmmreg_xmmreg:
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, bl );
	call store_nomem_instruction;
	call get_nextbyte;
	mov( (type byte value), al );
	stosb;
	jmp instruction_assembled;
	
  cvtpi2pd_instruction::
	mov( $66, operand_prefix );
  cvtpi2ps_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je cvtpi_xmmreg_xmmreg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	cmp( operand_size, 0 );
	je cvtpi_size_ok;
	cmp( operand_size, 8 );
	jne invalid_operand_size;
  cvtpi_size_ok:
	call store_instruction;
	jmp instruction_assembled;
  cvtpi_xmmreg_xmmreg:
	lodsb;
	call convert_mmx_register;
	cmp( ah, 8 );
	jne invalid_operand_size;
	mov( al, bl );
	call store_nomem_instruction;
	jmp instruction_assembled;
  cvtsi2ss_instruction::
	mov( $0F3, operand_prefix );
	jmp cvtsi_instruction;
  cvtsi2sd_instruction::
	mov( $0F2, operand_prefix );
  cvtsi_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 16 );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	mov( 0, operand_size );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je cvtsi_xmmreg_reg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	cmp( operand_size, 0 );
	je cvtsi_size_ok;
	cmp( operand_size, 4 );
	jne invalid_operand_size;
  cvtsi_size_ok:
	call store_instruction;
	jmp instruction_assembled;
  cvtsi_xmmreg_reg:
	lodsb;
	call convert_register;
	cmp( ah, 4 );
	je cvtsi_xmmreg_reg_store;
	cmp( ah, 8 );
	jne invalid_operand_size;
	call operand_64bit;
  cvtsi_xmmreg_reg_store:
	mov( al, bl );
	call store_nomem_instruction;
	jmp instruction_assembled;
  cvtps2pi_instruction::
	mov( 8, mmx_size );
	jmp cvtpd_instruction;
  cvtpd2pi_instruction::
	mov( $66, operand_prefix );
	mov( 16, mmx_size );
  cvtpd_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 8 );
	jne invalid_operand_size;
	mov( 0, operand_size );
	jmp sse_reg;
  cvtss2si_instruction::
	mov( $0F3, operand_prefix );
	mov( 4, mmx_size );
	jmp cvt2si_instruction;
  cvtsd2si_instruction::
	mov( $0F2, operand_prefix );
	mov( 8, mmx_size );
  cvt2si_instruction::
	mov( al, extended_code );
	mov( $0F, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( 0, operand_size );
	cmp( ah, 4 );
	je sse_reg;
	cmp( ah, 8 );
	jne invalid_operand_size;
	call operand_64bit;
	jmp sse_reg;
  amd3dnow_instruction::
	mov( $0F, base_code );
	mov( $0F, extended_code );
	mov( al, (type byte value) );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, 8 );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	je amd3dnow_mmreg_mmreg;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	call store_instruction_with_imm8;
	jmp instruction_assembled;
  amd3dnow_mmreg_mmreg:
	lodsb;
	call convert_mmx_register;
	cmp( ah, 8 );
	jne invalid_operand_size;
	mov( al, bl );
	call store_nomem_instruction;
	mov( (type byte value), al );
	stosb;
	jmp instruction_assembled;

  fxsave_instruction::
	mov( $0AE, extended_code );
	mov( $0F, base_code );
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, ah );
	or( ah, ah );
	jz fxsave_size_ok;
	mov( postbyte_register, al );
	cmp( al, %111 );
	je clflush_size_check;
	cmp( al, %10 );
	jb invalid_operand_size;
	cmp( al, %11 );
	ja invalid_operand_size;
	cmp( ah, 4 );
	jne invalid_operand_size;
	jmp fxsave_size_ok;
  clflush_size_check:
	cmp( ah, 1 );
	jne invalid_operand_size;
  fxsave_size_ok:
	call store_instruction;
	jmp instruction_assembled;
	
  prefetch_instruction::
	mov( $18, extended_code );
  prefetch_mem_8bit:
	mov( $0F, base_code );
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	or( ah, ah );
	jz prefetch_size_ok;
	cmp( ah, 1 );
	jne invalid_operand_size;
  prefetch_size_ok:
	call get_address;
	call store_instruction;
	jmp instruction_assembled;
	
  amd_prefetch_instruction::
	mov( $0D, extended_code );
	jmp prefetch_mem_8bit;
  fence_instruction::
	mov( al, bl );
	mov( $0AE0F, ax );
	stosw;
	mov( bl, al );
	stosb;
	jmp instruction_assembled;
  pause_instruction::
	mov( $90F3, ax );
	stosw;
	jmp instruction_assembled;
  movntq_instruction::
	mov( 8, mmx_size );
	jmp movnt_instruction;
  movntps_instruction::
	mov( 16, mmx_size );
	jmp movnt_instruction;
  movntdq_instruction::
	mov( $66, operand_prefix );
	mov( 16, mmx_size );
  movnt_instruction::
	mov( al, extended_code );
	mov( $0F, base_code );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_mmx_register;
	cmp( ah, mmx_size );
	jne invalid_operand_size;
	mov( al, postbyte_register );
	call store_instruction;
	jmp instruction_assembled;
  movnti_instruction::
	mov( $0F, base_code );
	mov( al, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	cmp( ah, 4 );
	je movnti_store;
	cmp( ah, 8 );
	jne invalid_operand_size;
	call operand_64bit;
  movnti_store:
	mov( al, postbyte_register );
	call store_instruction;
	jmp instruction_assembled;
  monitor_instruction::
	mov( al, postbyte_register );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	cmp( ax, $0400 );
	jne invalid_operand;
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	cmp( ax, $0401 );
	jne invalid_operand;
	cmp( postbyte_register, $0C8 );
	jne monitor_instruction_store;
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	cmp( ax, $0402 );
	jne invalid_operand;
  monitor_instruction_store:
	mov( $010F, ax );
	stosw;
	mov( postbyte_register, al );
	stosb;
	jmp instruction_assembled;

  simple_vmx_instruction::
	mov( al, ah );
	mov( $0F, al );
	stosb;
	mov( 1, al );
	stosw;
	jmp instruction_assembled;
  vmclear_instruction::
	mov( $66, operand_prefix );
	jmp vmx_instruction;
  vmxon_instruction::
	mov( $0F3, operand_prefix );
  vmx_instruction::
	mov( al, postbyte_register );
	mov( $0C7, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	mov( operand_size, al );
	or( al, al );
	jz vmx_size_ok;
	cmp( al, 8 );
	jne invalid_operand_size;
  vmx_size_ok:
	mov( $0F, base_code );
	call store_instruction;
	jmp instruction_assembled;
  vmread_instruction::
	mov( $78, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
  vmread_check_size:
	cmp( code_type, 64 );
	je vmread_long;
	cmp( operand_size, 4 );
	je vmx_size_ok;
	jmp invalid_operand_size;
  vmread_long:
	cmp( operand_size, 8 );
	je vmx_size_ok;
	jmp invalid_operand_size;
  vmwrite_instruction::
	mov( $79, extended_code );
	lodsb;
	call get_size_operator;
	cmp( al, $10 );
	jne invalid_operand;
	lodsb;
	call convert_register;
	mov( al, postbyte_register );
	lodsb;
	cmp( al, ',' );
	jne invalid_operand;
	lodsb;
	call get_size_operator;
	cmp( al, '[' );
	jne invalid_operand;
	call get_address;
	jmp vmread_check_size;


	debugStr( "format_directive" );
	
  format_directive::
	cmp( edi, code_start );
	jne unexpected_instruction;
	
	cmp( virtual_data, 0 );
	jne unexpected_instruction;
	
	cmp( output_format, 0 );
	jne unexpected_instruction;
	
	lodsb;
	cmp( al, $17 );
	je format_prefix;
	
	cmp( al, $18 );
	jne invalid_argument;
	lodsb;
	
  select_format:
	mov( al, dl );
	shr( 4, al );
	mov( al, output_format );
	and( $0F, edx );
	or( edx, format_flags );
	cmp( al, 2 );
	je format_mz;
	
	cmp( al, 3 );
	je format_pe;
	
	cmp( al, 4 );
	je format_coff;
	
	cmp( al, 5 );
	je format_elf;
	jmp instruction_assembled;
	
  format_prefix:
	lodsb;
	mov( al, ah );
	lodsb;
	cmp( al, $18 );
	jne invalid_argument;
	lodsb;
	mov( eax, edx );
	shr( 4, dl );
	shr( 4, dh );
	cmp( dl, dh );
	jne invalid_argument;
	or( ah, al );
	jmp select_format;
  entry_directive::
	bts( $10, format_flags );
	jc setting_already_specified;
	mov( output_format, al );
	cmp( al, 2 );
	je mz_entry;
	cmp( al, 3 );
	je pe_entry;
	cmp( al, 5 );
	jne illegal_instruction;
	bt( 0, format_flags );
	jc elf_entry;
	jmp illegal_instruction;
  stack_directive::
	bts( $11, format_flags );
	jc setting_already_specified;
	mov( output_format, al );
	cmp( al, 2 );
	je mz_stack;
	cmp( al, 3 );
	je pe_stack;
	jmp illegal_instruction;
  heap_directive::
	bts( $12, format_flags );
	jc setting_already_specified;
	mov( output_format, al );
	cmp( al, 2 );
	je mz_heap;
	cmp( al, 3 );
	je pe_heap;
	jmp illegal_instruction;
  segment_directive::
	cmp( virtual_data, 0 );
	jne illegal_instruction;
	mov( output_format, al );
	cmp( al, 2 );
	je mz_segment;
	cmp( al, 5 );
	je elf_segment;
	jmp illegal_instruction;
	
  section_directive::
	cmp( virtual_data, 0 );
	jne illegal_instruction;
	
	mov( output_format, al );
	cmp( al, 3 );
	je pe_section;
	
	cmp( al, 4 );
	je coff_section;
	
	cmp( al, 5 );
	je elf_section;
	jmp illegal_instruction;
	
  public_directive::
	mov( output_format, al );
	cmp( al, 4 );
	je public_allowed;
	cmp( al, 5 );
	jne illegal_instruction;
	bt( 0, format_flags );
	jc illegal_instruction;
  public_allowed:
	lodsb;
	cmp( al, 2 );
	jne invalid_argument;
	lodsd;
	cmp( eax, $0F );
	jb invalid_use_of_symbol;
	je reserved_word_used_as_symbol;
	mov( current_pass, dx );
	mov( dx, [eax+18] );
	or( 8, (type byte [eax+8]) );
	inc( esi );
	mov( free_additional_memory, ebx );
	lea( edx, [ebx+$10] );
	out_of_mem( ae, edx, structures_buffer );
	mov( edx, free_additional_memory );
	mov( eax, [ebx+8] );
	mov( current_line, eax );
	mov( eax, [ebx+$0C] );
	lodsb;
	cmp( al, $86 );
	jne invalid_argument;
	lodsw;
	cmp( ax, '(' );
	jne invalid_argument;
	mov( esi, [ebx+4] );
	lodsd;
	lea( esi, [esi+eax+1] );
	mov( $80, (type byte [ebx]) );
	jmp instruction_assembled;
  extrn_directive::
	mov( output_format, al );
	cmp( al, 4 );
	je extrn_allowed;
	cmp( al, 5 );
	jne illegal_instruction;
	bt( 0, format_flags );
	jc illegal_instruction;
  extrn_allowed:
	lodsw;
	cmp( ax, '(' );
	jne invalid_argument;
	mov( esi, ebx );
	lodsd;
	lea( esi, [esi+eax+1] );
	mov( free_additional_memory, edx );
	lea( eax, [edx+$0C] );
	out_of_mem( ae, eax, structures_buffer );
	mov( eax, free_additional_memory );
	mov( $81, (type byte [edx]) );
	mov( ebx, [edx+4] );
	lodsb;
	cmp( al, $86 );
	jne invalid_argument;
	lodsb;
	cmp( al, 2 );
	jne invalid_argument;
	lodsd;
	cmp( eax, $0F );
	jb invalid_use_of_symbol;
	je reserved_word_used_as_symbol;
	inc( esi );
	mov( eax, ebx );
	xor( ah, ah );
	lodsb;
	cmp( al, ':' );
	je get_extrn_size;
	dec( esi );
	cmp( al, $11 );
	jne extrn_size_ok;
  get_extrn_size:
	lodsw;
	cmp( al, $11 );
	jne invalid_argument;
  extrn_size_ok:
	mov( edx, address_symbol );
	movzx( ah, ecx );
	mov( ecx, [edx+8] );
	xor( eax, eax );
	xor( edx, edx );
	xor( ebp, ebp );
	mov( 2, ch );
	test( 8, format_flags );
	jz make_free_label;
	mov( 4, ch );
	jmp make_free_label;
	


  format_mz:
	mov( additional_memory, edx );
	push( edi );
	mov( edx, edi );
	mov( $1C >> 2, ecx );
	xor( eax, eax );
	rep.stosd;
	mov( edi, free_additional_memory );
	pop( edi );
	mov( $0FFFF, (type word [edx+$0C]) );
	mov( $1000, (type word [edx+$10]) );
	mov( 16, code_type );
	jmp instruction_assembled;
	
  format_elf:
	test( 8, format_flags );
	jnz format_elf64;
	mov( edi, edx );
	mov( $34 >> 2, ecx );
	lea( eax, [edi+ecx*4] );
	out_of_mem( ae, eax, display_buffer );
	xor( eax, eax );
	rep.stosd;
	mov( asDword( "ELF" ) << 8 + $7f, (type dword [edx]) );
	mov( 1, al );
	mov( al, [edx+4] );
	mov( al, [edx+5] );
	mov( al, [edx+6] );
	mov( al, [edx+$14] );
	
// Need to emit brand at offset 7
// Brand Values:
//	netbsd = 2
// 	linux  = 3
//   solaris = 6
//   freebsd = 9
//   openbsd = 12
//   qnx = ???
	
	mov( 3, (type byte [edx+$12]) );	// e_machine = EM_386
	mov( $34, (type byte [edx+$28]) );
	mov( $28, (type byte [edx+$2E]) );
	mov( 32, code_type );
	cmp( (type word [esi]), $1D19 );
	je format_elf_exe;
	
	mov( 2, labels_type );
  elf_header_ok:
	mov( 1, (type byte [edx+$10]) );	// e_type = ET_REL
	mov( additional_memory, eax );
	mov( eax, symbols_stream );
	mov( eax, ebx );
	add( $20, eax );
	out_of_mem( ae, eax, structures_buffer );
	mov( eax, free_additional_memory );
	xor( eax, eax );
	mov( ebx, current_section );
	mov( eax, number_of_sections );
	mov( edi, (type dword org_origin) );
	mov( eax, (type dword org_origin[4]) );
	mov( eax, org_registers );
	mov( edi, org_start );
	mov( ebx, org_symbol );
	mov( al, [ebx] );
	mov( eax, [ebx+4] );
	mov( edi, [ebx+8] );
	mov( %111, al );
	mov( eax, [ebx+$14] );
	mov( 4, al );
	mov( eax, [ebx+$10] );
	test( 8, format_flags );
	jz instruction_assembled;
	mov( 8, (type byte [ebx+$10]) );
	jmp instruction_assembled;
	
  format_elf64:
	mov( edi, edx );
	mov( $40 >> 2, ecx );
	lea( eax, [edi+ecx*4] );
	out_of_mem( ae, eax, display_buffer );
	xor( eax, eax );
	rep.stosd;
	mov( asDword( "ELF" ) << 8 + $7f, (type dword [edx]) );
	mov( 1, al );
	mov( al, [edx+5] );
	mov( al, [edx+6] );
	mov( al, [edx+$14] );
	mov( 2, (type byte [edx+4]) );
	mov( 62, (type byte [edx+$12]) );
	mov( $40, (type byte [edx+$34]) );
	mov( $40, (type byte [edx+$3A]) );
	mov( 64, code_type );
	cmp( (type word [esi]), $1D19 );
	je format_elf64_exe;
	mov( 4, labels_type );
	jmp elf_header_ok;
	
  elf_section:
	bt( 0, format_flags );
	jc illegal_instruction;
	
	call close_coff_section;
	mov( free_additional_memory, ebx );
	lea( eax, [ebx+$20] );
	out_of_mem( ae, eax, structures_buffer );
	mov( eax, free_additional_memory );
	mov( ebx, current_section );
	inc( (type word number_of_sections) );
	jz format_limitations_exceeded;
	
	xor( eax, eax );
	mov( al, [ebx] );
	mov( edi, [ebx+8] );
	mov( edi, (type dword org_origin) );
	mov( 0, (type dword org_origin[4]) );
	mov( 0, org_registers );
	mov( edi, org_start );
	mov( ebx, org_symbol );
	test( 8, format_flags );
	jnz elf64_labels_type;
	
	mov( 2, labels_type );
	jmp elf_labels_type_ok;
	
  elf64_labels_type:
	mov( 4, labels_type );
	
  elf_labels_type_ok:
	mov( eax, [ebx+$10] );
	mov( %10, al );
	mov( eax, [ebx+$14] );
	lodsw;
	cmp( ax, '(' );
	jne invalid_argument;
	
	mov( esi, [ebx+4] );
	mov( [esi], ecx );
	lea( esi, [esi+ecx+1+4] );
  elf_section_flags:
	cmp( (type byte [esi]), $1C );
	je elf_section_alignment;
	
	cmp( (type byte [esi]), $19 );
	jne elf_section_settings_ok;
	
	inc( esi );
	lodsb;
	sub( 28, al );
	xor( %11, al );
	test( _byte( !%10 ), al );
	jnz invalid_argument;
	
	mov( al, cl );
	mov( 1, al );
	shl( cl, al );
	test( al, (type byte [ebx+$14]) );
	jnz setting_already_specified;
	or( al, (type byte [ebx+$14]) );
	jmp elf_section_flags;
	
  elf_section_alignment:
	inc( esi );
	lodsb;
	or( al, al );
	jnz invalid_argument;
	
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	push( ebx );
	call get_dword_value;
	pop( ebx );
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
	mov( eax, edx );
	dec( edx );
	test( edx, eax );
	jnz invalid_value;
	or( eax, eax );
	jz invalid_value;
	
	xchg( eax, [ebx+$10] );
	or( eax, eax );
	jnz setting_already_specified;
	jmp elf_section_flags;
	
  elf_section_settings_ok:
	cmp( (type dword [ebx+$10]), 0 );
	jne instruction_assembled;
	
	mov( 4, (type dword [ebx+$10]) );
	test( 8, format_flags );
	jz instruction_assembled;
	
	mov( 8, (type byte [ebx+$10]) );
	jmp instruction_assembled;
	
  format_elf_exe:
	add( 2, esi );
	or( 1, format_flags );
	mov( $8048000, image_base );
	cmp( (type byte [esi]), $80 );
	jne elf_exe_base_ok;
	
	lodsw;
	cmp( ah, '(' );
	jne invalid_argument;
	
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	push( edx );
	call get_dword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
	mov( eax, image_base );
	pop( edx );
  elf_exe_base_ok:
	mov( 2, (type byte [edx+$10]) );
	mov( $20, (type byte [edx+$2A]) );
	mov( edi, ebx );
	mov( $20 >> 2, ecx );
	cmp( current_pass, 0 );
	je init_elf_segments;
	
	intmul( number_of_sections, ecx );
  init_elf_segments:
	xor( eax, eax );
	rep.stosd;
	mov( 0, number_of_sections );
	mov( 1, (type byte [ebx]) );
	mov( $1000, (type word [ebx+$1C]) );
	mov( %111, (type byte [ebx+$18]) );
	mov( edi, eax );
	sub( code_start, eax );
	mov( eax, [ebx+4] );
	add( image_base, eax );
	mov( eax, [ebx+8] );
	mov( eax, [ebx+$0C] );
	mov( eax, [edx+$18] );
	xor( edx, edx );
	not( eax );
	not( edx );
	add( 1, eax );
	adc( 0, edx );
	add( edi, eax );
	adc( 0, edx );
	mov( eax, (type dword org_origin) );
	mov( edx, (type dword org_origin[4]) );
	mov( 0, org_registers );
	mov( edi, org_start );
	mov( edi, symbols_stream );
	jmp instruction_assembled;
	
  format_elf64_exe:
	add( 2, esi );
	or( 1, format_flags );
	mov( $400000, image_base );
	mov( 0, image_base_high );
	cmp( (type byte [esi]), $80 );
	jne elf64_exe_base_ok;
	
	lodsw;
	cmp( ah, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	push( edx );
	call get_qword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
	mov( eax, image_base );
	mov( edx, image_base_high );
	pop( edx );
	
  elf64_exe_base_ok:
	mov( 2, (type byte [edx+$10]) );
	mov( $38, (type byte [edx+$36]) );
	mov( edi, ebx );
	mov( $38 >> 2, ecx );
	cmp( current_pass, 0 );
	je init_elf64_segments;
	
	intmul( number_of_sections, ecx );
  init_elf64_segments:
	xor( eax, eax );
	rep.stosd;
	mov( 0, number_of_sections );
	mov( 1, (type byte [ebx]) );
	mov( $1000, (type word [ebx+$30]) );
	mov( %111, (type byte [ebx+4]) );
	push( edx );
	mov( edi, eax );
	sub( code_start, eax );
	mov( eax, [ebx+8] );
	xor( edx, edx );
	add( image_base, eax );
	adc( image_base_high, edx );
	mov( eax, [ebx+$10] );
	mov( edx, [ebx+$10+4] );
	mov( eax, [ebx+$18] );
	mov( edx, [ebx+$18+4] );
	pop( ebx );
	mov( eax, [ebx+$18] );
	mov( edx, [ebx+$18+4] );
	not( eax );
	not( edx );
	add( 1, eax );
	adc( 0, edx );
	add( edi, eax );
	adc( 0, edx );
	mov( eax, (type dword org_origin) );
	mov( edx, (type dword org_origin[4]) );
	mov( 0, org_registers );
	mov( edi, org_start );
	mov( edi, symbols_stream );
	jmp instruction_assembled;
	
  elf_entry:
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	test( 8, format_flags );
	jnz elf64_entry;
	
	call get_dword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
	mov( code_start, edx );
	mov( eax, [edx+$18] );
	jmp instruction_assembled;
	
  elf64_entry:
	call get_qword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
	mov( code_start, ebx );
	mov( eax, [ebx+$18] );
	mov( edx, [ebx+$1C] );
	jmp instruction_assembled;
	
  elf_segment:
	bt( 0, format_flags );
	jnc illegal_instruction;
	
	test( 8, format_flags );
	jnz elf64_segment;
	
	call close_elf_segment;
	push( eax );
	mov( number_of_sections, ebx );
	shl( 5, ebx );
	add( code_start, ebx );
	add( $34, ebx );
	cmp( ebx, symbols_stream );
	jb new_elf_segment;
	
	mov( symbols_stream, ebx );
	sub( $20, ebx );
	push( edi );
	mov( ebx, edi );
	mov( $20 >> 2, ecx );
	xor( eax, eax );
	rep.stosd;
	pop( edi );
	or( -1, next_pass_needed );
  new_elf_segment:
	mov( 1, (type byte [ebx]) );
	mov( $1000, (type word [ebx+$1C]) );
	
  elf_segment_flags:
	cmp( (type byte [esi]), $19 );
	jne elf_segment_flags_ok;
	
	lodsw;
	sub( 28, ah );
	jbe invalid_argument;
	
	cmp( ah, 1 );
	je mark_elf_segment_flag;
	
	cmp( ah, 3 );
	ja invalid_argument;
	
	xor( 1, ah );
	cmp( ah, 2 );
	je mark_elf_segment_flag;
	
	inc( ah );
  mark_elf_segment_flag:
	test( ah, [ebx+$18] );
	jnz setting_already_specified;
	or( ah, [ebx+$18] );
	jmp elf_segment_flags;
	
  elf_segment_flags_ok:
	mov( edi, eax );
	sub( code_start, eax );
	mov( eax, [ebx+4] );
	pop( edx );
	and( $0FFF, eax );
	add( eax, edx );
	mov( edx, [ebx+8] );
	mov( edx, [ebx+$0C] );
	mov( edx, eax );
	xor( edx, edx );
	not( eax );
	not( edx );
	add( 1, eax );
	adc( 0, edx );
	add( edi, eax );
	adc( 0, edx );
	mov( eax, (type dword org_origin) );
	mov( edx, (type dword org_origin[4]) );
	mov( 0, org_registers );
	mov( edi, org_start );
	inc( number_of_sections );
	jmp instruction_assembled;
	

  elf64_segment:
	call close_elf64_segment;
	push( eax );
	push( edx );
	mov( number_of_sections, ebx );
	intmul( $38, ebx );
	add( code_start, ebx );
	add( $40, ebx );
	cmp( ebx, symbols_stream );
	jb new_elf64_segment;
	
	mov( symbols_stream, ebx );
	sub( $38, ebx );
	push( edi );
	mov( ebx, edi );
	mov( $38 >> 2, ecx );
	xor( eax, eax );
	rep.stosd;
	pop( edi );
	or( -1, next_pass_needed );
	
  new_elf64_segment:
	mov( 1, (type byte [ebx]) );
	mov( $1000, (type word [ebx+$30]) );
	
  elf64_segment_flags:
	cmp( (type byte [esi]), $19 );
	jne elf64_segment_flags_ok;
	lodsw;
	sub( 28, ah );
	jbe invalid_argument;
	
	cmp( ah, 1 );
	je mark_elf64_segment_flag;
	
	cmp( ah, 3 );
	ja invalid_argument;
	
	xor( 1, ah );
	cmp( ah, 2 );
	je mark_elf64_segment_flag;
	
	inc( ah );
  mark_elf64_segment_flag:
	test( ah, [ebx+4] );
	jnz setting_already_specified;
	or( ah, [ebx+4] );
	jmp elf64_segment_flags;
	
  elf64_segment_flags_ok:
	mov( edi, ecx );
	sub( code_start, ecx );
	mov( ecx, [ebx+8] );
	pop( edx );
	pop( eax );
	and( $0FFF, ecx );
	add( ecx, eax );
	adc( 0, edx );
	mov( eax, [ebx+$10] );
	mov( edx, [ebx+$10+4] );
	mov( eax, [ebx+$18] );
	mov( edx, [ebx+$18+4] );
	not( eax );
	not( edx );
	add( 1, eax );
	adc( 0, edx );
	add( edi, eax );
	adc( 0, edx );
	mov( eax, (type dword org_origin) );
	mov( edx, (type dword org_origin[4]) );
	mov( 0, org_registers );
	mov( edi, org_start );
	inc( number_of_sections );
	jmp instruction_assembled;
	

  format_coff:
	mov( additional_memory, eax );
	mov( eax, symbols_stream );
	mov( eax, ebx );
	add( $20, eax );
	out_of_mem( ae, eax, structures_buffer );
	
	mov( eax, free_additional_memory );
	xor( eax, eax );
	mov( al, [ebx] );
	mov( eax, [ebx+4] );
	mov( edi, [ebx+8] );
	mov( 4, al );
	mov( eax, [ebx+$10] );
	mov( $60, al );
	bt( 0, format_flags );
	jnc flat_section_flags_ok;
	
	or( $0E0000000, eax );
	
  flat_section_flags_ok:
	mov( eax, (type dword [ebx+$14]) );
	mov( ebx, current_section );
	mov( 0, number_of_sections );
	mov( edi, (type dword org_origin) );
	mov( 0, (type dword org_origin[4]) );
	mov( 0, org_registers );
	mov( edi, org_start );
	mov( ebx, org_symbol );
	mov( 2, labels_type );
	mov( 32, code_type );
	test( 8, format_flags );
	jz instruction_assembled;
	
	mov( 4, labels_type );
	mov( 64, code_type );
	jmp instruction_assembled;
	
  coff_section:
	call close_coff_section;
	mov( free_additional_memory, ebx );
	lea( eax, [ebx+$20] );
	out_of_mem( ae, eax, structures_buffer );
	
	mov( eax, free_additional_memory );
	mov( ebx, current_section );
	inc( number_of_sections );
	xor( eax, eax );
	mov( al, [ebx] );
	mov( edi, [ebx+8] );
	mov( edi, (type dword org_origin) );
	mov( 0, (type dword org_origin[4]) );
	mov( 0, org_registers );
	mov( edi, org_start );
	mov( ebx, org_symbol );
	mov( 2, labels_type );
	test( 8, format_flags );
	jz coff_labels_type_ok;
	
	mov( 4, labels_type );
  coff_labels_type_ok:
	mov( eax, [ebx+$10] );	// Alignment?
	mov( eax, [ebx+$14] );	// Characteristics?
	lodsw;
	cmp( ax, '(' );
	jne invalid_argument;
	
	mov( esi, [ebx+4] );	// Ptr to name?
	mov( [esi], ecx );
	lea( esi, [esi+ecx+1+4] );
	cmp( ecx, 8 );
	ja name_too_long;
	
  coff_section_flags:
	cmp( (type byte [esi]), $1C );
	je coff_section_alignment;
	
	cmp( (type byte [esi]), $19 );
	jne coff_section_settings_ok;
	
	inc( esi );
	lodsb;
	bt( 0, format_flags );
	jc coff_section_flag_ok;
	
	cmp( al, 7 );
	ja invalid_argument;
	
  coff_section_flag_ok:
	mov( al, cl );
	mov( 1, eax );
	shl( cl, eax );
	test( eax, (type dword [ebx+$14]) );	// Characteristics?
	jnz setting_already_specified;
		
	or( (type dword [ebx+$14]), eax );		// Characteristics?
	mov( eax, (type dword [ebx+$14]));		// Characteristics?
	and( %1100_0000, al );
	cmp( al, %1100_0000 );
	je invalid_argument;
	jmp coff_section_flags;
	
  coff_section_alignment:
	bt( 0, format_flags );
	jnc invalid_argument;
	
	inc( esi );
	lodsb;
	or( al, al );
	jnz invalid_argument;
	
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	
	push( ebx );
	call get_dword_value;
	pop( ebx );
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
	mov( eax, edx );
	dec( edx );
	test( edx, eax );
	jnz invalid_value;
	
	or( eax, eax );
	jz invalid_value;
	
	cmp( eax, $2000 );
	ja invalid_value;
	
	bsf( eax, edx );
	inc( edx );
	shl( 20, edx );
	or( edx, [ebx+$14] );				// Characteristics?
	xchg( eax, [ebx+$10] );				// Alignment?
	or( eax, eax );
	jnz setting_already_specified;
	jmp coff_section_flags;
	
  coff_section_settings_ok:
	cmp( (type dword [ebx+$10]), 0 );
	jne instruction_assembled;
	
	mov( 4, (type dword [ebx+$10]) );
	bt( 0, format_flags );
	jnc instruction_assembled;
	
	or( $300000, (type dword [ebx+$14]) );
	jmp instruction_assembled;


  pe_section:
	call close_pe_section;
	bts( 5, format_flags );
	lea( ecx, [ebx+$28] );
	add( [edx+$54], edx );
	sub( stub_size, edx );
	cmp( ecx, edx );
	jbe new_section;
	lea( ebx, [edx-$28] );
	or( -1, next_pass_needed );
	push( edi );
	mov( ebx, edi );
	mov( $28 >> 4, ecx );
	xor( eax, eax );
	rep.stosd;
	pop( edi );
  new_section:
	mov( eax, [ebx+$0C] );
	lodsw;
	cmp( ax, '(' );
	jne invalid_argument;
	lea( edx, [esi+4] );
	mov( [esi], ecx );
	lea( esi, [esi+ecx+1+4] );
	cmp( ecx, 8 );
	ja name_too_long;
	xor( eax, eax );
	mov( eax, [ebx] );
	mov( eax, [ebx+4] );
	push( esi );
	push( edi );
	mov( ebx, edi );
	mov( edx, esi );
	rep.movsb;
	pop( edi );
	pop( esi );
	mov( 0, (type dword [ebx+$24]) );
	mov( edi, [ebx+$14] );
	mov( code_start, edx );
	mov( edi, eax );
	xor( ecx, ecx );
	sub( [ebx+$0C], eax );
	sbb( 0, ecx );
	test( 8, format_flags );
	jnz pe64_section_org;
	
	sub( [edx+$34], eax );
	sbb( 0, ecx );
	mov( 2, labels_type );
	mov( 32, code_type );
	jmp pe_section_org_ok;
	
  pe64_section_org:
	sub( [edx+$30], eax );
	sbb( [edx+$34], ecx );
	mov( 4, labels_type );
	mov( 64, code_type );
	
  pe_section_org_ok:
	mov( eax, (type dword org_origin) );
	mov( ecx, (type dword org_origin[4]) );
	mov( 0, org_registers );
	mov( edi, org_start );
	
  get_section_flags:
	lodsb;
	cmp( al, lenStrTkn );
	je set_directory;
	
	cmp( al, $19 );
	je section_flag;
	
	dec( esi );
	jmp instruction_assembled;
	
  set_directory:
	movzx( (type byte [esi]), eax );
	inc( esi );
	mov( ebx, ecx );
	test( 8, format_flags );
	jnz pe64_directory;
	
	xchg( [edx+eax*8+$78], ecx );
	mov( -1, (type dword [edx+eax*8+4+$78]) );
	jmp pe_directory_set;
	
  pe64_directory:
	xchg( [edx+eax*8+$88], ecx );
	mov( -1, (type dword [edx+eax*8+4+$88]) );
	
  pe_directory_set:
	or( ecx, ecx );
	jnz data_already_defined;
	
	push( ebx );
	push( edx );
	call generate_pe_data;
	pop( edx );
	pop( ebx );
	jmp get_section_flags;
	
  section_flag:
	lodsb;
	cmp( al, 9 );
	je invalid_argument;
	
	cmp( al, 11 );
	je invalid_argument;
	
	mov( al, cl );
	mov( 1, eax );
	shl( cl, eax );
	test( eax, cSectionEBX.Characteristics );	// (type dword [ebx+$24])
	jnz setting_already_specified;
	
	// Note: Initialized data flag ($40) and
	//       uninitialized data flag ($80) are
	//       mutually exclusive. Initialized
	//       data takes precedence.

	or( cSectionEBX.Characteristics, eax );				// [ebx+$24]
	mov( eax, cSectionEBX.Characteristics );			// [ebx+$24]
	cmp( al, $c0 );
	jnae get_section_flags;
	and( $7f, al );
	mov( al, (type byte cSectionEBX.Characteristics) );	// [ebx+$24]
	jmp get_section_flags;
	

  data_directive::
	cmp( output_format, 3 );
	jne illegal_instruction;
	
	lodsb;
	cmp( al, lenStrTkn );
	je predefined_data_type;
	
	cmp( al, '(' );
	jne invalid_argument;
	
	call get_byte_value;
	cmp( al, 16 );
	jb data_type_ok;
	jmp invalid_value;
	
  predefined_data_type:
	movzx( (type byte [esi]), eax );
	inc( esi );
	
  data_type_ok:
	mov( current_section, ebx );
	mov( edi, ecx );
	sub( cSectionEBX.PointerToRawData, ecx );		// [ebx+$14]
	add( cSectionEBX.VirtualAddress, ecx );			// [ebx+$0C]
	mov( code_start, edx );
	test( 8, format_flags );
	jnz pe64_data;
	
	xchg( [edx+eax*8+$78], ecx );
	jmp init_pe_data;
	
  pe64_data:
	xchg( [edx+eax*8+$88], ecx );
	
  init_pe_data:
	or( ecx, ecx );
	jnz data_already_defined;
	
	call allocate_structure_data;
	mov( data_directive_assembler, ax );
	mov( ax, (type word [ebx]) );
	mov( al, [ebx+2] );
	mov( current_line, edx );
	mov( edx, [ebx+4] );
	call generate_pe_data;
	jmp instruction_assembled;
	
  pe_entry:
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	test( 8, format_flags );
	jnz pe64_entry;
	call get_dword_value;
	cmp( value_type, 2 );
	je pe_entry_ok;
	cmp( error_line, 0 );
	jne pe_entry_ok;
	mov( current_line, edx );
	mov( edx, error_line );
	mov( &invalid_address, error );
  pe_entry_ok:
	mov( code_start, edx );
	sub( [edx+$34], eax );
	mov( eax, [edx+$28] );
	jmp instruction_assembled;
  pe64_entry:
	call get_qword_value;
	cmp( value_type, 4 );
	je pe64_entry_type_ok;
	cmp( error_line, 0 );
	jne pe64_entry_type_ok;
	mov( current_line, edx );
	mov( edx, error_line );
	mov( &invalid_address, error );
  pe64_entry_type_ok:
	mov( code_start, ecx );
	sub( [ecx+$30], eax );
	sbb( [ecx+$34], edx );
	jz pe64_entry_range_ok;
	mov( current_line, edx );
	mov( edx, error_line );
	mov( &value_out_of_range, error );
  pe64_entry_range_ok:
	mov( eax, [ecx+$28] );
	jmp instruction_assembled;
  pe_stack:
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	test( 8, format_flags );
	jnz pe64_stack;
	call get_dword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( code_start, edx );
	mov( eax, [edx+$60] );
	cmp( (type byte [esi]), ',' );
	jne default_stack_commit;
	lodsb;
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	call get_dword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( code_start, edx );
	mov( eax, [edx+$64] );
	cmp( eax, [edx+$60] );
	ja value_out_of_range;
	jmp instruction_assembled;
  default_stack_commit:
	mov( $1000, (type dword [edx+$64]) );
	mov( [edx+$60], eax );
	cmp( eax, $1000 );
	ja instruction_assembled;
	mov( eax, (type dword [edx+$64]) );
	jmp instruction_assembled;
  pe64_stack:
	call get_qword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( code_start, ecx );
	mov( eax, [ecx+$60] );
	mov( edx, [ecx+$64] );
	cmp( (type byte [esi]), ',' );
	jne default_pe64_stack_commit;
	lodsb;
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	call get_qword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( code_start, ecx );
	mov( eax, [ecx+$68] );
	mov( edx, [ecx+$6C] );
	cmp( edx, [ecx+$64] );
	ja value_out_of_range;
	jb instruction_assembled;
	cmp( eax, [edx+$60] );
	ja value_out_of_range;
	jmp instruction_assembled;
  default_pe64_stack_commit:
	mov( $1000, (type dword [edx+$68]) );
	cmp( (type dword [edx+$64]), 0 );
	jne instruction_assembled;
	mov( [edx+$60], eax );
	cmp( eax, $1000 );
	ja instruction_assembled;
	mov( eax, (type dword [edx+$68]) );
	jmp instruction_assembled;
  pe_heap:
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	test( 8, format_flags );
	jnz pe64_heap;
	call get_dword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( code_start, edx );
	mov( eax, [edx+$68] );
	cmp( (type byte [esi]), ',' );
	jne instruction_assembled;
	lodsb;
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	call get_dword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( code_start, edx );
	mov( eax, [edx+$6C] );
	cmp( eax, [edx+$68] );
	ja value_out_of_range;
	jmp instruction_assembled;
  pe64_heap:
	call get_qword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( code_start, ecx );
	mov( eax, [ecx+$70] );
	mov( edx, [ecx+$74] );
	cmp( (type byte [esi]), ',' );
	jne instruction_assembled;
	lodsb;
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	call get_qword_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( code_start, ecx );
	mov( eax, [ecx+$78] );
	mov( edx, [ecx+$7C] );
	cmp( edx, [ecx+$74] );
	ja value_out_of_range;
	jb instruction_assembled;
	cmp( eax, [edx+$70] );
	ja value_out_of_range;
	jmp instruction_assembled;
	
	
  mz_segment:
	lodsb;
	cmp( al, 2 );
	jne invalid_argument;
	lodsd;
	cmp( eax, $0F );
	jb invalid_use_of_symbol;
	je reserved_word_used_as_symbol;
	inc( esi );
	mov( eax, ebx );
	mov( edi, eax );
	sub( code_start, eax );
	mov( $0F, ecx );
	add( $0F, eax );
	and( %1111, eax );
	sub( eax, ecx );
	mov( edi, edx );
	xor( al, al );
	rep.stosb;
	mov( edi, (type dword org_origin) );
	mov( 0, (type dword org_origin[4]) );
	mov( 0, org_registers );
	mov( edi, org_start );
	mov( edx, eax );
	undefined_data( eax, edi );
	mov( edi, eax );
	sub( code_start, eax );
	shr( 4, eax );
	cmp( eax, $10000 );
	jae value_out_of_range;
	mov( eax, edx );
	mov( 16, al );
	cmp( (type byte [esi]), $13 );
	jne segment_type_ok;
	inc( esi );
	lodsb;
  segment_type_ok:
	mov( al, code_type );
	mov( edx, eax );
	mov( $0100, cx );
	xor( edx, edx );
	xor( ebp, ebp );
	mov( edx, address_symbol );
	jmp make_free_label;
  mz_entry:
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	call get_word_value;
	cmp( value_type, 1 );
	je initial_cs_ok;
	cmp( error_line, 0 );
	jne initial_cs_ok;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_address, error );
  initial_cs_ok:
	mov( additional_memory, edx );
	mov( ax, [edx+$16] );
	lodsb;
	cmp( al, ':' );
	jne invalid_argument;
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	ja invalid_address;
	call get_word_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( additional_memory, edx );
	mov( ax, [edx+$14] );
	jmp instruction_assembled;
  mz_stack:
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	call get_word_value;
	cmp( (type byte [esi]), ':' );
	je stack_pointer;
	cmp( ax, $10 );
	jb invalid_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( additional_memory, edx );
	mov( ax, [edx+$10] );
	jmp instruction_assembled;
  stack_pointer:
	cmp( value_type, 1 );
	je initial_ss_ok;
	cmp( error_line, 0 );
	jne initial_ss_ok;
	mov( current_line, eax );
	mov( eax, error_line );
	mov( &invalid_address, error );
  initial_ss_ok:
	mov( additional_memory, edx );
	mov( ax, [edx+$0E] );
	lodsb;
	cmp( al, ':' );
	jne invalid_argument;
	lodsb;
	cmp( al, '(' );
	jne invalid_argument;
	call get_word_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( additional_memory, edx );
	mov( ax, [edx+$10] );
	bts( 4, format_flags );
	jmp instruction_assembled;
  mz_heap:
	cmp( output_format, 2 );
	jne illegal_instruction;
	lodsb;
	call get_size_operator;
	cmp( ah, 1 );
	je invalid_value;
	cmp( ah, 2 );
	ja invalid_value;
	cmp( al, '(' );
	jne invalid_argument;
	call get_word_value;
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	mov( additional_memory, edx );
	mov( ax, [edx+$0C] );
	jmp instruction_assembled;
	




  format_pe:
	xor( edx, edx );
	mov( $14C, machine );
	mov( 3, subsystem );
	mov( 3 + 10 << 16, subsystem_version );
	mov( $400000, image_base );
	test( 8, format_flags );
	jz pe_settings;
	mov( $8664, machine );
	mov( 5 + 0 << 16, subsystem_version );
	mov( 0, image_base_high );
  pe_settings:
	cmp( (type byte [esi]), $84 );
	je get_stub_name;
	cmp( (type byte [esi]), $80 );
	je get_pe_base;
	cmp( (type byte [esi]), $1B );
	jne pe_settings_ok;
	lodsb;
	lodsb;
	test( $80+$40, al );
	jz subsystem_setting;
	cmp( al, $80 );
	je dll_flag;
	cmp( al, $81 );
	je wdm_flag;
	jmp pe_settings;
  dll_flag:
	bts( 8, format_flags );
	jc setting_already_specified;
	jmp pe_settings;
  wdm_flag:
	bts( 9, format_flags );
	jc setting_already_specified;
	jmp pe_settings;
  subsystem_setting:
	bts( 7, format_flags );
	jc setting_already_specified;
	and( $3F, ax );
	mov( ax, subsystem );
	cmp( (type byte [esi]), '(' );
	jne pe_settings;
	inc( esi );
	cmp( (type byte [esi]), '.' );
	jne invalid_value;
	inc( esi );
	push( edx );
	cmp( (type byte [esi+11]), 0 );
	jne invalid_value;
	cmp( (type byte [esi+10]), 2 );
	ja invalid_value;
	mov( [esi+8], dx );
	cmp( dx, $8000 );
	je zero_version;
	mov( [esi+4], eax );
	cmp( dx, 7 );
	jg invalid_value;
	mov( 7, cx );
	sub( dx, cx );
	mov( [esi+4], eax );
	shr( cl, eax );
	mov( eax, ebx );
	shr( 24, ebx );
	cmp( bl, 100 );
	jae invalid_value;
	and( $0FFFFFF, eax );
	mov( 100, ecx );
	mul( ecx );
	shrd( 24, edx, eax );
	jnc version_value_ok;
	inc( eax );
  version_value_ok:
	shl( 16, eax );
	mov( bx, ax );
	jmp subsystem_version_ok;
  zero_version:
	xor( eax, eax );
  subsystem_version_ok:
	pop( edx );
	add( 13, esi );
	mov( eax, subsystem_version );
	jmp pe_settings;
  get_pe_base:
	bts( 10, format_flags );
	jc setting_already_specified;
	lodsw;
	cmp( ah, '(' );
	jne invalid_argument;
	cmp( (type byte [esi]), '.' );
	je invalid_value;
	push( edx );
	push( edi );
	add( stub_size, edi );
	test( 8, format_flags );
	jnz get_pe64_base;
	call get_dword_value;
	mov( eax, image_base );
	jmp pe_base_ok;
  get_pe64_base:
	call get_qword_value;
	mov( eax, image_base );
	mov( edx, image_base_high );
  pe_base_ok:
	pop( edi );
	pop( edx );
	cmp( value_type, 0 );
	jne invalid_use_of_symbol;
	
	cmp( (type byte [esi]), $84 );
	jne pe_settings_ok;
	
  get_stub_name:
	lodsb;
	lodsw;
	cmp( ax, '(' );
	jne invalid_argument;
	
	lodsd;
	mov( esi, edx );
	add( eax, esi );
	inc( esi );
	
  pe_settings_ok:
	mov( stub_size, ebp );
	or( ebp, ebp );
	jz make_pe_stub;
	
	cmp( edx, stub_file );
	je pe_stub_ok;
	
	sub( stub_size, edi );
	mov( edi, code_start );
	
  make_pe_stub:
	call make_stub;
	mov( edi, eax );
	sub( code_start, eax );
	mov( eax, stub_size );
	mov( edi, code_start );
	mov( eax, ebp );
	
  pe_stub_ok:
	mov( edi, edx );
	mov( $18+$0E0, ecx );
	test( 8, format_flags );
	jz zero_pe_header;
	add( $10, ecx );
  zero_pe_header:
	add( ecx, ebp );
	shr( 2, ecx );
	xor( eax, eax );
	rep.stosd;
	mov( asWord( "PE" ), (type word [edx]) );
	mov( machine, ax );
	mov( ax, (type word [edx+4]) );
	mov( $1000, (type dword [edx+$38]) );
	mov( $200, (type dword [edx+$3C]) );
	mov( 1, (type word [edx+$40]) );
	mov( subsystem_version, eax );
	mov( eax, [edx+$48] );
	mov( subsystem, ax );
	mov( ax, [edx+$5C] );
	cmp( ax, 1 );
	jne pe_alignment_ok;
	mov( $20, eax );
	mov( eax, (type dword [edx+$38]) );
	mov( eax, (type dword [edx+$3C]) );
  pe_alignment_ok:
	mov( VERSION_MAJOR + VERSION_MINOR << 8, (type word [edx+$1A]) );
	test( 8, format_flags );
	jnz init_pe64_specific;
	mov( $0E0, (type dword [edx+$14]) );
	mov( $10B010E, (type dword [edx+$16]) );
	mov( image_base, eax );
	mov( eax, (type dword [edx+$34]) );
	mov( $1000, (type dword [edx+$60]) );
	mov( $1000, (type dword [edx+$64]) );
	mov( $10000, (type dword [edx+$68]) );
	mov( 0, (type dword [edx+$6C]) );
	mov( 16, (type dword [edx+$74]) );
	jmp pe_header_ok;
  init_pe64_specific:
	mov( $0F0, (type dword [edx+$14]) );
	mov( $20B002E, (type dword [edx+$16]) );
	mov( image_base, eax );
	mov( eax, (type dword [edx+$30]) );
	mov( image_base_high, eax );
	mov( eax, (type dword [edx+$34]) );
	mov( $1000, (type dword [edx+$60]) );
	mov( $1000, (type dword [edx+$68]) );
	mov( $10000, (type dword [edx+$70]) );
	mov( 0, (type dword [edx+$78]) );
	mov( 16, (type dword [edx+$84]) );
  pe_header_ok:
	bsf( [edx+$3C], ecx );
	intmul( $28, number_of_sections, ebx );
	or( ebx, ebx );
	jnz reserve_space_for_section_headers;
	mov( $28, ebx );
  reserve_space_for_section_headers:
	add( ebp, ebx );
	dec( ebx );
	shr( cl, ebx );
	inc( ebx );
	shl( cl, ebx );
	sub( ebp, ebx );
	mov( ebx, ecx );
	mov( display_buffer, eax );
	sub( ecx, eax );
	out_of_mem( ae, edi, eax );
	shr( 2, ecx );
	xor( eax, eax );
	rep.stosd;
	mov( edi, eax );
	sub( code_start, eax );
	add( stub_size, eax );
	mov( eax, [edx+$54] );
	mov( [edx+$38], ecx );
	dec( ecx );
	add( ecx, eax );
	not( ecx );
	and( ecx, eax );
	bt( 8, format_flags );
	jc pe_entry_init_ok;
	mov( eax, [edx+$28] );
  pe_entry_init_ok:
	mov( 0, number_of_sections );
	movzx( (type word [edx+$14]), ebx );
	lea( ebx, [edx+ebx+$18] );
	mov( ebx, current_section );
	mov( asDword( ".fla" ), (type dword [ebx]) );
	mov( 't', (type dword [ebx+4]) );
	mov( edi, [ebx+$14] );
	mov( eax, [ebx+$0C] );
	mov( $0E0000060, (type dword [ebx+$24]) );
	xor( ecx, ecx );
	not( eax );
	not( ecx );
	add( 1, eax );
	adc( 0, ecx );
	add( edi, eax );
	adc( 0, ecx );
	test( 8, format_flags );
	jnz pe64_org;
	sub( [edx+$34], eax );
	sbb( 0, ecx );
	mov( 2, labels_type );
	mov( 32, code_type );
	jmp pe_org_ok;
  pe64_org:
	sub( [edx+$30], eax );
	sbb( [edx+$34], ecx );
	mov( 4, labels_type );
	mov( 64, code_type );
  pe_org_ok:
	mov( eax, (type dword org_origin) );
	mov( ecx, (type dword org_origin[4]) );
	mov( 0, org_registers );
	mov( edi, org_start );
	bt( 8, format_flags );
	jnc dll_flag_ok;
	or( $2000, (type dword [edx+$16]) );
  dll_flag_ok:
	bt( 9, format_flags );
	jnc wdm_flag_ok;
	or( $2000, (type word [edx+$5E]) );
  wdm_flag_ok:
	jmp instruction_assembled;
	
end assemble_line;

//////////////////////////////////////////////////////////////////////////////////


proc( write_code );

	mov( written_size, eax );
	mov( eax, headers_size );
	mov( code_start, edx );
	mov( code_size, ecx );
	add( ecx, written_size );
	write( ebx, edx, ecx );
	ret();

end write_code;

	
proc( store_symbol_name );

	push( esi );
	mov( [esi+4], esi );
	or( esi, esi );
	jz default_name;
	
	lodsd;
	mov( eax, ecx );
	cmp( ecx, 8 );
	ja add_string;
	
	push( edi );
	mov( ebx, edi );
	rep.movsb;
	pop( edi );
	pop( esi );
	ret();

  default_name:
	mov( asDword( ".fla" ), (type dword [ebx]) );
	mov( 't', (type dword [ebx+4]) );
	pop( esi );
	ret();

  add_string:
	mov( edi, eax );
	sub( edx, eax );
	mov( eax, [ebx+4] );
	inc( ecx );
	rep.movsb;
	pop( esi );
	ret();
	
end store_symbol_name;


proc( store_section_index );

	inc( ecx );
	mov( ecx, eax );
	shl( 8, eax );
	mov( eax, [ebx] );
	inc( dx );
	jz format_limitations_exceeded;
	mov( edx, eax );
	shl( 16, eax );
	mov( 3, al );
	test( $40, (type byte [ebx+$14]) );
	jz section_index_ok;
	or( -1, ah );
	inc( dx );
	jz format_limitations_exceeded;
  section_index_ok:
	stosd;
	ret();
	
end store_section_index;


proc( get_public_value );

	mov( [ebx], eax );
	cmp( (type dword [ebx+4]), 0 );
	je public_value_ok;
	cmp( (type dword [ebx+4]), -1 );
	jne value_out_of_range;
	bt( 31, eax );
	jnc value_out_of_range;
  public_value_ok:
	ret();
	
end get_public_value;



proc( store_elf_machine_word );

	stosd;
	test( 8, format_flags );
	jz elf_machine_word_ok;
	mov( 0, (type dword [edi]) );
	add( 4, edi );
  elf_machine_word_ok:
	ret();

end store_elf_machine_word;



////////


proc( formatter );

	cmp( output_file, 0 );
	jne output_path_ok;
	
	push( edi );
	mov( input_file, esi );
	mov( free_additional_memory, edi );
  copy_output_path:
	lodsb;
	out_of_mem( ae, edi, structures_buffer );
	
	stosb;
	or( al, al );
	jnz copy_output_path;
	
	dec( edi );
	mov( edi, eax );
  find_extension:
	dec( eax );
	cmp( eax, free_additional_memory );
	jb extension_found;
	cmp( (type byte [eax]), '\' );
	je extension_found;
	cmp( (type byte [eax]), '/' );
	je extension_found;
	cmp( (type byte [eax]), '.' );
	jne find_extension;
	mov( eax, edi );
	
  extension_found:
	lea( eax, [edi+9] );
	out_of_mem( ae, eax, structures_buffer );
	cmp( output_format, 2 );
	je exe_extension;
	jb bin_extension;
	cmp( output_format, 4 );
	je obj_extension;
	cmp( output_format, 5 );
	je o_extension;
	cmp( output_format, 3 );
	jne no_extension;
	cmp( subsystem, 1 );
	je sys_extension;
	bt( 8, format_flags );
	jnc exe_extension;
	mov( asDword( ".dll" ), eax );
	jmp make_extension;
	
  sys_extension:
	mov( asDword( ".sys" ), eax );
	jmp make_extension;
	
  bin_extension:
	mov( asDword( ".bin" ), eax );
	bt( 0, format_flags );
	jnc make_extension;
	mov( asDword( ".com" ), eax );
	jmp make_extension;
	
  obj_extension:
	mov( asDword( ".obj" ), eax );
	jmp make_extension;
	
  o_extension:
	mov( asDword( ".o" ), eax );
	bt( 0, format_flags );
	jnc make_extension;
	
  no_extension:
	xor( eax, eax );
	jmp make_extension;
	
  exe_extension:
	mov( asDword( ".exe" ), eax );
	
  make_extension:
	xchg( [edi], eax );
	scasd;
	mov( 0, (type byte [edi]) );
	scasb;
	mov( edi, esi );
	stosd;
	sub( 9, edi );
	xor( eax, eax );
	mov( &characters, ebx );
	
  adapt_case:
	mov( [esi], al );
	or( al, al );
	jz adapt_next;
	
	xlat;
	cmp( al, [esi] );
	je adapt_ok;

	sub( $20, (type byte [edi]) );
	
  adapt_ok:
	inc( esi );
	
  adapt_next:
	inc( edi );
	cmp( (type byte [edi]), 0 );
	jne adapt_case;
	
	mov( edi, esi );
	lea( ecx, [esi+1] );
	sub( free_additional_memory, ecx );
	mov( structures_buffer, edi );
	dec( edi );
	std;
	rep.movsb;
	cld;
	inc( edi );
	mov( edi, structures_buffer );
	mov( edi, output_file );
	pop( edi );
  output_path_ok:
	cmp( output_format, 4 );
	je coff_formatter;
	
	cmp( output_format, 5 );
	jne common_formatter;
	
	bt( 0, format_flags );
	jnc elf_formatter;
	
  common_formatter:
	mov( edi, eax );
	sub( code_start, eax );
	mov( eax, real_code_size );
	cmp( edi, undefined_data_end );
	jne calculate_code_size;
	
	mov( undefined_data_start, edi );
  calculate_code_size:
	sub( code_start, edi );
	mov( edi, code_size );
	mov( 0, written_size );
	mov( output_file, edx );
	call create;
	jc write_failed;
	
	cmp( output_format, 3 );
	jne stub_written;
	
	mov( code_start, edx );
	mov( stub_size, ecx );
	sub( ecx, edx );
	add( ecx, written_size );
	write( ebx, edx, ecx );
	
  stub_written:
	cmp( output_format, 2 );
	jne write_output;
	call write_mz_header;
	
  write_output:
	call write_code;
	
  output_written:
	close( ebx );
	ret();

  coff_formatter:
	sub( code_start, edi );
	mov( edi, code_size );
	call prepare_default_section;
	mov( free_additional_memory, edi );
	mov( edi, ebx );
	mov( $28 >> 2, ecx );
	intmul( number_of_sections, ecx );
	add( $14 >> 2, ecx );
	lea( eax, [edi+ecx*4] );
	out_of_mem( ae, eax, structures_buffer );
	
	xor( eax, eax );
	rep.stosd;
	mov( $14C, (type word [ebx]) );
	test( 8, format_flags );
	jz coff_magic_ok;
	
	mov( $8664, (type word [ebx]) );
  coff_magic_ok:
	mov( $104, (type word [ebx+$12]) );
	bt( 0, format_flags );
	jnc coff_flags_ok;
	
	or( $80, (type byte [ebx+$12]) );
	
  coff_flags_ok:
	push( ebx );
	call make_timestamp;
	pop( ebx );
	mov( eax, [ebx+4] );
	mov( number_of_sections, eax );
	mov( ax, [ebx+2] );
	mov( symbols_stream, esi );
	xor( eax, eax );
	xor( ecx, ecx );
	
  enumerate_symbols:
	cmp( esi, free_additional_memory );
	je symbols_enumerated;
	mov( [esi], dl );
	or( dl, dl );
	jz enumerate_section;
	
	cmp( dl, $80 );
	je enumerate_public;
	ja enumerate_extrn;
	
	add( $0C, esi );
	jmp enumerate_symbols;
	
  enumerate_section:
	mov( eax, edx );
	shl( 8, edx );
	mov( edx, [esi] );
	inc( eax );
	inc( ecx );
	mov( cx, [esi+$1E] );
	add( $20, esi );
	jmp enumerate_symbols;
	
  enumerate_public:
	mov( eax, edx );
	shl( 8, edx );
	mov( $80, dl );
	mov( edx, [esi] );
	mov( [esi+8], edx );
	add( $10, esi );
	inc( eax );
	cmp( (type byte [edx+11]), 2 );
	jne enumerate_symbols;
	
	mov( [edx+20], edx );
	cmp( (type byte [edx]), $81 );
	jne enumerate_symbols;
	
	inc( eax );
	jmp enumerate_symbols;
	
  enumerate_extrn:
	mov( eax, edx );
	shl( 8, edx );
	mov( $81, dl );
	mov( edx, [esi] );
	add( $0C, esi );
	inc( eax );
	jmp enumerate_symbols;
	
  prepare_default_section:
	mov( symbols_stream, ebx );
	cmp( (type dword [ebx+$0C]), 0 );
	jne default_section_ok;
	
	cmp( number_of_sections, 0 );
	je default_section_ok;
	
	mov( ebx, edx );
  find_references_to_default_section:
	cmp( ebx, free_additional_memory );
	jne check_reference;
	
	add( $20, symbols_stream );
	ret();

  check_reference:
	mov( [ebx], al );
	or( al, al );
	jz skip_other_section;
	
	cmp( al, $80 );
	je check_public_reference;
	ja next_reference;
	
	cmp( edx, [ebx+8] );
	je default_section_ok;
	
  next_reference:
	add( $0C, ebx );
	jmp find_references_to_default_section;
	
  check_public_reference:
	mov( [ebx+8], eax );
	add( $10, ebx );
	test( 1, (type byte [eax+8]) );
	jz find_references_to_default_section;
	
	mov( current_pass, cx );
	cmp( cx, [eax+16] );
	jne find_references_to_default_section;
	
	cmp( edx, [eax+20] );
	je default_section_ok;
	jmp find_references_to_default_section;
	
  skip_other_section:
	add( $20, ebx );
	jmp find_references_to_default_section;
	
  default_section_ok:
	inc( number_of_sections );
	ret();

  symbols_enumerated:
	mov( eax, [ebx+$0C] );
	mov( edi, ebp );
	sub( ebx, ebp );
	push( ebp );
	lea( edi, [ebx+$14] );
	mov( symbols_stream, esi );
	
  find_section:
	cmp( esi, free_additional_memory );
	je sections_finished;
	
	// If the first byte of the structure is a zero,
	// then we've got a FASM section:
	
	mov( [esi], al ); 
	or( al, al );
	jz section_found;
	
	// If it's not zero and it's not $80, then it's
	// a relocation record;
	
	add( $0C, esi );
	cmp( al, $80 );
	jne find_section;
	
	// Don't know what $80 means...	yet
	
	add( 4, esi );
	jmp find_section;
	
  section_found:
	push( esi );
	push( edi );
	mov( [esi+4], esi );
	if( esi <> NULL ) then
	
		mov( [esi], ecx );	// Get name length
		add( 4, esi );		// Skip over length to first char
		rep.movsb;			// Copy the name

	else
		
		mov( '.', al );					// If name field was NULL, then
		stosb;							// Use the default name of ".flat"
		mov( asDword( "flat" ), eax );
		stosd;
		
	endif;
	
  // Copy FASM section to COFF header.
  
  section_name_ok:
	pop( edi );
	pop( esi );
	mov( fSectionESI.SectionSize, eax );		// [esi+$0C]
	mov( eax, cSectionEDI.SizeOfRawData );		// [edi+$10]
	mov( fSectionESI.Characteristics, eax );	// [esi+$14]
	mov( eax, cSectionEDI.Characteristics );	// [edi+$24]
	
	// Check to see if this is an uninitialized data section
	
	test( IMAGE_SCN_CNT_UNINITIALIZED_DATA, al );
	if( @z ) then
	
		// It is not an uninitialized data section.
		// Compute the address of the data in the section.
		
		mov( fSectionESI.StartOfSection, eax );			// [esi+8]
		sub( code_start, eax );
		add( ebp, eax );
		mov( eax, cSectionEDI.PointerToRawData );		// [edi+$14]
		
	endif;
	mov( code_start, ebx );
	mov( code_size, edx );
	add( edx, ebx );			// Ptr to end of code in EBX
	add( ebp, edx );
	xor( ecx, ecx );
	add( @size( FASM_Section_Header ), esi );
	
  find_relocations:
	cmp( esi, free_additional_memory );
	je section_relocations_done;
	
	mov( [esi], al );
	or( al, al );
	jz section_relocations_done;
	
	cmp( al, $80 );
	jb add_relocation;
	ja next_relocation;
	
	add( $10, esi );
	jmp find_relocations;
	
  add_relocation:
	lea( eax, [ebx+$0A] );
	out_of_mem( a, eax, display_buffer );
	
	mov( [esi+4], eax );
	mov( eax, [ebx] );
	mov( [esi+8], eax );
	mov( [eax], eax );
	shr( 8, eax );
	mov( eax, [ebx+4] );
	movzx( (type byte [esi]), ax );
	mov( ax, [ebx+8] );
	add( $0A, ebx );
	inc( ecx );
	
  next_relocation:
	add( $0C, esi );
	jmp find_relocations;
	
  section_relocations_done:
	cmp( ecx, $10000 );
	jb section_relocations_count_16bit;
	
	bt( 0, format_flags );
	jnc format_limitations_exceeded;
	
	// We've overflowed the relocation count
	// (it's a two-byte field). Saturate it and
	// set up for extended relocations.
	
	mov( $0FFFF, (type word cSectionEDI.NumberOfRelocations) );	// [edi+$20]
	or( $1000000, (type dword cSectionEDI.Characteristics) );	// [edi+$24]
	mov( edx, cSectionEDI.PointerToRelocations );				// [edi+$18]
	push( esi );
	push( edi );
	push( ecx );
	
	// Make room for an extra entry by moving everything up
	// 10 bytes in memory. EBX points at the first byte beyond
	// the end of the current table:
	
	lea( esi, [ebx-1] );
	add( @size( FASM_RelocationRecord ), ebx );		// $0A
	lea( edi, [ebx-1] );
	intmul( @size( FASM_RelocationRecord ), ecx );	// $0A
	std;
	rep.movsb;
	cld;
	
	// Okay, fill in the new entry with the count of entries in
	// this list:
	
	pop( ecx );
	inc( esi );
	inc( ecx );
	
	// The VirtualAddress field of this entry holds the 
	// number of relocations (yeah, ought to be a union at
	// one point or another).
	
	mov( ecx, fRelocESI.VirtualAddress );			// [esi]
	
	// The following two fields are unused for this record:
	 
	xor( eax, eax );
	mov( eax, fRelocESI.SymbolTableIndex );			// [esi+4]
	mov( ax, fRelocESI.relocType );					// [esi+8]
	pop( edi );
	pop( esi );
	jmp section_relocations_ok;
	
  section_relocations_count_16bit:
	mov( cx, cSectionEDI.NumberOfRelocations );		// [edi+$20]
	jcxz section_relocations_ok;
	
	mov( edx, cSectionEDI.PointerToRelocations );	// [edi+$18]
  section_relocations_ok:
	sub( code_start, ebx );
	mov( ebx, code_size );
	add( @size( COFF_Section_Header ), edi );		// $28
	jmp find_section;
	
  sections_finished:
	mov( free_additional_memory, edx );
	mov( code_size, ebx );
	add( ebx, ebp );
	mov( ebp, [edx+8] );
	add( code_start, ebx );
	mov( ebx, edi );
	mov( [edx+$0C], ecx );
	intmul( $12 >> 1, ecx );
	xor( eax, eax );
	shr( 1, ecx );
	jnc zero_symbols_table;
	stosw;
	
  zero_symbols_table:
	rep.stosd;
	mov( edi, edx );
	stosd;
	mov( symbols_stream, esi );
	
  make_symbols_table:
	cmp( esi, free_additional_memory );
	je symbols_table_ok;
	
	mov( [esi], al );
	cmp( al, $80 );
	je add_public_symbol;
	ja add_extrn_symbol;
	
	or( al, al );
	jz add_section_symbol;
	
	add( $0C, esi );
	jmp make_symbols_table;
	
  add_section_symbol:
	call store_symbol_name;
	movzx( (type word [esi+$1E]), eax );
	mov( ax, [ebx+$0C] );
	mov( 3, (type byte [ebx+$10]) );
	add( $20, esi );
	add( $12, ebx );
	jmp make_symbols_table;
	
  add_extrn_symbol:
	call store_symbol_name;
	mov( 2, (type byte [ebx+$10]) );
	add( $0C, esi );
	add( $12, ebx );
	jmp make_symbols_table;
	
  add_public_symbol:
	call store_symbol_name;
	mov( [esi+$0C], eax );
	mov( eax, current_line );
	mov( [esi+8], eax );
	test( 1, (type byte [eax+8]) );
	jz undefined_symbol;
	
	mov( current_pass, cx );
	cmp( cx, [eax+16] );
	jne undefined_symbol;
	
	mov( [eax+11], cl );
	or( cl, cl );
	jz public_constant;
	
	test( 8, format_flags );
	jnz check_64bit_public_symbol;
	
	cmp( cl, 2 );
	je public_symbol_type_ok;
	jmp invalid_use_of_symbol;
	
  check_64bit_public_symbol:
	cmp( cl, 4 );
	jne invalid_use_of_symbol;
	
  public_symbol_type_ok:
	mov( [eax+20], ecx );
	cmp( (type byte [ecx]), $81 );
	je alias_symbol;
	
	cmp( (type byte [ecx]), 0 );
	jne invalid_use_of_symbol;
	
	mov( [ecx+$1E], cx );
	mov( cx, [ebx+$0C] );
  public_symbol_section_ok:
	cmp( (type dword [eax+4]), 0 );
	je store_public_symbol;
	
	cmp( (type dword [eax+4]), -1 );
	jne value_out_of_range;
	
	bt( 31, (type dword [eax]) );
	jnc value_out_of_range;
	
  store_public_symbol:
	mov( [eax], eax );
	mov( eax, [ebx+8] );
	mov( 2, (type byte [ebx+$10]) );
	add( $10, esi );
	add( $12, ebx );
	jmp make_symbols_table;
	
  alias_symbol:
	bt( 0, format_flags );
	jnc invalid_use_of_symbol;
	
	mov( [eax], ecx );
	or( [eax+4], ecx );
	jnz invalid_use_of_symbol;
	
	mov( $69, (type byte [ebx+$10]) );
	mov( 1, (type byte [ebx+$11]) );
	add( $12, ebx );
	mov( [eax+20], ecx );
	mov( [ecx], ecx );
	shr( 8, ecx );
	mov( ecx, [ebx] );
	mov( 3, (type byte [ebx+4]) );
	add( $10, esi );
	add( $12, ebx );
	jmp make_symbols_table;
	
  public_constant:
	mov( $0FFFF, (type word [ebx+$0C]) );
	jmp public_symbol_section_ok;
	
  symbols_table_ok:
	mov( edi, eax );
	sub( edx, eax );
	mov( eax, [edx] );
	sub( code_start, edi );
	mov( edi, code_size );
	mov( 0, written_size );
	mov( output_file, edx );
	call create;
	jc write_failed;
	mov( free_additional_memory, edx );
	pop( ecx );
	add( ecx, written_size );
	write(ebx, edx, ecx );
	jc write_failed;
	jmp write_output;
	


  elf_formatter:
	push( edi );
	call prepare_default_section;
	mov( symbols_stream, esi );
	mov( free_additional_memory, edi );
	xor( eax, eax );
	mov( 4, ecx );
	rep.stosd;
	test( 8, format_flags );
	jz find_first_section;
	mov( 2, ecx );
	rep.stosd;
  find_first_section:
	mov( [esi], al );
	or( al, al );
	jz first_section_found;
	cmp( al, $80 );
	jne skip_other_symbol;
	add( 4, esi );
  skip_other_symbol:
	add( $0C, esi );
	jmp find_first_section;
  first_section_found:
	mov( esi, ebx );
	mov( esi, ebp );
	add( $20, esi );
	xor( ecx, ecx );
	xor( edx, edx );
  find_next_section:
	cmp( esi, free_additional_memory );
	je make_section_symbol;
	mov( [esi], al );
	or( al, al );
	jz make_section_symbol;
	cmp( al, $80 );
	je skip_public;
	ja skip_extrn;
	or( $40, (type byte [ebx+$14]) );
  skip_extrn:
	add( $0C, esi );
	jmp find_next_section;
  skip_public:
	add( $10, esi );
	jmp find_next_section;
  make_section_symbol:
	mov( edi, eax );
	xchg( [ebx+4], eax );
	stosd;
	test( 8, format_flags );
	jnz elf64_section_symbol;
	xor( eax, eax );
	stosd;
	stosd;
	call store_section_index;
	jmp section_symbol_ok;
	

  elf64_section_symbol:
	call store_section_index;
	xor( eax, eax );
	stosd;
	stosd;
	stosd;
	stosd;
  section_symbol_ok:
	mov( esi, ebx );
	add( $20, esi );
	cmp( ebx, free_additional_memory );
	jne find_next_section;
	inc( dx );
	jz format_limitations_exceeded;
	mov( edx, current_section );
	mov( symbols_stream, esi );
  find_other_symbols:
	cmp( esi, free_additional_memory );
	je elf_symbol_table_ok;
	mov( [esi], al );
	or( al, al );
	jz skip_section;
	cmp( al, $80 );
	je make_public_symbol;
	ja make_extrn_symbol;
	add( $0C, esi );
	jmp find_other_symbols;
  skip_section:
	add( $20, esi );
	jmp find_other_symbols;
  make_public_symbol:
	mov( [esi+$0C], eax );
	mov( eax, current_line );
	mov( [esi+8], ebx );
	test( 1, (type byte [ebx+8]) );
	jz undefined_symbol;
	mov( current_pass, ax );
	cmp( ax, [ebx+16] );
	jne undefined_symbol;
	mov( [ebx+11], dl );
	or( dl, dl );
	jz public_absolute;
	mov( [ebx+20], eax );
	cmp( (type byte [eax]), 0 );
	jne invalid_use_of_symbol;
	mov( [eax+4], eax );
	test( 8, format_flags );
	jnz elf64_public;
	cmp( dl, 2 );
	jne invalid_use_of_symbol;
	mov( [eax+$0E], dx );
	jmp section_for_public_ok;
  elf64_public:
	cmp( dl, 4 );
	jne invalid_use_of_symbol;
	mov( [eax+6], dx );
	jmp section_for_public_ok;
  public_absolute:
	mov( $0FFF1, dx );
  section_for_public_ok:
	mov( [esi+4], eax );
	stosd;
	test( 8, format_flags );
	jnz elf64_public_symbol;
	call get_public_value;
	stosd;
	xor( eax, eax );
	mov( [ebx+10], al );
	stosd;
	mov( edx, eax );
	shl( 16, eax );
	mov( $10, al );
	cmp( (type byte [ebx+10]), 0 );
	je elf_public_function;
	or( 1, al );
	jmp store_elf_public_info;
  elf_public_function:
	or( 2, al );
  store_elf_public_info:
	stosd;
	jmp public_symbol_ok;
  elf64_public_symbol:
	mov( edx, eax );
	shl( 16, eax );
	mov( $10, al );
	cmp( (type byte [ebx+10]), 0 );
	je elf64_public_function;
	or( 1, al );
	jmp store_elf64_public_info;
  elf64_public_function:
	or( 2, al );
  store_elf64_public_info:
	stosd;
	call get_public_value;
	stosd;
	xor( eax, eax );
	stosd;
	mov( [ebx+10], al );
	stosd;
	xor( al, al );
	stosd;
  public_symbol_ok:
	inc( ecx );
	mov( ecx, eax );
	shl( 8, eax );
	mov( $80, al );
	mov( eax, [esi] );
	add( $10, esi );
	jmp find_other_symbols;
	
  make_extrn_symbol:
	mov( [esi+4], eax );
	stosd;
	test( 8, format_flags );
	jnz elf64_extrn_symbol;
	xor( eax, eax );
	stosd;
	mov( [esi+8], eax );
	stosd;
	mov( $10, eax );
	stosd;
	jmp extrn_symbol_ok;
  elf64_extrn_symbol:
	mov( $10, eax );
	stosd;
	xor( al, al );
	stosd;
	stosd;
	mov( [esi+8], eax );
	stosd;
	xor( eax, eax );
	stosd;
  extrn_symbol_ok:
	inc( ecx );
	mov( ecx, eax );
	shl( 8, eax );
	mov( $81, al );
	mov( eax, [esi] );
	add( $0C, esi );
	jmp find_other_symbols;
  elf_symbol_table_ok:
	mov( edi, edx );
	mov( free_additional_memory, ebx );
	xor( al, al );
	stosb;
	add( 16, edi );
	mov( edx, [edx+1] );
	add( $10, ebx );
	test( 8, format_flags );
	jz make_string_table;
	add( 8, ebx );
  make_string_table:
	cmp( ebx, edx );
	je elf_string_table_ok;
	test( 8, format_flags );
	jnz make_elf64_string;
	cmp( (type byte [ebx+$0D]), 0 );
	je rel_prefix_ok;
	mov( 0, (type byte [ebx+$0D]) );
	mov( asDword( ".rel" ), eax );
	stosd;
  rel_prefix_ok:
	mov( edi, esi );
	sub( edx, esi );
	xchg( [ebx], esi );
	add( $10, ebx );
  make_elf_string:
	or( esi, esi );
	jz default_string;
	lodsd;
	mov( eax, ecx );
	rep.movsb;
	xor( al, al );
	stosb;
	jmp make_string_table;
  make_elf64_string:
	cmp( (type byte [ebx+5]), 0 );
	je elf64_rel_prefix_ok;
	mov( 0, (type byte [ebx+5]) );
	mov( asDword( ".rel" ), eax );
	stosd;
	mov( 'a', al );
	stosb;
  elf64_rel_prefix_ok:
	mov( edi, esi );
	sub( edx, esi );
	xchg( [ebx], esi );
	add( $18, ebx );
	jmp make_elf_string;
  default_string:
	mov( asDword( ".fla" ), eax );
	stosd;
	mov( 't', ax );
	stosw;
	jmp make_string_table;
  elf_string_table_ok:
	mov( edi, [edx+1+8] );
	mov( code_start, ebx );
	mov( edi, eax );
	sub( free_additional_memory, eax );
	test( 8, format_flags );
	jnz finish_elf64_header;
	mov( eax, [ebx+$20] );
	mov( current_section, eax );
	inc( ax );
	jz format_limitations_exceeded;
	mov( ax, [ebx+$32] );
	inc( ax );
	jz format_limitations_exceeded;
	mov( ax, [ebx+$30] );
	jmp elf_header_finished;
  finish_elf64_header:
	mov( eax, [ebx+$28] );
	mov( current_section, eax );
	inc( ax );
	jz format_limitations_exceeded;
	mov( ax, [ebx+$3E] );
	inc( ax );
	jz format_limitations_exceeded;
	mov( ax, [ebx+$3C] );
  elf_header_finished:
	xor( eax, eax );
	mov( 10, ecx );
	rep.stosd;
	test( 8, format_flags );
	jz elf_null_section_ok;
	mov( 6, ecx );
	rep.stosd;
  elf_null_section_ok:
	mov( ebp, esi );
	xor( ecx, ecx );
  make_section_entry:
	mov( edi, ebx );
	mov( [esi+4], eax );
	mov( [eax], eax );
	stosd;
	mov( 1, eax );
	cmp( (type dword [esi+$0C]), 0 );
	je bss_section;
	test( $80, (type byte [esi+$14]) );
	jz section_type_ok;
  bss_section:
	mov( 8, al );
  section_type_ok:
	stosd;
	mov( [esi+$14], eax );
	and( $3F, al );
	call store_elf_machine_word;
	xor( eax, eax );
	call store_elf_machine_word;
	mov( [esi+8], eax );
	mov( eax, image_base );
	sub( code_start, eax );
	call store_elf_machine_word;
	mov( [esi+$0C], eax );
	call store_elf_machine_word;
	xor( eax, eax );
	stosd;
	stosd;
	mov( [esi+$10], eax );
	call store_elf_machine_word;
	xor( eax, eax );
	call store_elf_machine_word;
	inc( ecx );
	add( $20, esi );
	xchg( [esp], edi );
	mov( edi, ebp );
  convert_relocations:
	cmp( esi, free_additional_memory );
	je relocations_converted;
	mov( [esi], al );
	or( al, al );
	jz relocations_converted;
	cmp( al, $80 );
	jb make_relocation_entry;
	ja relocation_entry_ok;
	add( $10, esi );
	jmp convert_relocations;
  make_relocation_entry:
	test( 8, format_flags );
	jnz make_elf64_relocation_entry;
	mov( [esi+4], eax );
	stosd;
	mov( [esi+8], eax );
	mov( [eax], eax );
	mov( [esi], al );
	stosd;
	jmp relocation_entry_ok;
  make_elf64_relocation_entry:
	mov( [esi+4], eax );
	stosd;
	xor( eax, eax );
	stosd;
	movzx( (type byte [esi]), eax );
	stosd;
	mov( [esi+8], eax );
	mov( [eax], eax );
	shr( 8, eax );
	stosd;
	xor( eax, eax );
	stosd;
	stosd;
  relocation_entry_ok:
	add( $0C, esi );
	jmp convert_relocations;
	
  relocations_converted:
	cmp( edi, ebp );
	xchg( [esp], edi );
	je rel_section_ok;
	mov( [ebx], eax );
	sub( 4, eax );
	test( 8, format_flags );
	jz store_relocations_name_offset;
	dec( eax );
  store_relocations_name_offset:
	stosd;
	test( 8, format_flags );
	jnz rela_section;
	mov( 9, eax );
	jmp store_relocations_type;
  rela_section:
	mov( 4, eax );
  store_relocations_type:
	stosd;
	xor( al, al );
	call store_elf_machine_word;
	call store_elf_machine_word;
	mov( ebp, eax );
	sub( code_start, eax );
	call store_elf_machine_word;
	mov( [esp], eax );
	sub( ebp, eax );
	call store_elf_machine_word;
	mov( current_section, eax );
	stosd;
	mov( ecx, eax );
	stosd;
	inc( ecx );
	test( 8, format_flags );
	jnz finish_elf64_rela_section;
	mov( 4, eax );
	stosd;
	mov( 8, al );
	stosd;
	jmp rel_section_ok;
  finish_elf64_rela_section:
	mov( 8, eax );
	stosd;
	xor( al, al );
	stosd;
	mov( 24, al );
	stosd;
	xor( al, al );
	stosd;
  rel_section_ok:
	cmp( esi, free_additional_memory );
	jne make_section_entry;
	pop( eax );
	mov( code_start, ebx );
	sub( ebx, eax );
	mov( eax, code_size );
	mov( $20, ecx );
	test( 8, format_flags );
	jz adjust_elf_section_headers_offset;
	mov( $28, ecx );
  adjust_elf_section_headers_offset:
	add( eax, [ebx+ecx] );
	mov( 1, eax );
	stosd;
	mov( 2, al );
	stosd;
	xor( al, al );
	call store_elf_machine_word;
	call store_elf_machine_word;
	mov( code_size, eax );
	call store_elf_machine_word;
	mov( [edx+1], eax );
	sub( free_additional_memory, eax );
	call store_elf_machine_word;
	mov( current_section, eax );
	inc( eax );
	stosd;
	mov( number_of_sections, eax );
	inc( eax );
	stosd;
	test( 8, format_flags );
	jnz finish_elf64_sym_section;
	mov( 4, eax );
	stosd;
	mov( $10, al );
	stosd;
	jmp sym_section_ok;
  finish_elf64_sym_section:
	mov( 8, eax );
	stosd;
	xor( al, al );
	stosd;
	mov( $18, al );
	stosd;
	xor( al, al );
	stosd;
  sym_section_ok:
	mov( 1+8, al );
	stosd;
	mov( 3, al );
	stosd;
	xor( al, al );
	call store_elf_machine_word;
	call store_elf_machine_word;
	mov( [edx+1], eax );
	sub( free_additional_memory, eax );
	add( code_size, eax );
	call store_elf_machine_word;
	mov( [edx+1+8], eax );
	sub( [edx+1], eax );
	call store_elf_machine_word;
	xor( eax, eax );
	stosd;
	stosd;
	mov( 1, al );
	call store_elf_machine_word;
	xor( eax, eax );
	call store_elf_machine_word;
	mov( asDword( "tab" ), eax );
	mov( asDword( ".sym" ), (type dword [edx+1]) );
	mov( eax, [edx+1+4] );
	mov( asDword( ".str" ), (type dword [edx+1+8]) );
	mov( eax, [edx+1+8+4] );
	mov( 0, written_size );
	mov( output_file, edx );
	call create;
	jc write_failed;
	call write_code;
	mov( edi, ecx );
	mov( free_additional_memory, edx );
	sub( edx, ecx );
	add( ecx, written_size );
	write(ebx, edx, ecx );
	jmp output_written;

end formatter;	




/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// The following are some extra declarations we need if this is
// a standalone version of FASM (stuff that HLA would normally emit
// for a PROGRAM but doesn't emit for a UNIT).


static

	// Stuff that the HLA exception handling system needs:

	MainPgmCoroutine__hla_	:dword; @external;
	MainPgmCoroutine__hla_	:dword; @nostorage;
								dword	&MainPgmVMT__hla_;
								dword	0;		/* CurrentSP */
								dword	0;		/* Pointer to stack */
								dword	0;		/* ExceptionContext */
								dword	0;		/* Pointer to last caller */
		
	MainPgmVMT__hla_ 		:dword := &QuitMain__hla_;


	// The exception handling system is expecting the following
	// redirection functions.
	
	procedure HWexcept__hla_;	@external( "HWexcept__hla_" );
	procedure HWexcept__hla_;
	begin HWexcept__hla_;

		jmp shorthwExcept__hla_;

	end HWexcept__hla_;

	procedure DfltExHndlr__hla_;	@external( "DfltExHndlr__hla_" );

	procedure DfltExHndlr__hla_;
	begin DfltExHndlr__hla_;	

		jmp shortDfltExcept__hla_;
		
	end DfltExHndlr__hla_;
	
#if( !standalone )

	procedure Raise__hla_; @external;
	
	proc( Raise__hla_ );

			#if( @defined( unix ) )
			
				mov( ExceptionPtr, ebp );
				
			#else
			
				byte $64, $8b, $2d;		//mov ebp, fs:[0]  (ExceptionPtr$)
				dword 0;
				
			#endif
				
		Unstack:
			cmp( (type dword [ebp+4]), &HWexcept__hla_ );
			je DoThisOne;
			mov( [ebp], ebp );
			jmp Unstack;
						
		DoThisOne:
			mov( ebp, esp );
			
			#if( @defined( unix ) )
			
				pop( ExceptionPtr );
				
			#else
			
				byte $64, $8f, $05;	// pop fs:[0] (ExceptionPtr$)
				dword 0;
				
			#endif
			
			add( 8, esp); 		//Remove HWexcept and coroutine ptrs
			pop( ebp );
			ret();

	end Raise__hla_;
	
	proc( shortDfltExcept__hla_ );
	
		push( eax );
		puts( "Unhandled HLA exception: $" );
		pop( eax );
		puthex32( eax );
		put_newln();
		exitProcess( 1 );
		
	end shortDfltExcept__hla_;
	
	proc( shorthwExcept__hla_ );
	
		mov( 1, eax );
		ret();
		
	end shorthwExcept__hla_;
		

#endif
	





///////////////////////////////////////////////////////////////////////////////
//


#if( standalone )

	// If this is a standalone version of FASM, them define fasmMain to be
	// the HLA main program.

	?_fasmMain :text := "fasmMain";
	procedure fasmMain; @external( "_HLAMain" );
	
#else

	// If this is a module to be called from C, then
	// define the parameter list that is going to be
	// passed to us.
	
	?_fasmMain :text := 
		"fasmMain"
		"("
			"fName		:dword;"
			"outName	:dword;"
			"memory		:dword;"
			"memsize	:dword;"
			"maxPasses	:dword;"
			"verbose	:dword"
		")";

		
	// Provide an external linkage so that the linker can
	// find this function:
	
	procedure _fasmMain; @cdecl; @external("_fasmMain" );
		
#endif
	
	#if( debug )
		procedure fasmDebug;
		begin fasmDebug;
		
			debugStr( "fasmMain" );
			
		end fasmDebug;
	#endif
			 
procedure _fasmMain;
begin fasmMain;

	#if( !standalone )
	
		// If this is being called as a C function,
		// we need to preserve the registers (note: not all
		// C compilers out there adhere to the Intel ABI,
		// so this code saves everything except EAX):
		
		push( ebp );		// To make things easy, let's create a stack frame.
		mov( esp, ebp ); 
		push( ebx );
		push( ecx );
		push( edx );
		push( edi );
		push( esi );
		
	#endif

	// FASM expects to use its own 64K stack, so we're going to create
	// a new stack for it. Begin by saving the stack pointer so we can
	// restore it at the end of the assembly.
	
	mov( esp, saved_Stack_Pointer );	
	
	#if( !standalone )
	
		// Initialize the BSS section with zeros if this is not
		// a standalone version. We must do this because the caller
		// can call this program multiple times and the code makes
		// some assumptions about the BSS section being zeroed.
		//
		// Note: on the very first call, clearedBSS will contain
		// true (as BSS has already been cleared by the OS). On
		// subsequent calls (cFASM only), we have to clear the BSS
		// segment.
		
		if( !clearedBSS ) then
		
			lea( edi, startOfBSS );
			lea( ecx, endOfBSS );
			sub( edi, ecx );
			add( 3, ecx );
			shr( 2, ecx );
			xor( eax, eax );
			cld();
			rep.stosd();
			
		endif; 
		mov( false, clearedBSS );
	
		// If this is not a stand-alone version, we need to copy the
		// parameters passed to the fasmMain function to a global location
		// where other code can access them.
	
		mov( fName, eax );
		mov( eax, input_file );
		mov( outName, eax );
		mov( eax, output_file );
		mov( memory, eax );
		mov( eax, C_memory );
		mov( memsize, eax );
		mov( eax, C_memsize );
		mov( maxPasses, eax );
		mov( ax, passes_limit );
		mov( (type byte verbose), al );
		mov( al, g_verbose );
		
	#endif	
	
	// Okay set up the new stack:
	
	lea( esp, stack[ 65536] );
	lea( eax, stack[ 4096] );
	mov( eax, stack_limit );
	#if( standalone )
	
		call BuildExcepts__hla_;
		
	#else
	
		pushd( &DfltExHndlr__hla_ );
		push( ebp );
		pushd( &MainPgmCoroutine__hla_ );
		pushd( &HWexcept__hla_ );
		#if( @defined( unix ) )
		
			pushd( 0 );		// Undefined exception pointer at this point.
			mov( esp, ExceptionPtr );
		
		#else
		
			xor( ebx, ebx );
			byte $64; // fseg:
			push( (type dword [ebx]) );
			byte $64; //fseg: 
			mov( esp, [ebx] );
		
		#endif
		mov( esp, MainPgmCoroutine__hla_[12] ); //ExceptionContext
		
	#endif
	
	pushd(0);			// No Dynamic Link.
	mov( esp, ebp );	// Pointer to Main's locals (there are none, but...)
	push( ebp );		// Main's display.


	
	try
	

			#if( standalone )
			
				puts( "flat assembler  version "+VERSION_STRING );
				put_newln();
				call get_params;
				if( @c ) then
				
					mov( &_usage, esi );
					call display_string;
					exitProcess( 1 );
				
				endif;
				
			#else
			
				if( g_verbose ) then
				
					puts( "Using flat assembler version "+VERSION_STRING );
					put_newln();
					
				endif;
			
				
			#endif

			call init_memory;

			call preprocessor;
			call parser;
			call fasmAssembler;
			call formatter;

			call display_user_messages;
			
			#if( standalone )
			
				movzx( current_pass, eax );
				inc( eax );
				putu32( eax );				//call display_number;
				puts( " passes, " );

											//mov( written_size, eax );
				putu32( written_size );		//call display_number;
				puts( " bytes." );
				put_newln();
				
			#else
			
				if( g_verbose ) then
				
					movzx( current_pass, eax );
					inc( eax );
					putu32( eax );				//call display_number;
					puts( " passes, " );

												//mov( written_size, eax );
					putu32( written_size );		//call display_number;
					puts( " bytes." );
					put_newln();
					
				endif;
				
			#endif

		
		exception( fatal.main_file_not_found )
			fatal_err( "source file not found" );	

	  	exception( fatal.out_of_memory_reading_file )
			fatal_err( "Ran out of memory while reading file" );
			
	  	exception( fatal.could_not_allocate_memory )
			fatal_err( "Insufficient system memory - could not allocate heap" );
			
	  	exception( fatal.out_of_memory )
			fatal_err( "out of memory" );
			
	  	exception( fatal.stack_overflow )
			fatal_err( "out of stack space" );
			
	  	exception( fatal.unexpected_end_of_file )
			fatal_err( "unexpected end of file" );
			
	  	exception( fatal.code_cannot_be_generated )
			fatal_err( "code cannot be generated" );
			
	  	exception( fatal.format_limitations_exceeded )
			fatal_err( "format limitations exceeded" );
			
	  	exception( fatal.write_failed )
			fatal_err( "write failed" );
		
		exception( aerr.file_not_found )
			asm_error( "file not found" );
		
		exception( aerr.error_reading_file )
			asm_error( "error reading file" );
		
		exception( aerr.invalid_file_format )
			asm_error( "invalid file format" );
		
		exception( aerr.invalid_macro_arguments )
			asm_error( "invalid macro arguments" );
		
		exception( aerr.unexpected_characters )
			asm_error( "unexpected characters" );
		
		exception( aerr.invalid_argument )
			asm_error( "invalid argument" );
		
		exception( aerr.illegal_instruction )
			asm_error( "illegal instruction" );
		
		exception( aerr.invalid_operand )
			asm_error( "invalid operand" );
		
		exception( aerr.invalid_operand_size )
			asm_error( "invalid size of operand" );
		
		exception( aerr.operand_size_not_specified )
			asm_error( "operand size not specified" );
		
		exception( aerr.operand_sizes_do_not_match )
			asm_error( "operand sizes do not match" );
		
		exception( aerr.invalid_address_size )
			asm_error( "invalid size of address value" );
		
		exception( aerr.address_sizes_do_not_agree )
			asm_error( "address sizes do not agree" );
		
		exception( aerr.prefix_conflict )
			asm_error( "disallowed combination of registers" );
		
		exception( aerr.long_immediate_not_encodable )
			asm_error( "not encodable with long immediate" );
		
		exception( aerr.relative_jump_out_of_range )
			asm_error( "relative jump out of range" );
		
		exception( aerr.invalid_expression )
			asm_error( "invalid expression" );
		
		exception( aerr.invalid_address )
			asm_error( "invalid address" );
		
		exception( aerr.invalid_value )
			asm_error( "invalid value" );
		
		exception( aerr.value_out_of_range )
			asm_error( "value out of range" );
		
		exception( aerr.undefined_symbol )
			asm_error( "undefined symbol" );
		
		exception( aerr.invalid_use_of_symbol )
			asm_error( "invalid use of symbol" );
		
		exception( aerr.name_too_long )
			asm_error( "name too long" );
		
		exception( aerr.invalid_name )
			asm_error( "invalid name" );
		
		exception( aerr.reserved_word_used_as_symbol )
			asm_error( "reserved word used as symbol" );
		
		exception( aerr.symbol_already_defined )
			asm_error( "symbol already defined" );
		
		exception( aerr.missing_end_quote )
			asm_error( "missing end quote" );
		
		exception( aerr.missing_end_directive )
			asm_error( "missing end directive" );
		
		exception( aerr.unexpected_instruction )
			asm_error( "unexpected instruction" );
		
		exception( aerr.extra_characters_on_line )
			asm_error( "extra characters on line" );
		
		exception( aerr.section_not_aligned_enough )
			asm_error( "section is not aligned enough" );
		
		exception( aerr.setting_already_specified )
			asm_error( "setting already specified" );

		exception( aerr.data_already_defined )
			asm_error( "data already defined" );

		exception( aerr.too_many_repeats )
			asm_error( "too many repeats" );
			
		exception( aerr.incomplete_macro )
			asm_error( "incomplete macro" );
			
		anyexception
			puts( "Unhandled HLA exception: " );
			puthex32( eax );
			put_newln();
		
	endtry;
	
QuitMain__hla_::


	// Restore the original stack:
	
	mov( saved_Stack_Pointer, esp );
	
	#if( !standalone )
	
		// If this is being called as a C function,
		// we need to restore the registers and return
		
		pop( esi );
		pop( edi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		pop( ebp );
		ret();
		
	#endif
	
	// If this is the stand-alone version, quit.
	
	exitProcess(0);
		
end fasmMain;
		
end fasm;
